<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yonagi&#39;s Sekai</title>
  
  
  <link href="https://yonagi04.github.io/atom.xml" rel="self"/>
  
  <link href="https://yonagi04.github.io/"/>
  <updated>2025-05-18T09:07:25.413Z</updated>
  <id>https://yonagi04.github.io/</id>
  
  <author>
    <name>Yonagi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一次实习之北京之旅</title>
    <link href="https://yonagi04.github.io/posts/2025/e4126e29285c/"/>
    <id>https://yonagi04.github.io/posts/2025/e4126e29285c/</id>
    <published>2025-05-02T17:01:41.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>差点忘了上次写博客是什么时候了。这学期初一直忙于找实习，所以没时间写博客，但telegram频道我还在偶尔搬运点东西。找到实习之后本来打算入职之后写一篇的，没想到入职没几天电脑就进了水，只好把后盖和散热器拆开晾了接近一个星期，因此一个星期没得用电脑。现在电脑已经好了，因此来写这么一篇博客，讲讲第一次实习之北京之旅。</p><h2 id="投简历与面试">投简历与面试</h2><p>暑期实习我投了不少公司，但只有寥寥几家公司给了我笔试或者面试机会。小厂就不算进去了，这里只统计一些中大厂。</p><table><thead><tr><th>公司 and 部门 and 岗位</th><th>面试流程</th></tr></thead><tbody><tr><td>字节跳动 广告部门 后端</td><td>一面羞辱面，后续投了国际商业和飞书直接简历挂</td></tr><tr><td>腾讯 s3线 hr部门 后端</td><td>一面挂</td></tr><tr><td>腾讯 pcg线 qq部门 客户端开发</td><td>二面挂</td></tr><tr><td>腾讯 pcg线 腾讯地图 客户端开发</td><td>已拒面试，当时已经入职美团</td></tr><tr><td>灵犀互娱 游戏测试开发</td><td>一面挂</td></tr><tr><td>饿了么 客户端开发</td><td>笔试挂</td></tr><tr><td>网易互娱 游戏测试开发</td><td>已拒面试，当时已经oc美团了</td></tr><tr><td>米哈游 游戏测试开发</td><td>笔试挂</td></tr><tr><td>cvte 软件测试</td><td>oc，但是拒了</td></tr><tr><td>anker 软件测试</td><td>一面挂</td></tr><tr><td>美团 核心本地商业-业务研发 测试开发</td><td>offer，已入职</td></tr></tbody></table><p>（所以说双非的同学其实在找工作这方面是很困难的，一定要沉得住心，努力背八股+刷题，说不定明天就能拿到offer了）</p><p>最后的话是去了美团，做测试开发。</p><h2 id="启程">启程</h2><p>广州到北京的距离大概是两千多公里，坐飞机的话得飞两个半小时，而坐高铁需要12h起步，坐普速火车则更是需要花上整整一天的时间。权衡利弊，我最后选择了飞机，毕竟高铁票不便宜，火车的时间太长，飞机则是能很好地权衡价格和时间，相对来讲是不错的选择。</p><p>我是4月19号来的北京，从白云机场飞到北京首都。这是我人生第二次坐飞机，第一次坐飞机是中考结束之后从外婆家回广东的时候，坐了飞机，具体机型不记得了，只记得是一个窄体客机，飞机降落的时候我的耳朵非常不舒服，这也就让我对飞行留下了不太好的印象。这次坐飞机特意挑了宽体机型客机，执飞的是空客的a350-900，希望能改善一下我的耳朵状况。</p><p>从学校辗转两个小时的地铁和公交车到达白云机场，去值机柜台值机。有很多外国人，而且我正好前后都是外国人。说实话，他们的气味真的很难闻，如果用了廉价香水那么气味更加呛人</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/baiyun-airport.webp" alt=""></p><p>安检通过了，在登机口附近等待，当天广州的天气不是很好，阴沉沉的，早上还下了雨。不过并不耽误飞机起飞就是了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/waiting-4-plane.webp" alt=""></p><p>登机完成，我挑的是窗口位置的座位，飞机的上座率达到了100%，完全没有空位。不愧是京广干线的航线啊。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/on-plane.webp" alt=""></p><p>登机过了差不多20min左右，机舱门关闭，飞机推出，机舱内开始播放安全演示视频。滑行的时间倒不是很长，也没有等待很久，就起飞了，起飞时久违的超重感让人意识到自己就在飞机上</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/take-off.webp" alt=""></p><p>在飞机上看到了很漂亮的蓝天白云，想起了米津玄师的新曲《Bow And Arrow》的封面</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/blue-sky-and-white-cloud.webp" alt=""></p><p>飞机上面还有小触摸屏，可以实时观看飞机的位置，当然也可以看电影，玩小游戏之类的</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/tv-on-plane.webp" alt=""></p><p>途中碰到了一些颠簸，不过最后成功落地北京</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/view-of-beijing.webp" alt=""></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/shoudu-airport.webp" alt=""></p><h2 id="到达北京">到达北京</h2><p>北京当天的天气意外的不太冷，在地铁上我全程穿着短袖也不会感到寒冷，之后拖着箱子走在北京的路上更是感觉舒适。</p><p>落地北京，当然是不知道要吃什么的，所以只好吃了kfc，吃了老北京儿鸡肉儿卷儿。（其实来北京半个月了，我也不知道北京有什么好吃的，简直是美食荒漠）</p><p>住的酒店很糟糕，这家酒店的名字就不放出来了，是建在一个小区里面的。酒店的房间很小，没有窗户，装修留下的刺鼻气味很浓，呛得人只想呕吐，导致我一整个晚上都没睡好。</p><p>第二天就把房子看好了，住的地方离公司不太远，一个月不算水电差不多3300人民币左右，不算便宜了，不过好在小区安保设施齐全+物业服务态度好+房间大小合适，倒也能接受。</p><h2 id="入职美团">入职美团</h2><p>确定好房子之后的第二天，我就入职了美团。当天去的比较早，九点之前就到公司了。先是领工卡和电脑什么的，本来大象上显示我是领的m2芯片的MacBook Pro，结果资产管理那边发给我的是19年款intel芯片的MacBook Pro，算不算是一种偷工减料？</p><p>最后贴一张入职时候拍的一张美团的照片</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.37/img/content/meituan.webp" alt=""></p><h2 id="工作与生活">工作与生活</h2><p>美团的工作体验还算不错，虽然福利较少，但工资报酬还算不错，且好在同事和+1都很和蔼，并没有我想象中职场中严肃的感觉。</p><p>主要的工作内容是负责美团质效技术部的内部工具的开发和测试，俗称“造轮子”，而且这个轮子还没有造完，所以这个组肯定是很卷的。我入职第一天是晚上八点半下班，第二天就变成九点半了，之后的话下班时间在晚上九点和九点半之后反复横跳，虽然实习生不一定要跟着正式员工一起加班就是了</p><p>不过上班有一个好处，就是每天的工作都能转化成非常明确的报酬……今天干了一天活，拿了xxx钱什么的……如果是读书的话，可能就没有这么快的正反馈</p><p>午餐和晚餐时间一般会和mt、其他组的同事去吃饭（别问为什么不是我们组的，因为mt是从别的组调过来的），吃饭的地点选择倒是很多样，不用担心吃腻。早餐的话我买了麦当劳的早餐卡，每天早上一般是一个芝士蛋麦满分+美式咖啡，7块钱一份，在北京这个地方来讲已经相当便宜</p><p>平时周末的话一般用餐补点外卖，不过北京是美食荒漠，根本不知道吃什么</p><hr><p>大概就先写这么多吧，比较到北京的时间也不是很久。这几天又回广州了，回广州考试，考完试又得回北京接着上班</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;差点忘了上次写博客是什么时候了。这学期初一直忙于找实习，所以没时间写博客，但telegram频道我还在偶尔搬运点东西。找到实习之后本来打算入职之后写一篇的，没想到入职没几天电脑就进了水，只好把后盖和散热器拆开晾了接近一个星期，因此一个星期没得用电脑。现在电脑已经好了，因此来</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="实习" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="实习" scheme="https://yonagi04.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="北京" scheme="https://yonagi04.github.io/tags/%E5%8C%97%E4%BA%AC/"/>
    
  </entry>
  
  <entry>
    <title>我是如何学习日语的</title>
    <link href="https://yonagi04.github.io/posts/2025/98f5159820c0/"/>
    <id>https://yonagi04.github.io/posts/2025/98f5159820c0/</id>
    <published>2025-01-21T16:49:35.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>博客已经许久未更，差点要把这个网站给遗忘，不过好在还是想起来了。之前已经简单介绍了自己的未来计划，这次就介绍一下自己是怎么学日语的吧。</p><p><strong>开局叠甲：本人并非日语专业学生，非日语大神，目前日语水平为 JLPT N2，口语水平大致在 N3~N4之间，专业程度较低，提供的方法仅供参考。笔者的日语学习开始较早且日语接触较多，有长期的积累，因此以下的方法不一定适用于所有人。</strong></p><h2 id="听">听</h2><p>如果是应对 JLPT 考试，那么最有效的方法当然是高强度听 JLPT 的听力。一套试题的听力时间大概50min左右（N1 和 N2），所以可以在上班通勤路上慢慢听。</p><p>但是，就我个人的感受而言，日常生活的日语和 JLPT 考试的日语几乎是脱节的，具体表现为——JLPT 考试中出现的一些“口头”表达在现实中出现频次较少，且 JLPT 考试的语速明显不如日常生活中的日语（N1 考试除外）。不信？考完 JLPT，申请个日本旅游签，去日本旅游一次就知道了。</p><p>所以想要真正提高日语听力能力，我个人的方法很常见但有很好用：看日剧/日本新闻，且尽可能选择有日语字幕的片源进行观看，观看的过程中可以留心一下日本人的口语表达，以及一些单词。当然，如果单纯想磨耳朵的话，把广播（如 NHK）或电视（如 NHK、TBS、Nippon TV）的直播源 patch 下来并在电脑 / 手机上播放也未尝不是一个好选择。</p><h2 id="说">说</h2><p>JLPT 考试和雅思、托福等其他国际性语言考试不太一样，考试项目并不包括口语，所以经常会出现有 JLPT 考生在获得 N1 / N2 资格后口语表现却一塌糊涂的情况。花钱请日本的口语老师当然是最佳的选择，但是口语课的课时费并不便宜；找日本的语伴当然是个不错的选择，但怎么找一个合适且“不会给ta添麻烦”的语伴又是一件头疼的事情。那么如何做到既省钱，又不需要语伴，还能练口语呢？</p><p>我在看 Youtube 的时候曾经看到过这样一个口语练习法，名为 “Shadowing 练习法”。具体做法是：先找好一段音频材料（不要太长，且尽量贴近生活实际，可取材自动画、日剧等），听一遍并尝试将内容全部记录下来；记录完成之后，找到这段音频材料对应的文字材料，校对记录的内容是否有差错；校对完成后，尝试默读几次，仿照材料中说话人的语速、语调进行练习；最后，播放音频，在播放音频的同时开始朗读材料，并尽可能跟上材料中说话人说话的节奏。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/_zZdTKS_Z9g?si=4LAC4cGRh1P6mVlL&amp;start=395" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><p>在 GPT 大行其道的时代，我们也可以利用 GPT 练习口语。GPT 的移动端支持语音聊天功能，可以尝试和 GPT 聊天，聊天的同时练习口语。</p><h2 id="读">读</h2><h3 id="文字、词汇与文法">文字、词汇与文法</h3><p>文字词汇和文法是日文阅读的基础，一切的阅读前提都建立在有足够的词汇量和语法量上，但偏偏这两样东西是最没有歪路可走的，只能靠背。笔者学习文字词汇和文法使用的是红蓝宝书，文法学习配套 B 站的免费日语文法课，文字词汇则是配套使用了 Moji辞書 的 “MojiTest” App，并购买了它们的会员。</p><h3 id="阅读">阅读</h3><p>对于中国人来讲，因为日语中存在大量的汉字，所以阅读日文相较于非汉字圈的人而言有先天性优势，但若只看汉字，则非常容易“望文生义”，错误地领会其背后的含义，最后闹出笑话或误会。</p><blockquote><p>最近在知乎上看到的一条，“南京大屠杀”在日文中为『南京事件』，很多没学过日文的中国人望文生义，以为日本人淡化南京大屠杀。实际上在日文中能用到『事件』形容的事情基本上都是死伤极其惨重的事情，例如『地下鉄サリン事件』。</p></blockquote><p>那么，如何练习阅读？笔者最常用的练习日语阅读的网站是 “Yahoo！Japan”，即雅虎日本（ヤフージャパン），具体来讲应该是雅虎日本的新闻（ニュース）板块，里面的文章主要都为日本国内的新闻和国际新闻（当然，也包括中国的新闻，也包括了在中国大陆提都不能提的新闻）。不讨论新闻的内容是否“政治正确”，单纯讨论对阅读能力提升的帮助的话，雅虎日本是极佳的练习资源。</p><p>当然，也可以尝试多接触其他一些日本的网站，或者把电脑、手机的默认语言设置为日语，Google 搜索的默认结果也设置成日语。</p><h2 id="写">写</h2><p>JLPT 考试中不包括写作板块，所以仍然有不少考生在获得 N1 / N2 资格后不能掌握日文文章的撰写能力。日文的书面表达相当讲究，远比中文和英文要讲究得多，因此初次接触的人不大容易写好。</p><p>当然，我们也可以使用 GPT 来练习写作。具体做法是，让 GPT 随机给定一个主题，然后用户写一篇文章发送给 GPT，GPT 帮助用户修改词汇 / 文法 / 表达上存在的问题，用户修改后再次发送给 GPT，然后如此反复。根据这个做法，自行撰写 Prompt 并发送给 GPT 即可开始练习。</p><p>如果刚开始不能写出长篇的文章，那么可以从写最简单的句子开始，也就是尝试用日文和 GPT 聊天，基本做法和上述类似。</p><h2 id="结语">结语</h2><p>以上就是笔者的一些日语学习方法，希望可以帮助到有需要的人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客已经许久未更，差点要把这个网站给遗忘，不过好在还是想起来了。之前已经简单介绍了自己的未来计划，这次就介绍一下自己是怎么学日语的吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开局叠甲：本人并非日语专业学生，非日语大神，目前日语水平为 JLPT N2，口语水平大致在 N3~N4之间，</summary>
      
    
    
    
    <category term="外语学习" scheme="https://yonagi04.github.io/categories/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="日语" scheme="https://yonagi04.github.io/categories/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E6%97%A5%E8%AF%AD/"/>
    
    
    <category term="日语" scheme="https://yonagi04.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
    <category term="润" scheme="https://yonagi04.github.io/tags/%E6%B6%A6/"/>
    
  </entry>
  
  <entry>
    <title>大日本帝国是如何被低智商民粹主义反噬的？</title>
    <link href="https://yonagi04.github.io/posts/2024/cfc2fe83dba5/"/>
    <id>https://yonagi04.github.io/posts/2024/cfc2fe83dba5/</id>
    <published>2024-12-30T10:44:01.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自微信公众号 “种豆包Chong”，视频版发布在 B 站和 Youtube，均为同 ID。</p></blockquote><p>大家好，本期我们来讲讲大日本帝国的低智商民粹主义。</p><p>在20世纪初，为了应对来自海的对面的敌对势力，大日本帝国不惜放任国内媒体和 “网红”大肆发布极具煽动性、误导性、欺骗性的内容，自作聪明的玩弄低智商民粹主义，之后惨遭反噬引发了灾难级后果，后果之严重不亚于二二六兵变。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/640.png" alt="如果爱国能赚钱？"></p><p>低智商民粹主义就和泡沫一样，狂热的极端氛围迟早会有爆的一天，尤其是当爱国被盈利化，靠着爱国就能赚大钱，使得爱国饭、民粹饭、煽动饭、被各路妖魔鬼怪视为香饽饽，利用媒体一个比着一个的看谁更爱国更民粹更极端来吸引关注，其结果只会是害了国家坑了百姓。</p><p>1894年<strong>甲午战争</strong>爆发，大清惨败。作为大日本帝国的第一次对外战争，经过了以皇国史观为核心的臣民化教育、集体主义教育，以及对曾经的顶级东亚霸主在军事制度和政治制度上都取得了压倒性的胜利彻底塑造了日本人的国家意识。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/641.png" alt="低智商民粹主义的惯用手段，极端仇外"></p><p>且甲午战争战前、战时、战后的大日本帝国国内均出现了大量针对清国人的例如“猪尾辫人”等蔑称，对于这么明显的民族歧视舆论的流行，大日本帝国却放任其野蛮发展。</p><p>一种通过贬低对手来达到给民众注入兴奋剂从而增强本国民族主义效果的常用手段，到了现在也很常见啊。这是日本在历史上第一次居高临下的俯视中华帝国，给予了当时的日本民族极强的自豪感，客观上抬高了日本的民族自尊心阈值。</p><p>甲午战争战败后，大清和大日本帝国之间签订马关条约，不得已割让包括了辽东半岛在内的大量领土，并且支付高额赔偿金给大日本帝国。可随后，以沙皇俄国为首的西方列强为了防止大日本帝国独占中国的利益，叫来了德国和法国来一同斡旋甲午战争的战后事宜。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/642.png" alt="他们抢走了我们赢得的，都是他们的错！"></p><p>由此便发生了俄法德介入施压要求大日本帝国放弃索取我国的辽东半岛的史称三国干涉还辽的事件。由于彼时的大日本帝国还不具备反抗西方列强的国力，迫于压力大日本帝国只得放弃索取辽东半岛。话虽如此，这个仇可算是记下了。</p><p>1899年义和团运动爆发，在一年后的1900年6月慈禧太后借着国内激昂的 “扶清灭洋”势头，以光绪皇帝的名义向八国列强宣战。在八国联军入侵我国的过程中日本兵是人数最多的，是绝对主力。（笔者没有将沙俄强占我国东北地区列入八国联军侵华战争之中）</p><p>原因是1900年前后的美国和英国各自在忙着镇压殖民地的叛乱，这两个在东亚有着较大势力的列强暂时腾不出手，除沙俄外的其他列强在东亚的军事力量不太够，从本土调集军队的话又太过于遥远。</p><p>于是英国说服其他列强以类似外包的形式把惩罚大清的任务委托给了大日本帝国，组成了以大日本帝国为主力，沙俄次之，大英帝国再次之的八国联军。</p><p>结果众所周知，八国联军轻轻松松的击败了大清，清廷被迫签订辛丑条约，列强又进一步的瓜分了大清。此时就发生了大日本帝国非常不愿意看到的一幕，由于沙俄趁着义和团运动时期的混乱，派遣大军进入我国东北地区，事实上的占领了东北，随时可能南下的沙俄让大日本帝国倍感紧张，经过一系列复杂事件后，出于限制沙俄的目的大日本帝国和大英帝国缔结同盟条约，大日本帝国和沙俄的关系开始变得微妙起来。</p><p>日俄战争不仅是军事上战争，也是媒体的战争。当时的大日本帝国对沙俄与其说是反俄，不如说是恐俄。</p><p>但【反】和 【恐】实际上都是基于自保本能的情绪，是一体两面的，也都是滋生极端民粹主义的土壤。于是大日本帝国民间对俄出现了两种态度，即主战论和非战论。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/643.png" alt="两个帝国主义国家的邪恶交易"></p><p>起初，因为对大日本帝国政治极具影响力的伊藤博文主张对俄协商，认为不应当反对沙俄独占我国东北地区，应当作为利益交换，主张通过认可沙俄独占东北地区的利益以换取沙俄认可大日本帝国独占朝鲜半岛地区的利益，学术界称之为“满韩交换”。但沙俄压根就没搭理伊藤博文，根本没有把彼时的大日本帝国放眼里。</p><p>1902年4月8日，清日俄三国签订《交收东三省条约》，沙俄在条约中承诺会把驻在东北地区的军队分三批依次撤出。由于沙俄作出了“示弱”姿态，大日本帝国和沙俄之间一下子就“友谊”起来了，主要新闻报纸们也迅速跟进，一起随着总路线摇摆。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/644.png" alt="没有主见，和总路线一起摇摆罢了！"></p><p>新闻报社【日本】、【每日新闻】、【东京日日新闻】、【国民新闻】、还有以对俄强硬而闻名的【黑龙】等新闻媒体都纷纷开始发布非战论日俄友好的社论，特别是日本刊载的诸如</p><p><strong>“日俄两国国民的亲密关系比日英同盟还要坚固”</strong></p><p><strong>“执着于历史遗留问题而忽视大局的那些言论才是我们应该警惕的”</strong></p><p>等社论在日后看来真的很让人绷不住。</p><p>而作为读者画像以城市劳动者，或者说以工人阶级为主的【万朝报】则是在主张日俄非战的基础上依然不放松对沙俄的警惕，认为不能光听其言，要观其行，竟然没跟着总路线摇摆，非常的格格不入。</p><p>1903年4月8日，到了《交收东三省条约》所规定的沙俄第二批撤军期限，沙俄不仅没有从东北撤军，反而在增加兵力，并且跨过了大清与大韩帝国的国境线开始了屯兵驻扎。</p><p>局势又一次错综复杂了起来，然而大日本帝国政府却迟迟没有作出回应，各种小道消息满天飞，出现了一些不信邪的声音，这时候藩阀政府的领头人们桂太郎、伊藤博文、山县有朋等人也都慌了神儿了，聚集在在位于京都的别墅庄园里秘密讨论对俄方针，只可惜辟谣是不存在的，因为沙俄背弃条约，不撤兵反倒增兵就是铁一般的事实。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/645.png" alt="讲个笑话，俄国人的信誉"></p><p>没办法，沙俄对土地的渴望就是这么的吃相难看。日俄关系就此急速恶化，值得注意的是虽然这时的日俄关系非常紧张，但在大日本帝国民间仍然是以东京朝日新闻，时事新报等主流大媒体为代表的**『对俄施压派』**占据绝对主流，对俄施压派反对直接与沙俄开战，主张应当利用日英的同盟关系以及用沙俄亲手白纸黑字签署的《交收东三省条约》向沙俄施加压力，迫使其从东北完全撤军，不战而屈人之兵。</p><p>舆论风向的反转发生在1903年的6月。这里画了一张当时主要在东京地区发行的新闻报纸和偏向的表格，可以参考一下。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/646.png" alt=""></p><p>明治维新后的大日本帝国开放引进了许多西洋技术，其中印刷术在自由民权运动时期，因为民间设立了大量政治社团，这些个社团都需要有自己的机关报纸来向民众表达本社团的思想和意识形态，带动了大日本帝国新闻业的迅猛发展，各大新闻报社你方唱罢我登场。</p><p>进入20世纪开始，各大新闻媒体之间的竞争非常激烈，为了最大化的盈利，也就是为了能卖出更多的报纸。新闻媒体往往需要付钱请那些在社会上具备影响力的人来自己这边写社论，与此同时一些希望获得影响力的人也会主动来找新闻社通过写一些内容比较劲爆的社论来博取关注。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/647.png" alt="你给钱，我办事"></p><p>对于现在的我们来说这种事已经司空见惯，不就是新闻社找来一些专家教授站台背书嘛。但那个时候的大日本帝国是头一次出现了新闻媒体与专业知识人之间互相渗透的现象，对当时的日本人民来说是非常新鲜的现象。跟现在可不一样，现在越是依靠专家教授来背书的才是最不能相信的。</p><p>1903年6月10日发生了**『帝大七博士意见书』**事件。以东京帝国大学法学教授户水宽人为中心，以及中村进午・寺尾亨・高桥作卫・金井延・富井政章・小野塚喜平次，共7位顶尖大学的博士向时任内阁总理大臣的桂太郎提交了有关日俄情势的意见书，史称七博士意见书事件。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/648.png" alt="煽动民粹既能获得威望又能收获财富"></p><p>随后户水宽人在同月24日将意见书全文刊登在了东京朝日新闻上了，意见书中痛斥桂太郎内阁的软弱无能，指责其对俄外交政策令整个大日本帝国感到羞耻，强烈主张中国东北、朝鲜半岛涉及大日本帝国重大安全利益，倘若满韩有失则大日本帝国本土危在旦夕，沙皇俄国必须从中国东北全面撤军，大日本帝国为此应当不惜一战。</p><p>讲的那是一个热血沸腾，对那个时代的日本人民来说，大学的博士应该是一群没日没夜的泡在象牙塔里，仿佛世外仙人一般两耳不闻窗外事，一心钻研学术的人才对，所以在当时大学的教授博士是很受人尊敬的。</p><p>而像户水宽人这样这么年轻就取得博士学位，然后坦坦荡荡的公开自己的对俄态度，主动参与世俗的话题。可以说是非常罕见的。</p><p>户水宽人一下子成为了现象级爆款，开始不断的有新闻媒体邀请户水宽人发表社论举行演讲，其他新闻媒体也在接二连三的报道户水宽人的一言一行相比之下，其他对俄强硬派就显得那么暗淡无光。因为其他对俄强硬派都太不够极端了，所以**【对俄强硬】**这一舆论热点开始集中于户水宽人一人。</p><p>户水宽人这一现象级爆款的出现一举扭转了对俄非战论，也就是对俄施压论在舆论场上的优势，俗话说的好，打不过就加入，毕竟媒体是要赚钱的。在帝大七博士事件后，大日本帝国舆论场开始此起彼伏的涌现各式各样的对俄强硬发言，都开始抢着吃这口爱国饭。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/649.png" alt="怎么全是井外势力啊"></p><p>户水宽人也是不甘示弱，直到日俄宣战前，户水宽人的发言可谓是层层加码，从痛斥藩阀政府的软弱外交到要求不惜一战也要让沙俄势力完全退出满韩地区，再到散播日俄必有一战不可避论，最后到就算沙俄愿意完全退出满韩地区那也要跟沙俄打，打服了为止，要打到沙俄承认大日本帝国在东亚地区的特殊地位才行。</p><p>不停的给日俄情势上强度上价值，整个舆论场也跟着水涨船高，使得低智商民粹主义裹挟了国家政策方向，大量民众开始了无脑的追星式爱国。</p><p>“户水宽人一定就是对的！”</p><p>“户水宽人就是日俄情势方面的权威专家！”</p><p>残酷的战争也变得如同儿戏一般，根本没人在乎战争所带来的士兵伤亡，对外贸易的负面影响，战争的目的是什么以及最重要的军费究竟从哪来。</p><p><strong>把危机四伏的国际情势和战争当儿戏是吧，等着，好日子马上到你家</strong></p><p>就这样事态发展到了藩阀政府压制不住大日本帝国内部的战争狂热，沙俄那边也是根本不打算收敛自己对土地的贪婪丑态，完全不让步。日俄终于还是到了不得不用战争来解决的地步。</p><p>1904年2月4日，大日本帝国政府召开御前会议，会议上作出决议放弃与沙俄的外交交涉，全面备战武力军事行动。既然战争已经不可避免，那么如何筹集军费就变成了一个必须面对的难题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/650.png" alt="不要敬酒不吃吃罚酒"></p><p>大日本帝国政府计算出来的战争军费预计需要约18亿日元，这是是一笔天文数字级的费用，几乎是甲午战争军费的9倍，是当时大日本帝国政府5年的财政收入的总和。</p><p>所以不用一些非常手段是根本不可能筹集出这么多资金的，由此开始海量举债，经过时任日本银行副总裁高桥是清的交涉，大日本帝国成功在伦敦和纽约等地发行了对外国债。</p><p>另一方面在国内也发行了面向日本人的对内国债，号召日本人民积极踊跃购买国债支持国家。不过号召的方式有点硬核，直接由政府派出“工作人员”挨家挨户上门家访现场“监督”并“指导”日本人民购买国债，说白了就是强制购买，低智商民粹主义拥趸直接傻眼了。</p><p><strong>“爱国不是能赚钱吗？我爱国可不是为了掏钱！”</strong></p><p>仅靠售卖国债仍然不足以支撑日俄战争的预算。于是在1904年4月1日，大日本帝国通过**『非常特别税法案』，大幅提高了地税、营业税、所得税、酒税、砂糖消費税、酱油税、注册税、交易所税、狩猎免许税、矿区税、进口税的税率。**</p><p><strong>新增食盐消费税、毛织物消费税、石油消费税、绢布消费税，提高民事诉讼和商事非诉事务的诉讼印纸价格，可以理解成“诉讼税”，并实行烟草专卖制。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/651.png" alt="好日子还在后头呢"></p><p>面对已然失控了的民间舆论环境，退无可退的藩阀政府在同年11月与立宪政友会约定，待到日俄战争结束后，藩阀政府会在元老会议上向明治天皇推荐立宪政友会总裁西园寺公望担任新一届的内阁总理大臣。</p><p>1905年1月1日大日本帝国又实施了第二次非常特别税，<strong>刚才提过的那些税种在第一次非常特别税法案增税后的税率的基础上再次提高了税率，额外提高了售薬営業税、印紙税的税率。新设邮票印紙税、砂金採取地税、通行税、纺织物消費税、米籾进口税，提高行政诉讼手续费。永久性设置遗产继承税，并实行食盐专卖制。</strong></p><p>开启战争后，这好日子是宛如排山倒海一般的滚滚而来。千万不要以为其他人玩弄低智商民粹主义和自己没关系，到时候真出了事是要所有人来一同承担的。日本人民老老实实给天皇当臣民已经够苦的了，然后还天降横祸必须要跟着承受又重又多的苛捐杂税和征兵负担，别忘了，血税也是税。</p><p>低智商民粹主义永远只会站在道德制高点上代表所有人民，同时又视人民如草芥。日俄战争期间顶级网红户水宽人没有发表过一篇主张应该减轻日本人民负担的社论。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/652.png" alt=""></p><p>极端爱国依旧盛行在大日本帝国舆论场之中，新闻媒体疯狂报道各种赢赢赢，诸如我军势如破竹，俄军费拉不堪，完全不提及己方伤亡和当下的财政状况。</p><p>户水宽人还在开战后妄议满洲领有问题，声称沙俄退出满韩地区后大日本帝国应当派兵占领这些土地。看见了吧，低智商民粹主义的那层皮里面其实就是帝国主义。</p><p>之后还出版《世界的大势与日俄战争的结末》一书，书中称沙俄应当割让贝加尔湖以东的所有领土，受不了了，颅内狂想也要有个限度吧。在我们看来这是完全不切实际的夸夸其谈，可当时各大新闻媒体却都在盛赞户水宽人的雄壮发言，称赞其正在勇敢无畏的努力为国家争取利益。</p><p>媒体界逐渐失控，**是否支持和赞美户水宽人决定了这家媒体有没有人关注，报纸能不能卖得出去。**就这样劣币驱逐良币，舆论界已然没有非战论的生存空间了。最终，原本在万朝报工作的幸德秋水选择辞职，与堺利彦创立【周刊平民新闻】，直到战争结束都一直在坚持宣传反战思想。</p><p>户水宽人几乎已经事实上完全替代了政府在舆论场上的地位，明明是个政治素人，既不是官僚又不是军人，不过是一位学者的户水宽人却成为了日俄战争的绝对权威，典型的素人变成了权威。</p><p>日俄战争末期，联合舰队歼灭了远道而来波罗的海舰队，大日本帝国国内一片沸腾，民众对全面赢得战争胜利的期待值达到顶峰，可战役上的胜利根本无法掩盖在财政上的巨大压力，国力几近被掏空的大日本帝国已是强弩之末。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/653.png" alt="当残酷的现实击破了低智商民粹的春秋大梦之后？"></p><p>随后邀请美国总统西奥多罗斯福中间斡旋日俄和谈，这个时候户水宽人又一次出现了，称沙俄必须割让整个库页岛、整个勘察加半岛、东北亚的所有沿海州，外加支付赔偿金30亿日元。</p><p>简单粗算一下，根据日本三菱银行数据，20世纪初大日本帝国的1日元相当于现在的2万日元，也就是说户水宽人要求的30亿日元赔偿金约合现在的60兆日元,差不多是人民币2.8兆。俄罗斯联邦在2022年一年的GDP都不够2.8兆人民币，可见当时户水主张的30亿日元赔偿金有多离谱。</p><p>显然这种条件沙俄是不可能接受的，最终在美国的朴茨茅斯，日俄两国签订和约。和约的主要内容有大日本帝国获得了大韩帝国的支配权，大连·旅顺的租借权，长春-旅顺段，即南满洲铁路及沿线矿物的所有利权，沙俄在东北亚沿岸州海域的捕鱼权。沙俄军队撤出东北地区并割让库页岛北纬50度以南的部分给大日本帝国。</p><p>是的，你没有看错，低智商民粹主义煽动的给日本人民带了沉重负担的日俄战争的结果就是连一分钱的赔款都没有！低智商民粹主义开始迅速反噬大日本帝国。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.36/img/content/nippon-history/654.png" alt="低智商民粹真的于己有利吗？"></p><p>美好的幻想和沉重的现实形成的巨大落差引爆了民众的愤怒，如同火山喷发一般一发不可收拾，低智商民粹主义氛围的余温依旧没有消散。</p><p><strong>“形势不是一片大好吗？！”</strong></p><p><strong>“波罗的海舰队不是全灭吗？！”</strong></p><p><strong>“为什么是这么一个结果？！”</strong></p><p><strong>“一定都是投降失败主义的藩阀政府的错！”</strong></p><p>没有人相信，也没有人愿意去相信那些如梦如幻月的报道和社论其实都是假的。1905年9月5日，数万名愤怒的民众突破了警察的封锁，聚集在东京的日比古公园举行抗议。</p><p>散会后民众的怒火仍然没有消散，随后在内务大臣官邸、二重桥、京桥新富座接连发生了警民暴力冲突事件，事态逐渐演变成了一场ぼうらん，大量派出所、警察署、市街电车遭到了放火袭击。</p><p>愤怒的民众们包围了由桂太郎所控制的长州藩阀政府喉舌媒体『国民新闻』的总部并进行了攻击。9月6日来不及经议会程序，藩阀政府上奏明治天皇，随后明治天皇以敕令的形式第一次下达戒严令，史称**『日比古烧打事件』**。</p><p>日比古烧打事件中17人死亡，2000多人受伤，2000多人被拘捕，311人遭到检察院起诉，其中87人被判有罪。</p><p>可能有观众会认为仅从后果来看的话好像并不是很重量级？不要只看表面结果，整个日俄战争从酝酿到勃发再到结束，大日本帝国政府有无数次机会可以阻止“网红”们一个赛这一个的散播低智商民粹主义言论，禁止他们吃这口流量爱国饭，可结果却是选择放任其野蛮发展。</p><p>反倒是确实再也打不下去了，必须要和沙俄缔结朴茨茅斯和约的时候，由于户水宽人依旧激烈反对和谈，要求接着打下去，大日本帝国政府不得已动用『文官分限令』的11条第4项的兜底条款，强行解职了户水宽人的东京帝国大学教授身份。</p><p>可惜覆水难收，早知如此何必当初，在和谈前夕对户水宽人给予解职处分正好让他成为了英雄，勇敢无畏说真话的户水宽人被软弱无能的政府“封号”了。弄巧成拙又一次刺激了低智商民粹主义，提高了户水宽人的个人威信。</p><p>此后藩阀政府的威信骤然下降，在日比古烧打事件的3个月后，作为大日本帝国建国功勋组织的萨长藩阀终于迫不得已把政权交给了由西园寺公望所率领的立宪政友会。</p><p>大日本帝国正式进入了藩阀·政党迭立时代，政治开始走向大众化，也为后来所谓的『大正民主风潮』打下了一定的民意基础。所以说低智商民粹主义是非常危险的，自信以为低智商民粹主义可以为我所用的，结局很有可能是葬送了自己。120年前的教训犹在眼前，希望现在的日本国不要重蹈覆辙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转自微信公众号 “种豆包Chong”，视频版发布在 B 站和 Youtube，均为同 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家好，本期我们来讲讲大日本帝国的低智商民粹主义。&lt;/p&gt;
&lt;p&gt;在20世纪初，为了应对来自海的对面的敌对势力，</summary>
      
    
    
    
    <category term="历史" scheme="https://yonagi04.github.io/categories/%E5%8E%86%E5%8F%B2/"/>
    
    <category term="近代史" scheme="https://yonagi04.github.io/categories/%E5%8E%86%E5%8F%B2/%E8%BF%91%E4%BB%A3%E5%8F%B2/"/>
    
    
    <category term="近代史" scheme="https://yonagi04.github.io/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"/>
    
    <category term="日本史" scheme="https://yonagi04.github.io/tags/%E6%97%A5%E6%9C%AC%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>以后的一点计划</title>
    <link href="https://yonagi04.github.io/posts/2024/eb8e8616b295/"/>
    <id>https://yonagi04.github.io/posts/2024/eb8e8616b295/</id>
    <published>2024-12-21T20:10:23.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>本来想写24年的年度总结，但是想了半天，写了半天，写不出来一点东西，于是删掉，干脆写点以后的计划。</p><p>今年年中的时候我好像说过“不清楚自己以后是要考研还是找工作”，但是现在摆在我面前的已经不止这两条路了，大致来讲还是能分成两条路，就业和升学，但就业和升学依次还能在分出两条路或者若干条路。</p><p>我现在一直在忧虑自己以后到底要干什么。目前的打算是过几年去日本，留学或工作都可以，然后争取拿永驻。现在日语n2水平，英语托福和托业还没考。</p><p>由此看来，摆在我面前的就只有这么些路了。优先级从上到下依次为</p><ol><li>毕业去日本读研，然后留日工作，拿日本永驻，长期驻日</li><li>在国内工作，攒点钱再去日本读研，然后参考第1点</li><li>毕业直接去日本工作，然后参考第1点</li><li>毕业在国内读研，然后在国内工作，长期留国内</li></ol><p>只要是去日本的选项，优先级都是偏高的。至于我为什么要去日本，一方面是国内失业率越来越高，且国内互联网行业几乎无人能逃出35岁的魔咒，而在日本工作可以靠年功序列制嗯造高龄工资，不用担心35岁失业，真正的越老越吃香；另一方面是我本人确实对日本有一种奇妙的滤镜——毕竟作为互联网行业的人，去美国才是最合适的，毕竟美国的互联网行业也很发达。</p><p>如果是留学的话，国公立大学两年硕士的学费+生活费加起来差不多十来万，如果不去东京的话应该可以再便宜一点。因为真正的大头不在学费，而是生活费。</p><hr><p>以上说了这么多，其实都是我的碎碎念罢了，总之走一步看一步吧。最近的计划是先考下托业，然后找机会练好日语的口语。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来想写24年的年度总结，但是想了半天，写了半天，写不出来一点东西，于是删掉，干脆写点以后的计划。&lt;/p&gt;
&lt;p&gt;今年年中的时候我好像说过“不清楚自己以后是要考研还是找工作”，但是现在摆在我面前的已经不止这两条路了，大致来讲还是能分成两条路，就业和升学，但就业和升学依次还能</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>天气转寒，注意身体</title>
    <link href="https://yonagi04.github.io/posts/2024/1db1ad333570/"/>
    <id>https://yonagi04.github.io/posts/2024/1db1ad333570/</id>
    <published>2024-12-09T17:25:30.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a3cfd1e7c1c667febb79871a6705b998d1ab562fe214319b539600fc8df0f7f5">f58fadda878fbfed22556385e845a685939af906f680f019549cfb53a68c0a7ffbeff95d759846710380c76e62f2880d9055c3fbb702da35716d5648eff13eeb853aebdd2a24864220f8e323d0c32cdc5e62e87a8d522cccaaf01bc16f8219bcf717a8b26ac3c92104c4212e1653d84741f612ac79e2f574e001d5fe4cca6bb7635cea2d08f228ff22350aabd21761148da0d393620c637aed054e5475c0fac99e4f378012f8653a4582b8f7a013060d23474229a168c831186d0351d6790dc63a37cc43117cba5041f12f061b22635ebc7e18768c714efd0ab79bc38db4e5a63884cbc82a23afdbf82488eece9c8658b0ae5011d47b907bdd3f6e70845d08114d9824034ce4ca4b85f0e844072499b46900bf862f0dee5601eb22d2afc91c15472dc29d4092e72d4bc2f93288ab4211b72d876ae18afa0295565cf4b5f2b8ecb2370c428c83e1654a7a65e93b136c77dd057ce92b1dd75529049871f5ebc18bc95ffe189e0c2413e1f0b875bf432441e838b5759ce4d5d153f226e8821311004fe7eef1d19186154adf4373d778bb25ae01238ac09f0cda470009a5c4f1485eaa992f4ed5af76dcd908725c949823c8a872d756e23d564c11ce4ca2611eb8f749e4f6795136b9e44ca2ac65843e7a809d87622a1980009ccee660e54738339c3a424106dfcaea869225211752d0c660b1a2ebae4464edeb9720dff82fdc8c851a15b4f530b29b8893aa548c1b58818e0a134a5fac92eaa19402f8f8dc028d7f2f5090bf4e7b1498dc506fe28e1de76ffdcbe49f20a50c829637bf97348a050229d7f964f8f4dea563143840f471f115f207ff65817a6b901d71c4bc69be0792668275310e0c071f053ae522d9d79e9d36bdccf24ddecc3411c82d3ffbf0efd0b51f575d8358e27ee378e0737a6bd21ee1fd721f2e0659279fadf10e641646d16dc097ee9812cc2d752b6a1e533861fd05d8bd8242edafe066d4061ae095b08b206d9a17814fbcc83ce8774c466e2782d63556055fe0fc3998eaa5ce776b52bf555e87500c9d603efacab469e4403f250933660b6561833aeb226e2fa58d5194c56a831e1eadd31a63fa62a7cbddcbb8d1e065270e9a43606ab1e2744c765aeb4febdc7752d3173aabc7af47ef2fa98066929afcb6f5e54aea5bbc001b5bd0647460cdf34cbefe7ab8ea2038705d36b279a863a7f844a9f687dc75922f28cd8b10f1bba03b720df165b95f44dbd825032b1724620bb37128e077e3b8ad200c983d4a7ee3b46c2403a811f206a25dfd670d02bc406e07363df06519f9b12a1ac00e96497da6330142718f544b4e7c21090b2ff26dd4d77d213f1eac36c7f4c95a64c3515c5125487c7d50210cddc8ae44839ff42393ec91991befaf9c9b63e88baaefd1251db607010cd09800188c1641fcf30c7253d330b13e1a46ee65b6c5fb3b85a0eca10eca21b793ec728c4a679e9eb9a1772e394d6e9167fa4ef9e76767f3e4d66593805be4f9199b6707b852dd810b4f0a940ec147b6ed48fb08d50c4a119d5ba7e4e40ba4ee2a5b7a2882e2cc9a2c385c07075f04f756d3a5baa936170a01758244870ea4dd524d9054364896ca477aad60fb93acac16009af637667856f3727806b948c30610b3de1666c3f864dda13a68dd92c88eea7421032925e61ba6e456616bd92e3764bf2bef54ba7834bb7ceff222a0dae37f625f938f5072e88c655f689886f165928382b0d1383450a572fc3c2791b876513c829ef2accd5c639617b2911328ec11af7e5b87d1d85c9f87f6320bf3597b0d99c7d3901e8ebbb780711fa71c9a202b5fb852b554c961ed42f46626b49fea60a1c75ebe0d9b5336f5ca6d6fb74b3c3eac441b53aece3101d56371a3a176bff432fb05ef36e70e55d97a4b4eab6083d5b537d133e785b0079b72f05666b09c2b5ef411135ca6b34cf00397c9e7668a28be3d22c4aaba61a1033e202c1ba47336598dac7b023c7e7837ab221ed12a9b8084b521ab9484b69b53f10f13c37fdce8bdcbc69fb99b9acf4efe68f2d84df0f9247cce08759e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好, 这里需要密码. 如需密码, 请联系Yonagi.">您好, 这里需要密码. 如需密码, 请联系Yonagi.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇文章被加密了, 请输入密码查看.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>运营商的推销电话太烦人？看我如何制裁他们</title>
    <link href="https://yonagi04.github.io/posts/2024/bb2178df4581/"/>
    <id>https://yonagi04.github.io/posts/2024/bb2178df4581/</id>
    <published>2024-11-25T19:32:59.000Z</published>
    <updated>2025-05-18T09:07:25.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近半年以来天天接到来自中国移动的骚扰电话，大概内容为推销套餐、流量包、宽带等产品，开启手机的骚扰拦截功能之后依然无效，一天仍然能接到好多电话。最后实在忍无可忍，只好打开b站，看看有没有类似的情况，结果发现这种情况真是屡见不鲜了。有些视频提出可以去工信部举报，举报之后颇有成效，我一开始是不相信的，但是也想不出更好的方法，于是照着做了，结果真的有效果。</p><p>这是我最近三个月以来接到的部分骚扰电话，有些骚扰电话没有被手机系统拦截，所以没有包含在内</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.34/img/content/phonecall-blacklist.webp" alt=""></p><p>你可以发现，基本上都是来自于0663790这个号段的。我曾经完全没有怀疑过是运营商的问题，一直以为是高利贷/推销/诈骗分子的骚扰方式升级了，根据目标的手机号归属地自动选择对应归属地的座机号码，结果有一次拨通了，才知道是中国移动在搞鬼。</p><p>那么是时候该出重拳让中国移动吃吃铁拳了。如果你和我一样也有这样的困扰，不妨学着做起来，哪怕不是来自运营商的骚扰电话也可以试一试，说不定也有效果。</p><p>打开 <a href="https://yhssglxt.miit.gov.cn/web/userAppeal/">工信部的投诉网站</a>，选择“我要申诉”。进入申诉页面之后，根据需要，选择“基础电信运营商”或“其他企业”。“是否向企业投诉过”选“是”，“企业反馈结果满意程度”选“不满意”，毕竟我可不想和他们和稀泥，直接让工信部介入会更有效果。接下来就是填写申诉方相关信息以及申诉内容，填写完成后就可以直接提交了。</p><p>我是上周六提交的申诉，今天是周一，刚刚就接到了中国移动的电话。他们表示非常抱歉，并决定把我的号码添加为保护号码，保证以后不会再有类似的营销电话打进来。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.34/img/content/report-result.webp" alt=""></p><p>再看看后续是否会有变化吧，后续如果有新变化我会继续更新，继续举报。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近半年以来天天接到来自中国移动的骚扰电话，大概内容为推销套餐、流量包、宽带等产品，开启手机的骚扰拦截功能之后依然无效，一天仍然能接到好多电话。最后实在忍无可忍，只好打开b站，看看有没有类似的情况，结果发现这种情况真是屡见不鲜了。有些视频提出可以去工信部举报，举报之后颇有成</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>半天的广州小旅行</title>
    <link href="https://yonagi04.github.io/posts/2024/720ccdcc8c6e/"/>
    <id>https://yonagi04.github.io/posts/2024/720ccdcc8c6e/</id>
    <published>2024-11-20T18:21:53.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>其实也不算真正意义上的旅行，只不过是借着笔试的机会出来玩玩。兜兜转转，居然花了半天的时间逛了小半个广州。</p><hr><p>前段时间在投简历，很幸运地收到了一家公司的线下笔试邀约。公司地点位于海珠琶洲，是个好地方，毗邻珠江，不远处就是广州塔、珠江新城、东西双塔。因为是新开发的区域，所以道路条件也远比天河要好。这块区域主要是互联网公司的办公地，所以路上随处可见的是各大互联网公司的打工人。</p><p>笔试约在昨天下午。昨天上午我有一门理论课和实验课，下课已经12点钟了，吃完饭再回到宿舍已经是12点半。笔试的开始时间是下午两点半，考虑了一下以前从大学城去琶洲的耗时，遂决定下午1点15分从大学城出发，到达大学城北地铁站之后再坐地铁去琶洲。</p><p>结果1点15分出发，看了下高德地图，提示需要1小时20分钟后到达目的地。“这下完蛋了，要迟到了。”我这么想着，一面想着一面小跑以赶上即将到达公交站的公交车，幸运的是没有错过这趟车。假如错过了这趟车，再选择等下一辆开往地铁站的公交车，那就一定会迟到了。坐了差不多10分钟，公交车到达了大学城北地铁站。</p><p>大学城北地铁站的站厅面积十分狭小，刷卡进入付费区之后就是两个电梯出入口，分别导向大学城北站的两个站台。下到站台，在站台的长凳上稍微坐了一下，等待了些许，地铁到达了大学城北地铁站。大学城北是广州地铁4号线的一个中间站点，4号线是广州目前唯一一条连接了天河和南沙的地铁线路，所以即使不是在上下班高峰期，地铁车厢内也相当拥挤。</p><p>因为我的目的地是海珠区的琶洲，所以肯定不能4号线一坐坐到底，于是我选择在万胜围换乘8号线，坐到磨碟沙，出站之后走个1公里就能到达目的地了。</p><p>结果出乎我的意料，光走出磨碟沙站就走了差不多十分钟。磨碟沙站是8号线和18号线的换乘车站，所以车站面积也相当大。根据高德地图的指引，我需要从H出口出站，然后走1公里之后就能到达目的地，但是H出口位于18号线区域，我乘坐的线路是8号线，所以下车之后我必须先徒步走到18号线的区域，才能找到H出口，才能离开车站。</p><p>离开车站之后，走了差不多5分钟，就到达了目的地。这么一看，我在车站内的耗时远大于在车站外的耗时。目的地是琶洲的一座写字楼，我还是第一次来琶洲的写字楼，未免心生畏惧。在写字楼前台的指引下，我找到了电梯口，坐上电梯到达笔试地点。</p><p>笔试的过程就不讲了，毕竟这不是本文的主题。</p><p>我是3点30分交卷跑路的。毕竟难得来一次琶洲，不如在琶洲徒步逛一逛。徒步的路线我并没有记录，但是路上经过的几家公司的写字楼我却是记得很清楚：最开始先是小米大厦（很好奇，小米在广州也有Office吗？我印象里小米的Office主要在北京上海南京和武汉），然后是欢聚大厦，接着是阿里巴巴广州中心、在建的广州微信大楼和唯品会大厦。印象最深的是广州微信大楼，第一眼看上去确实很震撼，空中小屋的设计也相当独特，只不过看起来应该还得两三年才能完工，如果能在这里办公就太好了，可惜我的实力不允许我在这里打赛博螺丝。</p><p>在琶洲，待的越久，越觉得自己是个土包子。可能我还是个学生，潜意识里觉得和这个环境有点格格不入，毕竟周围都是打工人。于是转了一圈之后，就打算打道回府，照原路回学校了。走路回地铁站的路上还看到了赫基大楼，是由赫基集团建设的一栋写字楼，字节跳动的广州Office就在那里。</p><p>到达地铁站，依旧是徒步10分钟走到站台，依旧是8号线换乘4号线，一切看起来都很顺利，但是假如真的这么顺利的话，就不符合我这个标题了。</p><p>在昨天的小旅行结束之后，我得到了两个教训：第一个就是以后坐车一定要按照高德地图的提示来，第二个就是——广外公交站不在广外大学城校区，在广外白云校区。</p><p>没错，到达大学城北换乘公交车的时候出了岔子，我坐上了开往广外公交站的车。我以为这辆车是开到大学城的广外，没想到是开到白云区的广外。上车之后我还在暗暗的想“今天真是辛苦了”，结果车厢广播马上打破了我的幻想——“下一站是，仑头立交”。不在广州的读者应该不清楚这是什么地方，只要知道一个成语“南辕北辙”即可。我现在所做的事情简直就是南辕北辙，本来想回大学城的，结果坐上了公交车，又给我拉到天河了。</p><p>当时时间已经是接近下午五点。那既然如此，只能先吃个饭再回大学城了。吃什么好呢？难得出来一次，我决定吃萨莉亚，毕竟经常在QQ群发萨莉亚企鹅的表情包，怎么能不吃萨莉亚呢？在高德地图搜索一番之后，最后还是选择去了曾经经常去的一家萨莉亚，位于天河区的岗顶，不过这可离仑头立交远得多了，差不多要20分钟的车程。因为这趟车并不直接经过岗顶，所以我必须在中间车站换乘其他公交。这样一来一回，又是花了差不多30分钟在路上。</p><p>终于到达了岗顶，我最熟悉的地方。走在岗顶天桥上，我不禁想吟诗一句：</p><blockquote><p>岗顶纯K今犹在，不见当年唱K人。</p></blockquote><p>其实是大一大二两年经常和群里的群友来岗顶的纯K，大唱特唱二次元歌曲，只不过群友基本都大学毕业了，离开了广州，自然也就凑不齐唱K的人了。当然这是另外一码事，和本文的主题没啥关联。</p><p>轻车熟路到达萨莉亚。我本来以为孤身一人来吃萨莉亚是一件很凄惨的事情，毕竟萨莉亚在日本是家庭餐厅，多用于聚餐，结果到了萨莉亚一看，发现有不少和我一样的孤身一人来品尝萨莉亚的美食。点了一碗奶油蘑菇汤，一份芝士焗饭，一份饮料畅饮，花了40元大洋，性价比相当高了。我不是美食家，没有鉴赏美食的能力，但是萨莉亚的出品还是值得保证的，基本上水平上乘，且价格不算贵，属于性价比很高的选择。可惜并不是所有城市都有萨莉亚，一般来讲只有大城市才会有。</p><p>酒足饭饱之后，也该回学校了。遂离开萨莉亚，到达公交站，坐上B25路公交车，一路直达学校。B25算是通勤线路，所以车厢内的人也相当多，整辆车犹如沙丁鱼罐头。路上塞着耳机听歌，路上经过了琶洲大桥，正好能看到广州塔，此时耳机里放着藤井风的《帰ろう》，正好放到副歌段</p><blockquote><p>ああ 全て忘れて帰ろう</p><p>ああ 全て流して帰ろう</p><p>あの傷は疼けどこの渇き癒えねど</p><p>もうどうでもいいの 吹き飛ばそう</p><p>さわやかな風と帰ろう</p><p>やさしく降る雨と帰ろう</p><p>憎み合いの果てに何が生まれるの</p><p>わたし、わたしが先に 忘れよう</p></blockquote><p><meting-js server="netease" type="song" id="1449537108"></meting-js></p><p>突然感觉，偶尔释放一下自己紧绷的神经，出来逛一逛，也挺好的。</p><hr><p>与其说是小旅行，还不如说是乌龙——坐错车，走错路，最后转了一圈才回学校，不过也算是难得找到一次机会出来玩一玩，出来玩的时候还不用考虑学业和找工作的事情，挺不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实也不算真正意义上的旅行，只不过是借着笔试的机会出来玩玩。兜兜转转，居然花了半天的时间逛了小半个广州。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前段时间在投简历，很幸运地收到了一家公司的线下笔试邀约。公司地点位于海珠琶洲，是个好地方，毗邻珠江，不远处就是广州塔、珠江新城、东西双塔。因为是</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>面对频发的恐怖袭击案件，我们该怎么办</title>
    <link href="https://yonagi04.github.io/posts/2024/e14cfcc7196f/"/>
    <id>https://yonagi04.github.io/posts/2024/e14cfcc7196f/</id>
    <published>2024-11-17T12:40:46.000Z</published>
    <updated>2025-05-18T09:07:25.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅为表面闲谈，不涉及更深层次原因。</p></blockquote><p>今年一年可谓是多事之秋，而今年的下半年更是如此。从9月份的深圳大学杀人案，到10月份的深圳日本人学校的学生被捅，再到同样是10月份的上海某商场门口的随机杀人案，再到前几天珠海的体育场开车碾压无辜群众，再到昨天（11月16日）无锡工艺职业技术学院发生的随机杀人事件，再到今天（11月17日）的广东工业大学的宿舍杀人案，这一切让我们不禁为社会的安全产生了担忧。现在这个社会真的如同宣传所说的这么“安全”吗？今天笔者不想讨论更深层次的原因，只想简单聊聊——面对频发的恐怖袭击案件，我们该怎么办。</p><p>这里简单贴一个来自“深圳反恐”公众号的推文。</p><p><a href="https://mp.weixin.qq.com/s/H_YCtOwDeJcQ0FqxTlcFEA">五大场景逃生教学（二）：车辆冲撞恐怖袭击</a></p><p>很明显，这则推文应该是在珠海体育场事件之后发布的。对于懒得点开的读者，这里直接给出省流：</p><blockquote><p>碰到极端驾车冲撞时，牢记三个技巧：</p><ol><li>躲。往树木、石桌石凳、建筑物、摊位、大型车辆、大件物品后面躲，注意留出缓冲空间。切记不要往路灯、玻璃橱窗躲避，避免物品被撞倒或破碎导致二次伤害</li><li>避。千万不要背对汽车逃窜，应该面向或侧向来袭汽车，连续向左向右移动，做“之”字形或“O”字形运动</li><li>掷。把衣服、面粉、鸡蛋等能够干扰视线的物品往汽车挡风玻璃上丢</li></ol></blockquote><p>希望能给读者带来点帮助。在网上冲浪的时候也找到了一段文字，希望能给大家带来点帮助（敏感字已被屏蔽）</p><blockquote><p>最近开服频率越来越高且临近春节，考虑到x友的安全，我决定盘点一下防x大法给肉身还在服里的x友们防身：<br>1.尽量避免在特殊时间、在人流量大的地方逗留太久，例如：知名网红打卡点、节假日的火车站飞机场、大型商超、广场<br>2.非必要不出门，如果一定要出门的话，建议谨慎选择通勤路线，地铁（已经帮你安检好）&gt;开车&gt;打车（打特价车容易被司机车内单杀）&gt;公交（司机有可能x）&gt;骑行、步行（被x无处可躲），不要在路口、街边站立太久，选择有石墩的行人岛，不要一直低头、时常观察下附近的不稳定因素（大喊大叫、争执声、引擎声、刹车声、碰撞声、人流涌动）<br>3.同任何底层服务行业的人交往一定保持客气的态度：外卖员、滴滴司机、路边小摊贩、服务员、环卫工人，他们很可能是刚破产的老板，随时准备着屠x，就等你引爆。<br>4.不要凑热闹、越热闹的地方越不要去最好，如果你一个人除非你和别人有仇一般不会x你，人多了就不一定。<br>5.最坏情况：如果匹配到刀战，头也不回的跑，边跑边观察，如果是团伙开x，千万不要跑到别人同伙的包围圈里，边跑边看看有没有可以影响他视听的物品例如灭火器、牛奶、甚至可以把消防喷淋头打开，切忌和他搏斗哪怕你有武器，也不要妄想躲在某个地方等待，跑出刀战地图才是最安全的。<br>如果匹配到赛车局：和刀战服恰恰相反，不要尝试使劲跑动，你不可能跑得过汽车，反而跑动起来会被观察到，最应该做的是：能进到室内就最好、越往里走越好，如果没有建筑物就寻找大树、石墩、高处、台阶（路灯是没有用的），如果你不幸在空旷地区尽可能躲开车头行驶的方向、如果你躲开了他的加速他就不太可能专门倒车来撞你，因为这样他会损失速度。</p></blockquote><p>希望这些东西大家永远都用不上。如果大家用不到这些东西，那就太好了。那么再回到我们最开始的话题，面对频发的恐怖袭击案件，我们该怎么办？硬要说的话，除了学习一些应对恐怖袭击的方法之外，其实我们并没有什么更好的方法来完全规避恐袭（当然，我相信能提出更好方法的人应该也不会来看我的blog）。对于学校的恐袭而言，学生（不包括校外人士在校内或在学校门口的袭击）恐袭的原因多半是人际关系问题（例如宿舍纠纷、情侣纠纷……）、学业问题（例如学校卡毕业、学校卡保研……）；而对于社会的恐袭而言……原因就很复杂了，如果要深究一下原因，那就已经违背了本文的宗旨，而且很可能这篇文章发布后我就会被请去喝茶。所以深层次的原因不在此讨论，但是相信大家懂得都懂。</p><p>希望大家都能平平安安地过完2024年吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文仅为表面闲谈，不涉及更深层次原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年一年可谓是多事之秋，而今年的下半年更是如此。从9月份的深圳大学杀人案，到10月份的深圳日本人学校的学生被捅，再到同样是10月份的上海某商场门口的随机杀人案，再到前</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客对繁体自动化镜像搬运的反制</title>
    <link href="https://yonagi04.github.io/posts/2024/a1a274fe806b/"/>
    <id>https://yonagi04.github.io/posts/2024/a1a274fe806b/</id>
    <published>2024-11-14T17:15:13.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>在网上冲浪，偶然看到这么一篇文章</p><p><a href="https://blog.meta-code.top/2024/10/27/2024-15/">我也中招了！大量简中博客站点被镜像，并翻译成了繁体中文</a></p><p>文章的内容就是一位站长发现自己的网站在未经许可的情况下被海外的繁体镜像搬运。我个人对这种行为是极其深恶痛绝且不齿的，搬运他人的文章构建“内容农场”，不仅侵害了他人的著作权，还会影响原站的SEO权重，时间长了搞不好搜索引擎也会把假的镜像站当成真的网站，而把真的网站当成假的网站。</p><p>文章给了一些反制措施，事不宜迟，跟着做起来。虽然我的网站还没有出现这种情况，但是防范于未然。</p><h2 id="1-在网站中添加防盗链代码">1. 在网站中添加防盗链代码</h2><p>镜像站的特点就是无脑搬运原站的内容，既然如此，那就在网站中添加这么一段Javascript代码，如果当前网站的域名不是笔者的域名，就直接跳转到笔者的网站</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;scirpt&gt;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> encodedValidDomain1 = <span class="string">&#x27;eW9uYWdpMDQuZ2l0aHViLmlv&#x27;</span>; <span class="comment">// 使用Base64编码替代明文字符串`yonagi04.github.io`</span></span><br><span class="line">    <span class="keyword">var</span> encodedValidDomain2 = <span class="string">&#x27;YmxvZy55b25hZ2kwNC5jbg==&#x27;</span>; <span class="comment">// 使用Base64编码替代明文字符串`blog.yonagi04.cn`</span></span><br><span class="line">    <span class="keyword">var</span> encodedValidDomain3 = <span class="string">&#x27;bG9jYWxob3N0&#x27;</span>; <span class="comment">// 使用Base64编码替代明文字符串`localhost`</span></span><br><span class="line">    <span class="keyword">var</span> encodedRedirectUrl = <span class="string">&#x27;aHR0cHM6Ly9ibG9nLnlvbmFnaTA0LmNu&#x27;</span>; <span class="comment">// 使用Base64编码替代明文字符串`https://blog.yonagi04.cn`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对Base64编码后的域名和URL进行解码</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">decodeBase64</span>(<span class="params">encodedStr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">atob</span>(encodedStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> validDomain1 = <span class="title function_">decodeBase64</span>(encodedValidDomain1);</span><br><span class="line">    <span class="keyword">var</span> validDomain2 = <span class="title function_">decodeBase64</span>(encodedValidDomain2);</span><br><span class="line">    <span class="keyword">var</span> validDomain3 = <span class="title function_">decodeBase64</span>(encodedValidDomain3)</span><br><span class="line">    <span class="keyword">var</span> redirectUrl = <span class="title function_">decodeBase64</span>(encodedRedirectUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果访问不是来自指定的域名，则自动跳转页面</span></span><br><span class="line">    <span class="keyword">var</span> hostname = <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">hostname</span>;</span><br><span class="line">    <span class="keyword">if</span> (hostname !== validDomain1 &amp;&amp; hostname !== validDomain2 &amp;&amp; hostname !== validDomain3) &#123;</span><br><span class="line">      <span class="title function_">confirm</span>(<span class="string">&quot;警告：您当前浏览的页面非官方页面，可能存在有害信息！建议您跳转至官方页面进行浏览！&quot;</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = redirectUrl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为了保证这段代码在任何一个页面都可以执行，所以可以选择把这段代码放到页面的pug文件下。笔者使用的是Hexo Butterfly主题，所以笔者把这个代码放到了 <code>\themes\butterfly\layout\includes\head\analytics.pug</code> 的最后一行。对于其他框架或其他主题，可以参考类似的做法。</p><h2 id="2、向域名的注册商报告滥用">2、向域名的注册商报告滥用</h2><p>根据ICANN的政策，域名的注册商有义务配合被侵权者终止侵权行为。如果域名注册商是中国企业，我们还可以根据民法典、著作权法等法律法规向对方提出配合的要求。如果域名注册商是美国企业，我们还可以根据DMCA（Digital Millennium Copyright Act，数字千年版权法案）向对方提出配合要求。</p><p>根据域名的WHOIS信息找到域名注册商的官方网站，然后将侵权事项通过EMail、在线客服等方式告知对方，要求对方停止为侵权域名提供DNS服务器地址更新服务。如果打算起诉侵权者的话，还可以要求对方配合提供侵权者的姓名、身份证号、联系电话、住址等信息。</p><h2 id="3、向搜索引擎报告滥用">3、向搜索引擎报告滥用</h2><p>参照第2条，向搜索引擎报告滥用，寻求对方的配合，将侵权者的网站从收录条目中剔除。</p><h2 id="4、向域名的DNS解析服务商报告滥用">4、向域名的DNS解析服务商报告滥用</h2><p>参照第2条，向域名的DNS解析服务商报告滥用，寻求对方的配合，终止向侵权者提供DNS解析服务。</p><h2 id="5、向网站的托管商报告滥用">5、向网站的托管商报告滥用</h2><p>参照第2条，向网站的托管商报告滥用，寻求对方的配合，终止向侵权者提供服务。</p><h2 id="6、向域名的注册局报告滥用">6、向域名的注册局报告滥用</h2><p>每个域名的注册局都有防滥用(Anti Abuse)的政策，打开对应域名的注册局官网，然后找到报告域名滥用的页面，通过提交请求的方式将侵权事项告知对方。寻求对方的配合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在网上冲浪，偶然看到这么一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.meta-code.top/2024/10/27/2024-15/&quot;&gt;我也中招了！大量简中博客站点被镜像，并翻译成了繁体中文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章的内容就是一位站长发现自己的网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简谈布谷鸟过滤器：它是比布隆过滤器更好的选择吗？</title>
    <link href="https://yonagi04.github.io/posts/2024/c92be60d126b/"/>
    <id>https://yonagi04.github.io/posts/2024/c92be60d126b/</id>
    <published>2024-11-01T08:56:01.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>其实我一直想研究一下布谷鸟过滤器，但苦于找不到一个合适的契机。真正促使我查找布谷鸟过滤器相关的资料并决定写这篇博客的原因，还要追溯到半个月之前欢聚时代的一场面试。</p><p>面试官：“你的xxxxx功能用到了布隆过滤器，但假如是xxxx从数据库中删掉了，布隆过滤器里面的数据怎么处理？”</p><p>我：“如果是这样的话，因为布隆过滤器是无法删除数据的，所以只能在删数据之前做一个特判，然后拿一个Set之类的数据类型存起来……其实还有一个更好的解决方案，就是布谷鸟过滤器，它可以实现元素的删除，解决了布隆过滤器无法删除元素的问题……”说到这里就断了，究其本质还是对布谷鸟过滤器不太熟悉。所以想借着这个契机，和大家简单聊聊布谷鸟过滤器，以及——布谷鸟过滤器真的是比布隆过滤器更好的选择吗？</p><hr><h2 id="在布谷鸟之前：布隆过滤器的缺点与展望">在布谷鸟之前：布隆过滤器的缺点与展望</h2><p>在开讲布谷鸟过滤器之前，我想先简单回顾一下布隆过滤器。</p><p>布隆过滤器（Bloom Filter）是一种特殊的数据结构，其本质是一个位数组和若干个哈希函数的组合。在元素存入布隆过滤器时，首先要对元素进行哈希运算，得到哈希值<code>hash 1、hash 2、...、hash n</code> ，然后将坐标为<code>hash 1、hash 2、...、hash n</code>的位标记成 <code>1</code> 以实现元素的存储。当需要判断元素是否存在于布隆过滤器中时，也是基于同样的操作，只需要先计算出哈希值，再判断哈希值对应的位是否被标记成 <code>1</code>，就能判断元素是否存在于布隆过滤器中。布隆过滤器有一个很明显的好处，就是我们只需要进行 <code>n</code> 次运算就能判断出元素是否存在于布隆过滤器中，其时间复杂度相较于其他数据类型而言有明显的改善，但是布隆过滤器有两个明显的缺点，第一个缺点就是布隆过滤器的误判，由于可能存在哈希碰撞的问题，不同的元素通过哈希函数计算之后得到了相同的哈希值，进而可能会出现 “元素本来不存在于布隆过滤器，但布隆过滤器却判断其存在” 的情况，也就是我们常说的 “误判”；第二个缺点就是布隆过滤器无法删除元素，因为布隆过滤器本质上存储的是元素经过哈希运算之后得到的哈希值对应的bit值而不是元素本身，所以对于布隆过滤器而言，删除元素本来就是一件很不现实的事情——毕竟如果草率地将哈希值对应的bit值标记为 <code>0</code> 来表示元素被删除，就会出现其他元素被布隆过滤器“误判”为“不存在”的情况，因为其他元素计算出来的哈希值和被删除元素计算出来的哈希值很有可能是相同的，如果直接将bit值标记为 <code>0</code>，那么布隆过滤器需要判断其他元素是否存在的时候就会因为这个bit值被标记成了<code>0</code>而将其他元素误判为“不存在”。</p><p>基于这些问题，我们提出了一个展望：我们希望能够设计出一个新的数据结构，这个数据结构继承了布隆过滤器的“优良传统”，也就是能够实现快速判断元素是否存在，也摈弃了布隆过滤器的“缺陷”，也就是误判和无法删除元素的问题。介于此，布谷鸟过滤器由此诞生。</p><h2 id="布谷鸟过滤器：鸠占鹊巢">布谷鸟过滤器：鸠占鹊巢</h2><p>2014年，来自CMU、Harvard 和 Intel 的团队基于布谷鸟哈希算法设计出了一个新的数据结构，他们将其命名为“Cuckoo Filter”，中文译名即为“布谷鸟过滤器”。在团队发表的文章 <a href="https://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf">“Cuckoo Filter: Practically Better Than Bloom”</a> 的引言部分，简单提到了布谷鸟过滤器和布隆过滤器的对比，颇有一种“碰瓷”的意味。</p><blockquote><p>We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.</p></blockquote><p>文章提到，布谷鸟过滤器相较于布隆过滤器，有以下几点明显的优势：</p><ol><li>支持动态地添加和删除元素 (It supports adding and removing items dynamically)</li><li>比传统的布隆过滤器有更好的查询性能，即使布谷鸟过滤器即将被填满 (It provides higher lookup performance than traditional Bloom filters, even when close to full)</li><li>比其他替代方案（如 Quotient Filter）更容易实现 (It is easier to implement than alternatives such as the quotient filter)</li><li>如果误判率小于 3% ，那么它的空间占用比布隆过滤器更小 (It uses less space than Bloom filters in many practical applications, if the target false positive rate is less than 3%)</li></ol><p>布谷鸟过滤器是基于布谷鸟哈希算法实现的，所以先介绍布谷鸟哈希算法。</p><hr><p>布谷鸟哈希算法的特性可以用一个成语来概括，那就是“鸠占鹊巢”，也就是本小节的标题。布谷鸟哈希算法是使用两个哈希函数对同一个元素进行哈希运算，得到两个哈希值，进而得到在桶中存储的位置，此时</p><ul><li>若两个位置都为空，则随机选择一个位置将元素放入；</li><li>若只有一个位置为空，则将元素放入这个空位置；</li><li>若两个位置都不为空，则将两个位置上的元素随机“踢”走一个，新元素占据其位置，被“踢”走的元素通过哈希运算重新寻找新的位置。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.32/img/content/Cuckoo%20hash.webp" alt=""></p><p>当存入布谷鸟过滤器的元素足够多时，这种“踢出”已有元素的情况就会越来越频繁，所以一般会设置一个 <strong>踢出阈值</strong>，当超出这个阈值，布谷鸟过滤器就会进行扩容，减少频繁地“踢出元素”对插入性能的影响。</p><hr><p>而布谷鸟过滤器本身的插入过程，具体可以如下图所示。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.32/img/content/Cuckoo%20Filter.webp" alt=""></p><p>图中的 (a) 和 (b) 展示了布谷鸟过滤器的插入过程，和布谷鸟哈希算法的插入流程基本同理，因此不再赘述。基本的布谷鸟过滤器由两个或多个哈希函数构成，布谷鸟过滤器的哈希表的基本单位又称为“条目” (entry) ，每个条目存储元素的 “指纹” (fingerprint)，指纹指的是哈希函数生成的 n 位比特位，一般根据能接受的最大误判率来设置。具体的布谷鸟过滤器的哈希表如图 © 所示。</p><h3 id="布谷鸟过滤器的插入">布谷鸟过滤器的插入</h3><p>与传统的布谷鸟哈希不同，布谷鸟过滤器采用了两个并不独立的哈希函数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i_1 = hash(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⊕</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i_2 = i_1 \oplus hash(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是指待插入的元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 是指元素的指纹，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i_1, i_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 即为计算出来的两个哈希值。具体来讲，第一个桶的索引是通过某个哈希函数计算出来，第二个是使用第一个索引和 <strong>指纹的哈希</strong> 做了一个异或操作，由于异或运算的特性，所以我们可以通过当前桶的索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和存储在桶中的指纹 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 计算出备用桶的索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">i_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。 计算指纹 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的哈希这一步是不是冗余的呢？并不是。因为指纹只是 <code>key</code> 映射出来的少量bit位置，假如不进行哈希操作，那么计算出来的备用位置和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 差别很小，例如采用8位的指纹时，如果直接计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⊕</mo><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f \oplus i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，那么最多改变 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的低八位，也就是在数值上最多相差256，不利于均匀分配。</p><h3 id="布谷鸟过滤器的查找">布谷鸟过滤器的查找</h3><p>布谷鸟过滤器的查找也很简单。根据上述提及的插入方法，只需要用同样的方式计算出两个桶的位置和指纹 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> ，再判断对应的桶内是否能够和指纹 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 匹配，如果可以匹配，则认为元素存在，返回 <code>true</code>，反之则不存在，返回 <code>false</code>。</p><h3 id="布谷鸟过滤器的删除">布谷鸟过滤器的删除</h3><p>布隆过滤器不能实现删除元素的功能，如果要选择删除元素就必须重建布隆过滤器。布谷鸟过滤器则实现了删除功能，只需要从哈希表中删除对应的指纹和对应的项，即可实现删除。具体来讲，只需要在给定的两个候选桶中检查是否有匹配的指纹，如果有则直接删除匹配指纹的一个副本</p><h2 id="没有银弹">没有银弹</h2><p>布谷鸟过滤器真的完美吗？它真的能成为布隆过滤器的“替代品”吗？</p><blockquote><p>软件工程领域有一个相当知名的说法，“There is no single development, in either technology or management technique, which by itself promises even one order of magnitude improvement within a decade in productivity, in reliability, in simplicity.”，用一句话总结就是，“No silver bullet”，没有银弹。</p></blockquote><p>正如这个子标题，我想表达的是，布谷鸟过滤器也有自己的缺陷，而且它并不是布隆过滤器的替代品。</p><ol><li><strong>布谷鸟过滤器的删除功能并不完美，存在误删的可能性</strong>。由于删除的时候只是删除了一份指纹副本，不能判断这个副本属于被删除的 <code>key</code> 的指纹。</li><li><strong>插入时间复杂度比较高</strong>。随着已插入元素的增多，“踢出”元素的情况会越来越频繁，对于被“踢出”的元素而言，需要重新计算其索引，提高了插入时间复杂度，但总体来看，插入的时间复杂度还是维持在较低的水平。</li><li><strong>存储空间必须为2的倍数</strong>，空间利用率较低。</li><li><strong>对于同一个元素，布谷鸟过滤器最多可以插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k * b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 次</strong>，这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是指哈希函数的个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 是指桶的尺寸。如果布谷鸟过滤器支持删除，则必须存储同一项的多个副本。 插入同一项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k * b + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 次将导致插入失败。 这类似于计数布隆过滤器，其中重复插入会导致计数器溢出。</li></ol><p>介于此，我个人认为，布谷鸟过滤器是布隆过滤器的一个 “上位”替代，它实现了删除功能，也解决了布隆过滤器存在的误判问题，但是布谷鸟过滤器本身存在一些缺陷，所以它并不是完美的，也没法成为布隆过滤器的“替代品”。实际情况是，布隆过滤器的使用场景依然广泛，布隆过滤器也没有完全被布谷鸟过滤器所替代。</p><h2 id="与其他过滤器的比较">与其他过滤器的比较</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.32/img/content/compare-with-other-filter.webp" alt=""></p><p>上图是布隆过滤器、布谷鸟过滤器和其他过滤器在误判率和元素空间成本上的比较。由图可知，布谷鸟过滤器在空间成本上比布隆过滤器更加出色，存储空间会更小。</p><h2 id="布谷鸟过滤器的实现">布谷鸟过滤器的实现</h2><p>因为笔者擅长使用Java，所以这里给出了布谷鸟过滤器Java版的实现，仅供读者参考。C++版本的实现在布谷鸟过滤器的 <a href="https://github.com/efficient/cuckoofilter">Github仓库</a> 已有提供，其他版本的布谷鸟过滤器可以在 Github 上自行查找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuckooFilter</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//最大的踢出次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM_KICKS</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="comment">//桶的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">//存入元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//存放桶的数组</span></span><br><span class="line">    <span class="keyword">private</span> Bucket[] buckets;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">cuckooFilter</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        capacity = tableSizeFor(capacity);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">Bucket</span>[capacity];</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">Bucket</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 向布谷鸟过滤器中插入一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 插入成功，返回true</span></span><br><span class="line"><span class="comment">     * 过滤器已满或插入数据为空，返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span> <span class="variable">f</span> <span class="operator">=</span> fingerprint(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> hash(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 ^ hash(f);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (buckets[i1].insert(f) || buckets[i2].insert(f)) &#123;</span><br><span class="line">            <span class="comment">//有空位置</span></span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有空位置，relocate再插入</span></span><br><span class="line">        <span class="keyword">return</span> relocateAndInsert(i1, i2, f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对插入的值进行校验，只有当未插入过该值时才会插入成功</span></span><br><span class="line"><span class="comment">     * 若过滤器中已经存在该值，会插入失败返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertUnique</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || contains(o))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> insert(o);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机在两个位置挑选一个将其中的一个值标记为旧值，</span></span><br><span class="line"><span class="comment">     * 用新值覆盖旧值，旧值会在重复上面的步骤进行插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">relocateAndInsert</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">byte</span> f)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> random.nextBoolean();</span><br><span class="line">        <span class="type">int</span> <span class="variable">itemp</span> <span class="operator">=</span> flag ? i1 : i2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_NUM_KICKS; i++) &#123;</span><br><span class="line">            <span class="comment">//在桶中随机找一个位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> random.nextInt(Bucket.BUCKET_SIZE);</span><br><span class="line">            <span class="comment">//踢出</span></span><br><span class="line">            f = buckets[itemp].swap(position, f);</span><br><span class="line">            itemp = itemp ^ hash(f);</span><br><span class="line">            <span class="keyword">if</span> (buckets[itemp].insert(f)) &#123;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//超过最大踢出次数，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此过滤器包含对象的指纹，返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">f</span> <span class="operator">=</span> fingerprint(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> hash(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 ^ hash(f);</span><br><span class="line">        <span class="keyword">return</span> buckets[i1].contains(f) || buckets[i2].contains(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从布谷鸟过滤器中删除元素</span></span><br><span class="line"><span class="comment">     * 为了安全地删除，此元素之前必须被插入过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">f</span> <span class="operator">=</span> fingerprint(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> hash(o);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 ^ hash(f);</span><br><span class="line">        <span class="keyword">return</span> buckets[i1].delete(f) || buckets[i2].delete(f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器中元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//过滤器是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//得到指纹</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> <span class="title function_">fingerprint</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> o.hashCode();</span><br><span class="line">        h += ~(h &lt;&lt; <span class="number">15</span>);</span><br><span class="line">        h ^= (h &gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        h += ~(h &lt;&lt; <span class="number">11</span>);</span><br><span class="line">        h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="type">byte</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">byte</span>) h;</span><br><span class="line">        <span class="keyword">if</span> (hash == Bucket.NULL_FINGERPRINT)</span><br><span class="line">            hash = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        h -= (h &lt;&lt; <span class="number">6</span>);</span><br><span class="line">        h ^= (h &gt;&gt; <span class="number">17</span>);</span><br><span class="line">        h -= (h &lt;&lt; <span class="number">9</span>);</span><br><span class="line">        h ^= (h &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        h -= (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &lt;&lt; <span class="number">10</span>);</span><br><span class="line">        h ^= (h &gt;&gt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> h &amp; (capacity - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//hashMap的源码 有一个tableSizeFor的方法，目的是将传进来的参数转变为2的n次方的数值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FINGERPINT_SIZE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//桶大小为4</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUCKET_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">NULL_FINGERPRINT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] fps = <span class="keyword">new</span> <span class="title class_">byte</span>[BUCKET_SIZE];</span><br><span class="line">        <span class="comment">//在桶中插入</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">byte</span> fingerprint)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fps.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fps[i] == NULL_FINGERPRINT) &#123;</span><br><span class="line">                    fps[i] = fingerprint;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在桶中删除</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">byte</span> fingerprint)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fps.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fps[i] == fingerprint) &#123;</span><br><span class="line">                    fps[i] = NULL_FINGERPRINT;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//桶中是否含此指纹</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">byte</span> fingerprint)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fps.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fps[i] == fingerprint)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> position, <span class="type">byte</span> fingerprint)</span> &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">tmpfg</span> <span class="operator">=</span> fps[position];</span><br><span class="line">            fps[position] = fingerprint;</span><br><span class="line">            <span class="keyword">return</span> tmpfg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>在这篇博客中，我们简单地回顾了一下布隆过滤器，在了解了布隆过滤器的优点和缺点的基础上，我们又进一步引入了布谷鸟过滤器，布谷鸟过滤器较布隆过滤器有四点明显优势：</p><ol><li>实现了元素的动态删除</li><li>查询性能更好</li><li>不存在误判的情况</li><li>空间占用的表现更加出色</li></ol><p>但是布谷鸟过滤器也有明显的缺点，例如布谷鸟过滤器的空间利用率较低，布谷鸟过滤器的删除功能可能会导致误删等。实际开发场景下，布谷鸟过滤器也没有完全替代布隆过滤器，具体的选择要根据具体的业务场景来判断，选择合适的数据结构来满足开发需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实我一直想研究一下布谷鸟过滤器，但苦于找不到一个合适的契机。真正促使我查找布谷鸟过滤器相关的资料并决定写这篇博客的原因，还要追溯到半个月之前欢聚时代的一场面试。&lt;/p&gt;
&lt;p&gt;面试官：“你的xxxxx功能用到了布隆过滤器，但假如是xxxx从数据库中删掉了，布隆过滤器里面的</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="缓存" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="布隆过滤器" scheme="https://yonagi04.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    <category term="布谷鸟过滤器" scheme="https://yonagi04.github.io/tags/%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>非常好合奏</title>
    <link href="https://yonagi04.github.io/posts/2024/054a6c35de23/"/>
    <id>https://yonagi04.github.io/posts/2024/054a6c35de23/</id>
    <published>2024-10-28T09:44:26.000Z</published>
    <updated>2025-05-18T09:07:25.415Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚躺在床上刷Tiktok，刷到了Ado和初音未来在最近的一次Live上的合唱……非常好合唱，使我泪流满面，平板不由自主旋转</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">     <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113362440557847&bvid=BV1K2ykYmE8w&cid=26461276769&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚躺在床上刷Tiktok，刷到了Ado和初音未来在最近的一次Live上的合唱……非常好合唱，使我泪流满面，平板不由自主旋转&lt;/p&gt;
&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="VOCALOID" scheme="https://yonagi04.github.io/tags/VOCALOID/"/>
    
    <category term="JPOP" scheme="https://yonagi04.github.io/tags/JPOP/"/>
    
  </entry>
  
  <entry>
    <title>Yonagi&#39;s Sekai祝大家1024程序员节快乐</title>
    <link href="https://yonagi04.github.io/posts/2024/46e0ea94ef6a/"/>
    <id>https://yonagi04.github.io/posts/2024/46e0ea94ef6a/</id>
    <published>2024-10-24T12:54:09.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序，选择排序，插入排序，快速排序，堆排序，归并排序，希尔排序，桶排序，基数排序帮您排忧解难。</p><p>有向图，无向图，有环图，无环图，完全图，稠密图，稀疏图，拓扑图祝您宏图大展。</p><p>最长路，最短路，单源路径，所有节点对路径祝您路路通畅。</p><p>二叉树，红黑树，van Emde Boas树，最小生成树祝您好运枝繁叶茂。</p><p>最大流，网络流，标准输入流，标准输出流，文件输入流，文件输出流祝您顺顺流流。</p><p>线性动规，区间动规，坐标动规，背包动规，树型动归为您的规划精彩。</p><p>散列表，哈希表，邻接表，双向链表，循环链表帮您在表达喜悦。</p><p>O(n!),O(2^n), O(n3),O(n2), O(nlog n) , O(n), O(log n) , O(1)</p><p>祝大家渐进步步高 !</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;冒泡排序，选择排序，插入排序，快速排序，堆排序，归并排序，希尔排序，桶排序，基数排序帮您排忧解难。&lt;/p&gt;
&lt;p&gt;有向图，无向图，有环图，无环图，完全图，稠密图，稀疏图，拓扑图祝您宏图大展。&lt;/p&gt;
&lt;p&gt;最长路，最短路，单源路径，所有节点对路径祝您路路通畅。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简谈设计模式之迭代器模式、访问者模式、备忘录模式、解释器模式</title>
    <link href="https://yonagi04.github.io/posts/2024/83ee462de905/"/>
    <id>https://yonagi04.github.io/posts/2024/83ee462de905/</id>
    <published>2024-10-13T15:37:35.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器模式">迭代器模式</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示，类似于C++和Java的迭代器</p><h3 id="迭代器模式结构">迭代器模式结构</h3><ul><li><strong>迭代器接口</strong>：规定了遍历元素的方法</li><li><strong>具体迭代器</strong>：实现迭代器接口，包含遍历逻辑</li><li><strong>聚合类</strong>：定义一个接口用于返回一个迭代器对象</li></ul><h3 id="迭代器结构实现">迭代器结构实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameRepository</span> <span class="keyword">implements</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] names = &#123;<span class="string">&quot;Robert&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Julie&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NameIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; name.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> names[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NameRepository</span> <span class="variable">namesRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameRepository</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> namesRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)iter.next();</span><br><span class="line">         System.out.println(<span class="string">&quot;Name : &quot;</span> + name);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>支持多种遍历方式</li><li>简化了聚合类</li><li>多遍历支持</li><li>拓展性更好</li></ul><p><strong>缺点</strong>：</p><ul><li>系统复杂性增加</li></ul><h2 id="访问者模式">访问者模式</h2><p>在访问者模式中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。</p><h3 id="访问者模式结构">访问者模式结构</h3><ul><li><strong>访问者接口</strong>：包含访问不同元素的方法</li><li><strong>具体访问者</strong>：实现访问者接口，实现具体的访问不同元素的逻辑</li><li><strong>元素接口</strong>：包含一个接受访问者的方法</li><li><strong>具体元素</strong>：实现了元素接口，提供给访问者访问的入口</li></ul><h3 id="访问者模式实现">访问者模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keyboard</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">   </span><br><span class="line">   ComputerPart[] parts;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span>&#123;</span><br><span class="line">      parts = <span class="keyword">new</span> <span class="title class_">ComputerPart</span>[] &#123;<span class="keyword">new</span> <span class="title class_">Mouse</span>(), <span class="keyword">new</span> <span class="title class_">Keyboard</span>(), <span class="keyword">new</span> <span class="title class_">Monitor</span>()&#125;;      </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parts.length; i++) &#123;</span><br><span class="line">         parts[i].accept(computerPartVisitor);</span><br><span class="line">      &#125;</span><br><span class="line">      computerPartVisitor.visit(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Computer computer)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Mouse mouse)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Keyboard keyboard)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monitor monitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实体访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Computer computer)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Computer.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Mouse mouse)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Mouse.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Keyboard keyboard)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Keyboard.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monitor monitor)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Displaying Monitor.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerPart</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.accept(<span class="keyword">new</span> <span class="title class_">ComputerPartDisplayVisitor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>符合单一职责原则</li><li>拓展性好</li><li>灵活性好</li></ul><p><strong>缺点</strong>：</p><ul><li>违反迪米特原则</li><li>元素类难以变更</li><li>依赖于具体类</li></ul><h2 id="备忘录模式">备忘录模式</h2><p>备忘录模式保存一个对象的某个状态，以便在适当的时候恢复对象，备忘录模式属于行为型模式。备忘录模式允许在不破坏封装性的前提下，捕获和恢复对象的内部状态。</p><h3 id="备忘录模式结构">备忘录模式结构</h3><ul><li><strong>备忘录</strong>：负责存储原发器对象的内部状态</li><li><strong>原发器</strong>：创建一个备忘录对象，并且可以使用备忘录对象恢复自身的内部状态</li><li><strong>负责人</strong>：负责保存备忘录对象，但是不对备忘录对象进行操作或检查</li></ul><h3 id="备忘录模式实现">备忘录模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> Memento <span class="title function_">saveStateToMemento</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStateFromMemento</span><span class="params">(Memento Memento)</span>&#123;</span><br><span class="line">      state = Memento.getState();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CareTaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Memento&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Memento state)</span>&#123;</span><br><span class="line">      mementoList.add(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> Memento <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">      <span class="type">CareTaker</span> <span class="variable">careTaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CareTaker</span>();</span><br><span class="line">      originator.setState(<span class="string">&quot;State #1&quot;</span>);</span><br><span class="line">      originator.setState(<span class="string">&quot;State #2&quot;</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">&quot;State #3&quot;</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">&quot;State #4&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;Current State: &quot;</span> + originator.getState());    </span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First saved State: &quot;</span> + originator.getState());</span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Second saved State: &quot;</span> + originator.getState());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>提供状态恢复机制</li><li>封装了状态信息</li></ul><p><strong>缺点</strong>：</p><ul><li>资源消耗大</li></ul><h2 id="解释器模式">解释器模式</h2><p>解释器模式提供了评估语言的语法或表达式的方式，它属于行为型模式。</p><p>解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h3 id="解释器模式结构">解释器模式结构</h3><ul><li><strong>抽象表达式</strong>：定义了解释器的抽象接口，声明了解释操作的方法，通常是一个抽象类或接口</li><li><strong>终结符表达式</strong>：实现了抽象表达式接口的终结符表达式类，用于表示语言中的终结符，并实现了对应的解释操作</li><li><strong>非终结符表达式</strong>：实现了抽象表达式接口的非终结符表达式类，用于表示语言中的非终结符，并实现了对应的解释操作</li><li><strong>上下文</strong>：包含解释器以外的一些全局信息</li></ul><h3 id="解释器模式实现">解释器模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String data;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TerminalExpression</span><span class="params">(String data)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.data = data; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String context)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(context.contains(data))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expr1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expr2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.expr1 = expr1;</span><br><span class="line">      <span class="built_in">this</span>.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String context)</span> &#123;      </span><br><span class="line">      <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expr1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expr2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.expr1 = expr1;</span><br><span class="line">      <span class="built_in">this</span>.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String context)</span> &#123;      </span><br><span class="line">      <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">//规则：Robert 和 John 是男性</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title function_">getMaleExpression</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">robert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;Robert&quot;</span>);</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(robert, john);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//规则：Julie 是一个已婚的女性</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title function_">getMarriedWomanExpression</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">julie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;Julie&quot;</span>);</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">married</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;Married&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndExpression</span>(julie, married);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">isMale</span> <span class="operator">=</span> getMaleExpression();</span><br><span class="line">      <span class="type">Expression</span> <span class="variable">isMarriedWoman</span> <span class="operator">=</span> getMarriedWomanExpression();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;John is male? &quot;</span> + isMale.interpret(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Julie is a married women? &quot;</span> </span><br><span class="line">      + isMarriedWoman.interpret(<span class="string">&quot;Married Julie&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>可拓展性好</li><li>灵活性好</li><li>易于实现简单的文法</li></ul><p><strong>缺点</strong>：</p><ul><li>适用场景有限，只适合用于比较简单的文法</li><li>维护困难，尤其是对于复杂的文法</li><li>类膨胀，可能会出现很多的类</li><li>递归调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h2&gt;
&lt;p&gt;迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示，类似于C++和Java的迭代器&lt;/p&gt;
&lt;h3 id=&quot;迭代器模式结构&quot;&gt;迭代器模式结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;迭代器接</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之状态模式、观察者模式、中介模式</title>
    <link href="https://yonagi04.github.io/posts/2024/0ed02d84529e/"/>
    <id>https://yonagi04.github.io/posts/2024/0ed02d84529e/</id>
    <published>2024-10-11T18:58:33.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态模式">状态模式</h2><p>状态模式允许对象在内部状态改变时改变其行为, 使得对象在不同的状态下有不同的行为表现. 通过将每个状态封装成独立的类, 可以避免使用大量的条件语句实现状态切换</p><h3 id="状态模式结构">状态模式结构</h3><ul><li><strong>状态接口</strong>: 声明行为方法</li><li><strong>具体状态类</strong>: 实现状态接口, 封装具体行为</li><li><strong>上下文类</strong>: 维护一个状态对象, 并提供方法以改变其状态</li></ul><h3 id="状态模式实现">状态模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现状态接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Player is in start state&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Player is in stop state&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">()</span> &#123;</span><br><span class="line">        state = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="type">State</span> <span class="variable">startState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartState</span>();</span><br><span class="line">        startState.doAction(context);</span><br><span class="line">        </span><br><span class="line">        <span class="type">State</span> <span class="variable">stopState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopState</span>();</span><br><span class="line">        stopState.doAction(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>封装状态转换规则</strong>: 将状态转换逻辑封装在状态对象内部</li><li><strong>易于拓展</strong>: 增加新的状态类不会影响现有的代码</li><li><strong>集中状态相关的行为</strong>: 状态相关的行为都集中在了状态类</li><li><strong>简化代码</strong>: 避免使用了复杂的条件代码来切换行为</li><li><strong>状态共享</strong>: 允许多个上下文对象共享同一个状态</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>增加类的数量</strong>: 每个状态都要一个具体的状态类</li><li><strong>实现复杂</strong>: 状态模式的实现比较复杂</li><li><strong>开闭原则支持不足</strong>: 修改状态行为可能需要修改现有代码</li></ul><h2 id="观察者模式">观察者模式</h2><p>观察者模式定义了一对多的依赖关系, 当一个对象的状态发生变化时, 其依赖者都会收到通知并自动更新</p><h3 id="观察者模式结构">观察者模式结构</h3><ul><li><strong>观察者接口</strong>: 包含一个观察者更新的方法</li><li><strong>具体观察者</strong>: 实现观察者接口, 定义接收到通知时的行为</li><li><strong>主题接口</strong>: 包含添加, 删除, 通知观察者的方法</li><li><strong>具体主题</strong>: 实现主题接口, 通知观察者</li></ul><h3 id="观察者模式实现">观察者模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实体观察者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Binary String: &quot;</span> + Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OctalObserver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OctalObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Octal String: &quot;</span> + Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hex String: &quot;</span> + Integer.toHexString(subject.getState()).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OctalObserver</span>(subject);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject);</span><br><span class="line">        </span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>抽象耦合</strong>: 观察者和主题之间是抽象耦合的</li><li><strong>触发机制</strong>: 建立了一套状态改变时的触发和通知机制</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>性能问题</strong>: 如果观察者众多, 通知过程可能耗时</li><li><strong>循环依赖</strong>: 可能导致循环调用</li><li><strong>缺乏变换详情</strong>: 观察者不知道主题如何变化, 只知道变化发生</li></ul><h2 id="中介者模式">中介者模式</h2><p>中介者模式定义了一个中介对象来封装一系列对象之间的交互. 中介者使各对象之间不需要显式地相互引用, 从而使其耦合松散, 且可以独立地改变它们之间的交互</p><h3 id="中介者模式结构">中介者模式结构</h3><ul><li><strong>中介者接口</strong>: 规定中介者必须实现的接口</li><li><strong>具体中介者</strong>: 实现中介者接口</li><li><strong>定义同事类</strong>：各个对象不需要显式地相互引用, 而是通过中介者来进行交互</li></ul><h3 id="中介者模式实现">中介者模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoom</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">(User user, String message)</span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>().toString()</span><br><span class="line">         + <span class="string">&quot; [&quot;</span> + user.getName() +<span class="string">&quot;] : &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name  = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">      ChatRoom.showMessage(<span class="built_in">this</span>,message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">robert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Robert&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      robert.sendMessage(<span class="string">&quot;Hi! John!&quot;</span>);</span><br><span class="line">      john.sendMessage(<span class="string">&quot;Hello! Robert!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>降低复杂度</strong>: 将对象间一对多的关系转换为一对一关系</li><li><strong>解耦</strong>: 对象之间不再直接引用, 通过中介者进行交互</li><li><strong>符合迪米特原则</strong>: 对象只需要知道中介者, 不需要知道其他对象</li></ul><p><strong>缺点</strong>:</p><ul><li>可能会变得复杂, 难以维护</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;状态模式&quot;&gt;状态模式&lt;/h2&gt;
&lt;p&gt;状态模式允许对象在内部状态改变时改变其行为, 使得对象在不同的状态下有不同的行为表现. 通过将每个状态封装成独立的类, 可以避免使用大量的条件语句实现状态切换&lt;/p&gt;
&lt;h3 id=&quot;状态模式结构&quot;&gt;状态模式结构&lt;/h3&gt;
&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入RocketMQ消息队列——消息原理</title>
    <link href="https://yonagi04.github.io/posts/2024/cc5c07c21950/"/>
    <id>https://yonagi04.github.io/posts/2024/cc5c07c21950/</id>
    <published>2024-10-02T15:47:36.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要讲解 RocketMQ 的消息原理方面相关理论，不涉及消息的底层存储过程</p></blockquote><h2 id="消息在-RocketMQ-中流转的过程与消息可靠性的保证">消息在 RocketMQ 中流转的过程与消息可靠性的保证</h2><p>在研究 RocketMQ 的消息原理之前，我们必须先了解 RocketMQ 的领域模型，以及消息在 RocketMQ 中流转的过程</p><h3 id="RocketMQ-领域模型">RocketMQ 领域模型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/mainarchi-9b036e7ff5133d050950f25838367a17.png" alt="Apache RocketMQ Main Architecture"></p><p>如上图所示，RocketMQ 中消息的生命周期主要分为消息生产、消息存储、消息消费三大流程。生产者生产消息并将其发送到 RocketMQ 服务端，消息被存储在服务端的主题中，消费者通过订阅主题来消费消息</p><p><strong>消息生产</strong></p><p>生产者（Producer）：RocketMQ 中用于产生消息的实体，一般继承于业务调用链路的上游。</p><p><strong>消息存储</strong></p><ul><li>主题（Topic）：RocketMQ 消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平拓展是由主题内的队列实现的</li><li>队列（MessageQueue）：RocketMQ 消息传输和存储的实际单元容器。RocketMQ 通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特征</li><li>消息（Message）：RocketMQ 的最小传输单元，消息具备不变性，在初始化和完成存储后不可变</li></ul><p><strong>消息消费</strong></p><ul><li>消费者分组（ConsumerGroup）：RocketMQ发布订阅模型中定义的独立的消费身份分组，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持消费逻辑和配置一致，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</li><li>消费者（Consumer）：RocketMQ 消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</li><li>订阅关系（Subscription）：RocketMQ 发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。RocketMQ 的订阅关系除过滤表达式之外都是持久化的，即服务端重启或请求断开，订阅关系依然保留。</li></ul><p>在了解领域模型之后，我们就可以基于这个领域模型，进一步了解消息的流转过程</p><h3 id="消息的发送流程">消息的发送流程</h3><p>一条消息从生产到被消费，大致会经历以下三个阶段</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.28/img/content/rocket-mq-message-send.png" alt=""></p><ul><li>生产阶段，Producer 新建消息，然后通过网络将消息发送给 MQ Broker服务器</li><li>存储阶段，消息存储在 Broker 端的磁盘</li><li>消费阶段，Consumer 从 Broker 拉取消息</li></ul><p>在这三个阶段，如果发生了网络波动、机器宕机、断电等异常情况，就可能导致消息的丢失。因此，消息的可靠性保证也从这三个阶段展开</p><h3 id="消息可靠性的保证">消息可靠性的保证</h3><h4 id="生产阶段">生产阶段</h4><p>生产者通过网络发送消息给 Broker，当 Broker 收到后，将会返回确认响应消息（ACK）给 Producer。所以只要生产者收到了返回的 ACK，就代表消息在生产过程中没有丢失</p><p>发送普通消息的示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通消息发送。</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilderImpl</span>();</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">    <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">    .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">    <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">    .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">    <span class="comment">//消息体。</span></span><br><span class="line">    .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常。</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send</code> 方法是一个同步操作，只要不抛出异常，就说明消息已经发送成功</p><p>另外，还有一种异步的 <code>send</code> 方法，但是需要重写一个回调方法，以确保在消息发送成功 or 失败后可以继续后续的业务流程</p><p>无论是同步发送还是异步发送，都有可能出现由于网络抖动而导致发送失败的情况。针对这种情况，可以设置合理的重试次数，当发送消息失败时，会自动重试发送</p><h4 id="Broker-存储阶段">Broker 存储阶段</h4><p>默认情况下，消息到达 Broker 端后，会先将消息保存在内存中，然后立刻返回 ACK 给 Producer，随后 Broker 会定期地将一组消息异步地写入磁盘，它可以减少磁盘的I/O次数，但是如果机器突然掉电或宕机，内存中的消息没有写入磁盘，就会出现丢失消息的情况</p><p>为了确保 Broker 端不丢失消息，Broker 端选择把消息记录到 CommitLog 中，关于记录到 CommitLog，也有两种方式：</p><ol><li><strong>同步刷盘</strong>：生产者将消息发送到 Broker 后，只有 Broker 将消息成功记录到 CommitLog 之后，才会返回 ACK。这种可靠性高，但是性能差</li><li><strong>异步刷盘</strong>：Broker 将消息写入 CommitLog 采用后台线程异步刷盘的方式，刷盘完成之后回调接口返回发送成功的 ACK。它的性能更好，但是 Broker 宕机时会丢失一部分没有写入到 CommitLog 的消息</li></ol><h4 id="消费阶段">消费阶段</h4><p>Consumer 从 Broker 拉取消息，并执行后续的业务逻辑，一旦执行成功，将会返回 <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code> 状态给 Broker</p><p>如果 Broker 没有收到ACK，Consumer 下次还会尝试拉取这条消息，进行重试，这样避免了 Consumer 在消费过程中出现了异常，或由于网络抖动而导致消息丢失的情况</p><p>消费普通消息的示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费普通消息，只需要在消费监听器中处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费普通消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息幂等性的保证">消息幂等性的保证</h2><p>在消息幂等性和消息可靠性的抉择之中，RocketMQ选择了保证消息可靠性，这就意味着在消息中间件层面上消息幂等性得不到保障，消息重复的问题需要开发者在业务层面自行解决</p><p>一般情况下，导致消息重复问题的原因可能是网络抖动。例如在消息的消费阶段，由于网络抖动，Consumer 返回给 Broker 的 ACK 丢失了，Broker 自然无法收到来自 Consumer 的 ACK。因此，当 Consumer 再次拉取消息时，就会拉取到已经消费过的消息，这就是消息重复</p><p>解决消息重复的方法是通过存储消息的 MessageID，通过在缓存或数据库中查找对应的 MessageID 来判断消息是否已经被消费过。一般可以通过 MySQL 或 Redis 的 Set 来存储消息的MessageID，但要根据具体业务来决定是采用 MySQL 还是采用 Redis</p><h2 id="消息堆积问题">消息堆积问题</h2><p>消息队列主要的作用是“削峰”，那么消息队列必然需要有一定的消息积压能力来保证后端服务的正常运作。</p><p>如果发生了消息积压，意味着 Consumer 的消费速度赶不上 Producer 的生产速度，这时候需要考虑提高 Consumer 的消费能力</p><ul><li>如果 Queue 的数量大于 Consumer 的数量，这时候需要做的是 <strong>消费者扩容</strong>，也就是把 Consumer 的数量增加到和 Queue 的数量一致</li><li>如果 Consumer 的数量大于等于 Queue 的数量但还是发生了消息积压问题，这时候需要做的是 <strong>消息迁移Queue扩容</strong>，具体来讲就是修改消费者的逻辑，让消费者使用一个临时的 Topic，在这个 Topic 下建立设置更多的 Consumer，然后把原来的消息转发到临时的 Topic 上，通过临时的 Topic 的 Consumer 来消费这些堆积的消息</li></ul><h2 id="定时消息">定时消息</h2><p>定时消息是 RocketMQ 提供的一种高级消息特性，消息被发送到服务端之后，在指定时间后才能被消费者消费</p><h3 id="SCHEDULE-TOPIC-XXXX-介绍"><code>SCHEDULE_TOPIC_XXXX</code> 介绍</h3><p><code>SCHEDULE_TOPIC_XXXX</code> 是 RocketMQ 一个系统类型的 Topic，用于标识延时消息</p><p>这个 Topic 有 18 个队列，分别唯一对应着 RocketMQ 的 18 个延时等级，对应关系为：queueId = delayTimeLevel - 1</p><h3 id="ScheduleMessageService-介绍"><code>ScheduleMessageService</code> 介绍</h3><p>这是 Broker 中的一个延时服务，专门消费 Topic 为 <code>SCHEDULE_TOPIC_XXXX</code> 的延时消息，并将其投递到目标 Topic 中</p><p><code>ScheduleMessageService</code> 在启动时，会创建一个定时器 Timer，并根据延迟级别的个数，启动对应数量的 TimerTask，每个 TimerTask 负责一个延迟级别的消费与投递</p><h3 id="延时消息的生命周期">延时消息的生命周期</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/lifecyclefordelay-2ce8278df69cd026dd11ffd27ab09a17.png" alt=""></p><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态</li><li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达</li><li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。 RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除</li></ul><h3 id="延时消息在-Broker-的轮转流程">延时消息在 Broker 的轮转流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.28/img/content/delay_message_send_process.png" alt=""></p><ol><li>Broker 把消息的 Topic 修改为 <code>SCHEDULE_TOPIC_XXX</code>，然后根据本次消息的延时等级计算需要投递到的具体队列。同时还需要把消息原来的 Topic 及其队列信息存储到消息的属性中，便于后面正确投递</li><li>在从 CommitLog 把消息转发到 Queue 的过程中，会计算这个延时消息什么时候进行投递，<strong>投递时间 = 消息存储时间 + 延时等级对应的时间</strong></li><li>延时队列服务 <code>ScheduleMessageService</code> 消费这个消息</li><li>从消息属性中取出并设置原来消息的 Topic 和队列信息，存储到 CommitLog，此时这条消息已经完成延时，所以 ConsumeQueue 中的 Message Tag HashCode 需要重新计算消息 Tag 的哈希值再存储</li><li>由于消息的 Topic 已经修改为原来的 Topic，所以直接投递到对应的队列中</li><li>消费者消费这条消息</li></ol><p>延时消息的示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时/延时消息发送</span></span><br><span class="line"><span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilderImpl</span>();;</span><br><span class="line"><span class="comment">//以下示例表示：延迟时间为10分钟之后的Unix时间戳。</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">deliverTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">10L</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">        .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">        <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">        .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">        .setDeliveryTimestamp(deliverTimeStamp)</span><br><span class="line">        <span class="comment">//消息体</span></span><br><span class="line">        .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//发送消息，需要关注发送结果，并捕获失败等异常。</span></span><br><span class="line">    <span class="type">SendReceipt</span> <span class="variable">sendReceipt</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">    System.out.println(sendReceipt.getMessageId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费示例一：使用PushConsumer消费定时消息，只需要在消费监听器处理即可。</span></span><br><span class="line"><span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">        System.out.println(messageView.getDeliveryTimestamp());</span><br><span class="line">        <span class="comment">//根据消费结果返回状态。</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//消费示例二：使用SimpleConsumer消费定时消息，主动获取消息进行消费处理并提交消费结果。</span></span><br><span class="line">List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">//消费处理完成后，需要主动调用ACK提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务消息">事务消息</h2><p>事务消息是 RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性</p><h3 id="实现事务消息的核心">实现事务消息的核心</h3><ul><li><strong>两阶段提交</strong>：第一阶段 Producer 发送 Half 消息到 Broker 测试 RocketMQ 是否正常；Broker只有在收到第二阶段的消息为 Commit 时，Consumer 才能对消息进行消费</li><li><strong>事务补偿机制</strong>：当 Broker 收到状态为 <code>unknown</code> 的消息或由于网络波动、Producer 宕机导致长时间没有收到第二阶段的提交时，Broker 会调用生产者接口来回查本次事务的状态</li></ul><h3 id="事务消息处理流程">事务消息处理流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png" alt=""></p><ol><li>生产者将消息发送至 RocketMQ 服务端。</li><li>RocketMQ 服务端将消息持久化成功之后，向生产者返回 ACK 确认消息已经发送成功，此时消息被标记为&quot;暂不能投递&quot;，这种状态下的消息即为半事务消息。</li><li>生产者开始执行本地事务逻辑。</li><li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit 或是 Rollback），服务端收到确认结果后处理逻辑如下：<ul><li>二次确认结果为 Commit ：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为 Rollback ：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ol><h3 id="事务消息生命周期">事务消息生命周期</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/lifecyclefortrans-fe4a49f1c9fdae5d590a64546722036f.png" alt=""></p><ul><li><p>初始化：半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</p></li><li><p>事务待提交：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</p></li><li><p>消息回滚：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</p></li><li><p>提交待消费：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</p></li><li><p>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ会对消息进行重试处理。</p></li><li><p>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。 Apache RocketMQ默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</p></li><li><p>消息删除：Apache RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</p></li></ul><p>事务消息的示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示demo，模拟订单表查询服务，用来确认订单事务是否提交成功。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkOrderById</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示demo，模拟本地事务的执行结果。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doLocalTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientException &#123;</span><br><span class="line">    <span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceProvider</span>();</span><br><span class="line">    <span class="type">MessageBuilder</span> <span class="variable">messageBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBuilderImpl</span>();</span><br><span class="line">    <span class="comment">//构造事务生产者：事务消息需要生产者构建一个事务检查器，用于检查确认异常半事务的中间状态。</span></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> provider.newProducerBuilder()</span><br><span class="line">            .setTransactionChecker(messageView -&gt; &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 事务检查器一般是根据业务的ID去检查本地事务是否正确提交还是回滚，此处以订单ID属性为例。</span></span><br><span class="line"><span class="comment">                 * 在订单表找到了这个订单，说明本地事务插入订单的操作已经正确提交；如果订单表没有订单，说明本地事务已经回滚。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> messageView.getProperties().get(<span class="string">&quot;OrderId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (Strings.isNullOrEmpty(orderId)) &#123;</span><br><span class="line">                    <span class="comment">// 错误的消息，直接返回Rollback。</span></span><br><span class="line">                    <span class="keyword">return</span> TransactionResolution.ROLLBACK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> checkOrderById(orderId) ? TransactionResolution.COMMIT : TransactionResolution.ROLLBACK;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//开启事务分支。</span></span><br><span class="line">    <span class="keyword">final</span> Transaction transaction;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        transaction = producer.beginTransaction();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//事务分支开启失败，直接退出。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageBuilder.setTopic(<span class="string">&quot;topic&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息索引键，可根据关键字精确查找某条消息。</span></span><br><span class="line">            .setKeys(<span class="string">&quot;messageKey&quot;</span>)</span><br><span class="line">            <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">            .setTag(<span class="string">&quot;messageTag&quot;</span>)</span><br><span class="line">            <span class="comment">//一般事务消息都会设置一个本地事务关联的唯一ID，用来做本地事务回查的校验。</span></span><br><span class="line">            .addProperty(<span class="string">&quot;OrderId&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">            <span class="comment">//消息体。</span></span><br><span class="line">            .setBody(<span class="string">&quot;messageBody&quot;</span>.getBytes())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">//发送半事务消息</span></span><br><span class="line">    <span class="keyword">final</span> SendReceipt sendReceipt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendReceipt = producer.send(message, transaction);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">        <span class="comment">//半事务消息发送失败，事务可以直接退出并回滚。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务，并确定本地事务结果。</span></span><br><span class="line"><span class="comment">     * 1. 如果本地事务提交成功，则提交消息事务。</span></span><br><span class="line"><span class="comment">     * 2. 如果本地事务提交失败，则回滚消息事务。</span></span><br><span class="line"><span class="comment">     * 3. 如果本地事务未知异常，则不处理，等待事务消息回查。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">localTransactionOk</span> <span class="operator">=</span> doLocalTransaction();</span><br><span class="line">    <span class="keyword">if</span> (localTransactionOk) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 业务可以自身对实时性的要求选择是否重试，如果放弃重试，可以依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            <span class="comment">// 建议记录异常信息，回滚异常时可以无需重试，依赖事务消息回查机制进行事务状态的提交。</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息发送重试与消息流控">消息发送重试与消息流控</h2><h3 id="重试的基本概念">重试的基本概念</h3><p>RocketMQ 客户端连接服务端发起消息发送请求时，可能会因为网络故障、服务异常等原因导致调用失败。为保证消息的可靠性， RocketMQ 在客户端SDK中内置请求重试逻辑，尝试通过重试发送达到最终调用成功的效果。</p><p>同步发送和异步发送模式均支持消息发送重试。</p><h3 id="重试的触发条件">重试的触发条件</h3><p>触发消息发送重试机制的条件如下：</p><ul><li>客户端消息发送请求调用失败或请求超时</li><li>网络异常造成连接失败或请求超时。</li><li>服务端节点处于重启或下线等状态造成连接失败。</li><li>服务端运行慢造成请求超时。</li><li>服务端返回失败错误码<ul><li>系统逻辑错误：因运行逻辑不正确造成的错误。</li><li>系统流控错误：因容量超限造成的流控错误。</li></ul></li></ul><blockquote><p>对于事物消息，只会进行 <strong>透明重试（transparent retries）</strong>，网络超时或异常等场景不会进行重试</p></blockquote><h3 id="重试流程">重试流程</h3><p>Producer 在初始化时设置消息发送最大重试次数，当触发了上述条件时，Producer 客户端会按照重试的最大次数一直重试发送消息，直到消息发送成功或已经达到最大重试次数，并在最后一次重试失败后返回调用错误响应</p><ul><li>同步发送：调用线程会一直阻塞，直到某次重试成功或彻底重试失败并返回错误码、抛出异常</li><li>异步发送：调用线程不会阻塞，但调用结果会通过异常事件或成功事件返回</li></ul><h3 id="重试间隔">重试间隔</h3><ul><li>除了服务端返回系统流控错误场景，其他触发条件触发重试之后，均会立即重试，无等待间隔</li><li>若由于服务端返回了系统流控错误触发了重试，系统会按照 <strong>指数退避策略</strong> 进行延迟重试。指数退避算法通过以下参数控制重试行为：<ul><li>INITIAL_BACKOFF：第一次失败重试前后需要等待多久，默认值为1s</li><li>MULTIPLIER：指数退避因子，即退避倍率，默认值为1.6</li><li>JITTER：随即抖动因子，默认值为0.2</li><li>MAX_BACKOFF：等待间隔时间上限，默认值为120s</li><li>MIN_CONNECT_TIMEOUT：最短重试间隔，默认值为20s</li></ul></li></ul><h3 id="流控的基本概念">流控的基本概念</h3><p>消息流控指的是系统容量或水位过高， RocketMQ 服务端会通过快速失败返回流控错误来避免底层资源承受过高压力。</p><h3 id="流控的触发条件">流控的触发条件</h3><ul><li>存储压力大：参考 <a href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">消费进度管理</a> 的原理机制，消费者分组的初始消费位点为当前队列的最大消费位点。若某些场景例如业务上新等需要回溯到指定时刻前开始消费，此时队列的存储压力会瞬间飙升，触发消息流控。</li><li>服务端请求任务排队溢出：若消费者消费能力不足，导致队列中有大量堆积消息，当堆积消息超过一定数量后会触发消息流控，减少下游消费系统压力。</li></ul><h2 id="消费者分类">消费者分类</h2><p>RocketMQ 支持 PushConsumer 、 SimpleConsumer 以及 PullConsumer 这三种类型的消费者</p><h3 id="PushConsumer">PushConsumer</h3><p>PushConsumers是一种高度封装的消费者类型，消费消息仅通过消费监听器处理业务并返回消费结果。消息的获取、消费状态提交以及消费重试都通过 RocketMQ 的客户端SDK完成。</p><h4 id="使用方式">使用方式</h4><p>PushConsumer的使用方式比较固定，在消费者初始化时注册一个消费监听器，并在消费监听器内部实现消息处理逻辑。由 RocketMQ 的SDK在后台完成消息获取、触发监听器调用以及进行消息重试处理。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费示例：使用PushConsumer消费普通消息。</span></span><br><span class="line"><span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line"><span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;YourTopic&quot;</span>;</span><br><span class="line"><span class="type">FilterExpression</span> <span class="variable">filterExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterExpression</span>(<span class="string">&quot;YourFilterTag&quot;</span>, FilterExpressionType.TAG);</span><br><span class="line"><span class="type">PushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> provider.newPushConsumerBuilder()</span><br><span class="line">    <span class="comment">// 设置消费者分组。</span></span><br><span class="line">    .setConsumerGroup(<span class="string">&quot;YourConsumerGroup&quot;</span>)</span><br><span class="line">    <span class="comment">// 设置接入点。</span></span><br><span class="line">    .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(<span class="string">&quot;YourEndpoint&quot;</span>).build())</span><br><span class="line">    <span class="comment">// 设置预绑定的订阅关系。</span></span><br><span class="line">    .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">    <span class="comment">// 设置消费监听器。</span></span><br><span class="line">    .setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">            <span class="comment">// 消费消息并返回处理结果。</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeResult.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>PushConsumer的消费监听器执行结果分为以下三种情况：</p><ul><li>返回消费成功：以Java SDK为例，返回<code>ConsumeResult.SUCCESS</code>，表示该消息处理成功，服务端按照消费结果更新消费进度。</li><li>返回消费失败：以Java SDK为例，返回<code>ConsumeResult.FAILURE</code>，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费。</li><li>出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费。</li></ul><p>PushConsumer 消费消息时，若消息处理逻辑出现预期之外的阻塞导致消息处理一直无法执行成功，SDK会按照消费超时处理强制提交消费失败结果，并按照消费重试逻辑进行处理。</p><h4 id="内部原理">内部原理</h4><p>在PushConsumer类型中，消息的实时处理能力是基于SDK内部的典型Reactor线程模型实现的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/pushconsumer-26b909b090d4f911a40d5050d3ceba1d.png" alt=""></p><p>SDK内置了一个长轮询线程，先将消息异步拉取到SDK内置的缓存队列中，再分别提交到消费线程中，触发监听器执行本地消费逻辑。</p><h3 id="SimpleConsumer">SimpleConsumer</h3><p>SimpleConsumer 是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。</p><h4 id="使用方式-2">使用方式</h4><p>SimpleConsumer 的使用涉及多个接口调用，由业务逻辑按需调用接口获取消息，然后分发给业务线程处理消息，最后按照处理的结果调用提交接口，返回服务端当前消息的处理结果。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。 </span></span><br><span class="line"><span class="type">ClientServiceProvider</span> <span class="variable">provider</span> <span class="operator">=</span> ClientServiceProvider.loadService();</span><br><span class="line"><span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;YourTopic&quot;</span>;</span><br><span class="line"><span class="type">FilterExpression</span> <span class="variable">filterExpression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterExpression</span>(<span class="string">&quot;YourFilterTag&quot;</span>, FilterExpressionType.TAG);</span><br><span class="line"><span class="type">SimpleConsumer</span> <span class="variable">simpleConsumer</span> <span class="operator">=</span> provider.newSimpleConsumerBuilder()</span><br><span class="line">        <span class="comment">// 设置消费者分组。</span></span><br><span class="line">        .setConsumerGroup(<span class="string">&quot;YourConsumerGroup&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置接入点。</span></span><br><span class="line">        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(<span class="string">&quot;YourEndpoint&quot;</span>).build())</span><br><span class="line">        <span class="comment">// 设置预绑定的订阅关系。</span></span><br><span class="line">        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))</span><br><span class="line">        <span class="comment">// 设置从服务端接受消息的最大等待时间</span></span><br><span class="line">        .setAwaitDuration(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SimpleConsumer 需要主动获取消息，并处理。</span></span><br><span class="line">    List&lt;MessageView&gt; messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">    messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">        System.out.println(messageView);</span><br><span class="line">        <span class="comment">// 消费处理完成后，需要主动调用 ACK 提交消费结果。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleConsumer.ack(messageView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to ack message, messageId=&#123;&#125;&quot;</span>, messageView.getMessageId(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">    logger.error(<span class="string">&quot;Failed to receive message&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费重试">消费重试</h2><p>消费重试指的是，消费者在消费某条消息失败后，Apache RocketMQ 服务端会根据重试策略重新消费该消息，超过一定次数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中。</p><p><strong>消息重试的触发条件</strong></p><ul><li>消费失败，包括消费者返回消息失败状态标识或抛出非预期异常。</li><li>消息处理超时，包括在PushConsumer中排队超时。</li></ul><p><strong>消息重试策略主要行为</strong></p><ul><li>重试过程状态机：控制消息在重试流程中的状态和变化逻辑。</li><li>重试间隔：上一次消费失败或超时后，下次重新尝试消费的间隔时间。</li><li>最大重试次数：消息可被重试消费的最大次数。</li></ul><p><strong>消息重试策略差异</strong></p><p>根据消费者类型不同，消息重试策略的具体内部机制和设置方法有所不同，具体差异如下：</p><table><thead><tr><th>消费者类型</th><th>重试过程状态机</th><th>重试间隔</th><th>最大重试次数</th></tr></thead><tbody><tr><td>PushConsumer</td><td>已就绪 处理中 待重试 提交死信</td><td>消费者分组创建时的元数据控制</td><td>消费者分组创建时的元数据控制</td></tr><tr><td>SimpleConsumer</td><td>已就绪 处理中 提交死信</td><td>通过API修改获取消息时的不可见时间</td><td>消费者分组创建时的元数据控制</td></tr></tbody></table><h3 id="PushConsumer-消费重试策略">PushConsumer 消费重试策略</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/retrymachinestatus-37ddbd0a20b8736e34bb88f565945d16.png" alt=""></p><ul><li>Ready：已就绪状态。消息在 RocketMQ 服务端已就绪，可以被消费者消费。</li><li>Inflight：处理中状态。消息被 Consumer 客户端获取，处于消费中还未返回消费结果的状态。</li><li>WaitingRetry：待重试状态，PushConsumer 独有的状态。当 Consumer 消息处理失败或消费超时，会触发消费重试逻辑判断。如果当前重试次数未达到最大次数，则该消息变为待重试状态，经过重试间隔后，消息将重新变为已就绪状态可被重新消费。多次重试之间，可通过重试间隔进行延长，防止无效高频的失败。</li><li>Commit：提交状态。消费成功的状态，消费者返回成功响应即可结束消息的状态机。</li><li>DLQ：死信状态。消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。您可以通过消费死信队列的消息进行业务恢复。</li></ul><p>消息重试过程中，每次重试消息状态都会经过已就绪&gt;处理中&gt;待重试的变化，两次消费间的间隔时间实际由消费耗时及重试间隔控制，消费耗时的最大上限受服务端系统参数控制，一般不应该超过上限时间。</p><p>PushConsumer 的最大重试次数由 Consumer 分组创建时的元数据控制</p><p>PushConsumer的消费重试示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleConsumer</span> <span class="variable">simpleConsumer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//消费示例：使用PushConsumer消费普通消息，如果消费失败返回错误，即可触发重试。</span></span><br><span class="line">        <span class="type">MessageListener</span> <span class="variable">messageListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeResult <span class="title function_">consume</span><span class="params">(MessageView messageView)</span> &#123;</span><br><span class="line">                System.out.println(messageView);</span><br><span class="line">                <span class="comment">//返回消费失败，会自动重试，直至到达最大重试次数。</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeResult.FAILURE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h3 id="SimpleConsumer-消费重试策略">SimpleConsumer 消费重试策略</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://rocketmq.apache.org/zh/assets/images/simplemachinestatus-1844bd0115b315e32661cf20b1732db0.png" alt=""></p><ul><li>Ready：已就绪状态。消息在 RocketMQ 服务端已就绪，可以被 Consumer 消费。</li><li>Inflight：处理中状态。消息被 Consumer 客户端获取，处于消费中还未返回消费结果的状态。</li><li>Commit：提交状态。消费成功的状态，Consumer 返回成功响应即可结束消息的状态机。</li><li>DLQ：死信状态。消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。</li></ul><p>和 PushConsumer 消费重试策略不同的是，SimpleConsumer 消费者的重试间隔是预分配的，每次获取消息消费者会在调用 API 时设置一个不可见时间参数 InvisibleDuration，即消息的最大处理时长。若消息消费失败触发重试，不需要设置下一次重试的时间间隔，直接复用不可见时间参数的取值。</p><p>SimpleConsumer 的最大重试次数由 Consumer 分组创建时的元数据控制</p><p>SimpleConsumer的消费重试示例代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费示例：使用SimpleConsumer消费普通消息，如果希望重试，只需要静默等待超时即可，服务端会自动重试。</span></span><br><span class="line">       List&lt;MessageView&gt; messageViewList = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           messageViewList = simpleConsumer.receive(<span class="number">10</span>, Duration.ofSeconds(<span class="number">30</span>));</span><br><span class="line">           messageViewList.forEach(messageView -&gt; &#123;</span><br><span class="line">               System.out.println(messageView);</span><br><span class="line">               <span class="comment">//如果处理失败，希望服务端重试，只需要忽略即可，等待消息再次可见后即可重试获取。</span></span><br><span class="line">           &#125;);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">           <span class="comment">//如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。</span></span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要讲解 RocketMQ 的消息原理方面相关理论，不涉及消息的底层存储过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;消息在-RocketMQ-中流转的过程与消息可靠性的保证&quot;&gt;消息在 RocketMQ 中流转的过程与消息可靠性的保</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="消息队列" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RocketMQ" scheme="https://yonagi04.github.io/tags/RocketMQ/"/>
    
    <category term="消息队列" scheme="https://yonagi04.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>大刀阔斧砍掉了一些东西</title>
    <link href="https://yonagi04.github.io/posts/2024/9dd863e8c349/"/>
    <id>https://yonagi04.github.io/posts/2024/9dd863e8c349/</id>
    <published>2024-10-01T20:05:29.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>文如其名，我把博客中一些不常用又影响使用体验（比如访问速度）的功能or资源给“砍”掉了</p><p>比如Chatra，这个功能自从引入之后就从来没有使用过，但是会影响正常用户的使用体验（根据我个人的实测，获取+加载Chatra的JavaScript脚本大概需要20s左右的时间，这无疑是严重影响用户使用体验的）（当然，我这个破站恐怕也没有什么用户）；比如unpkg的CDN，虽然服务器节点就在香港，但是速度并不是很理想——有时候会出现加载了十几秒甚至几十秒都加载不完资源的情况。</p><p>所以我大概做了以下几点改进：</p><ol><li>砍掉了Chatra的实时聊天功能，毕竟作为静态博客站点，不需要也没必要使用实时聊天功能（是上周有个用户看了我的文章，通过qq私信我之后，才想到这个功能根本就用不到，毕竟我已经留了我的联系方式了）</li><li>把静态资源的CDN从原来的Unpkg修改为国内的某公益CDN</li><li>删除了一些已经不需要的资源</li></ol><p>或许可以让本站的访问速度变得更快一点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文如其名，我把博客中一些不常用又影响使用体验（比如访问速度）的功能or资源给“砍”掉了&lt;/p&gt;
&lt;p&gt;比如Chatra，这个功能自从引入之后就从来没有使用过，但是会影响正常用户的使用体验（根据我个人的实测，获取+加载Chatra的JavaScript脚本大概需要20s左右的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>本周面试总结</title>
    <link href="https://yonagi04.github.io/posts/2024/7400043a3c2c/"/>
    <id>https://yonagi04.github.io/posts/2024/7400043a3c2c/</id>
    <published>2024-09-14T20:15:15.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，这篇blog就是来总结这周的面试的</p><p>这周的面试真的拉满了。上周三摔了车之后，周四就开始陆陆续续约面试。首先是广州的一家小厂和字节跳动约了面试，小厂我放在了这周一，字节放在了周二。周四的时候快手也约了面试，我放在了周六。</p><p>周一一大早我就坐着b25公交车出发去天河面试，小厂的面试体验真的很糟糕，首先就是面试官迟到，迟到了接近20min（当然，我可以接受，据说是面试官在开会），然后就是他“拷打”的一些方向让我难以理解，可能我和他解决问题的思路不太一样吧，所以最后自然也就没了下文。</p><p>周二就是字节跳动的面试，字节给我的印象就非常好：首先是HR，约面试的时间比较能尊重候选人（也就是我）的意见，在约一面之前也能介绍部门的主要工作内容；然后是一面的面试官，和我以前在acm队的时候认识的一个师兄非常相像。我和一面的面试官倒是“相谈甚欢”，所以一面结束之后很快就约了二面；二面的面试官是一个女面试官，看起来气色不太好，发际线也非常高，二面就没有那么顺利了，感觉自己缺的东西还是有点多，面试的表现也不太好，最后倒在了二面，有点可惜。希望之后还能打复活赛，打赢复活赛了再进字节吧</p><p>周六（也就是今天）下午是快手的一面。快手的面试官也是女面试官，疯狂问我测试相关的技术（因为我投的测试开发），知道我测试几乎是一窍不通之后就选择问我计算机基础、MySQL这种八股题了，好在这部分答的还不错。算法题给了两道双指针题，很快就ak了。面试结束后大概半个小时就约了二面，二面在下周三（也就是中秋假期结束后）</p><hr><p>所以这周可以叫做面试周，一堆面试，不是在面试就是在准备面试的路上。不知道下周还会不会有新面试，大概率是没有了吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顾名思义，这篇blog就是来总结这周的面试的&lt;/p&gt;
&lt;p&gt;这周的面试真的拉满了。上周三摔了车之后，周四就开始陆陆续续约面试。首先是广州的一家小厂和字节跳动约了面试，小厂我放在了这周一，字节放在了周二。周四的时候快手也约了面试，我放在了周六。&lt;/p&gt;
&lt;p&gt;周一一大早我就坐</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库与缓存一致性的解决方案</title>
    <link href="https://yonagi04.github.io/posts/2024/f0084df8053c/"/>
    <id>https://yonagi04.github.io/posts/2024/f0084df8053c/</id>
    <published>2024-08-29T19:04:00.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>数据库和缓存的数据一致性问题一直是老生常谈的话题了，它不仅在面试中十分常见，而且在实际开发中也是需要加以考量的因素。借着难得的空暇时光（其实是晚上不太想写代码），笔者今天想和大家简单讨论一下，数据库和缓存的数据一致性问题，以及如何避免or解决数据库和缓存的数据不一致的问题。</p><h2 id="为什么要引入缓存？">为什么要引入缓存？</h2><p>在我们的后端系统没有引入缓存之前，我们的后端系统大致来讲应该是类似于这样的模型。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_database.webp" alt=""></p><p>应用服务器中的数据库驱动通过网络I/O向数据库发增删改查操作的请求，数据库通过硬盘I/O在硬盘读/写相应数据之后，再通过网络I/O返回给应用服务器的数据库驱动，然后完成后续的业务操作。</p><p>这个模型在请求量较小的时候，是行得通的。但是当请求量变大，就会出现性能问题，而这个性能问题的瓶颈就出在硬盘I/O上。</p><p>我们都知道，内存的读写速度大于磁盘的读写速度，那么我们可以考虑将一些数据放到内存中，这样就能有效加快整体的响应速度。此时的模型应当是这样的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_cache_database_1.webp" alt=""></p><p>对于缓存，我们有以下几个疑问：</p><ol><li>对于缓存中存放的数据，是存放全部数据，还是存放热点数据？</li><li>假如数据库中的数据发生了更新/删除，缓存中对应的数据要怎么处理？</li></ol><p>最简单的思路是，<strong>将数据库中的所有数据全部刷到缓存，然后定时将数据库的数据再次刷到缓存里面</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_cache_database_2.webp" alt=""></p><p>但是这又带来了两个问题：</p><ol><li>缓存的利用率不高。因为有些非热点数据也被放进了缓存，但是这些数据正如其名，很少被访问，所以缓存的利用率并不高</li><li>定时刷新会带来数据库和缓存的不一致问题。因为这里用了定时刷新缓存的方案，假如数据库中的数据发生了更新/删除，那么需要等到下一次刷新缓存才能把缓存中的数据更新为新的数据。在更新数据库到刷新缓存之间的窗口期就是数据不一致的窗口期，窗口期越长，数据不一致带来的负面影响就越大。</li></ol><p>因此这个方案实际上无人采用，我们更倾向于下面这个方案：<strong>将数据库中的热点数据刷新到缓存中，并设置一个过期时间。对于热点数据的请求，先查看缓存中是否有对应的数据，如果没有再去查数据库，查询到对应的数据后返回并同时写回缓存中。当数据库的数据发生更新/删除时，缓存中对应的数据也需要做对应操作。（如果这个数据存在的话）</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_cache_database_3.webp" alt=""></p><p>这样，缓存中不常访问的数据，都会随着时间的推移而过期，这样缓存中保存的数据就都是热点数据了。缓存的利用率问题成功解决。</p><p>那么，数据不一致的问题呢？我们刚刚提到，当数据库的数据发生更新/删除时，缓存中对应的数据也需要做对应操作，这个操作是更新还是删除？这个操作应该发生在数据库更新/删除之前，还是发生在数据库更新/删除之后？</p><h2 id="多级存储结构带来的数据不一致问题">多级存储结构带来的数据不一致问题</h2><p>对于这个问题，我们有四个选择（假设此时数据库中的数据发生了更新）：</p><ol><li>先更新数据库，再更新缓存</li><li>先更新缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li><li>先删除缓存，再更新数据库</li></ol><p>哪种最可靠呢？实际上四种都不大可靠。对于这四种完全不同的解决方案，我们都可以构造出可以让它们发生数据不一致问题的情形——第二步操作失败。</p><p>假设某热点数据存在于数据库和缓存中，初始的数据为10，我们需要将其更新为20。</p><p>对于方案1，第一步操作之后数据库的数据更新为20，但是如果缓存中的数据更新失败了，仍然为10，那么就发生了数据不一致。</p><p>对于方案4，第一步操作之后缓存中的数据被删除了，但是数据库中的数据更新失败，仍然为10，那么就发生了数据不一致。</p><p>方案2和方案3同样很容易构造出数据不一致的情形，以下不再赘述。</p><p>因为更新数据库和更新/删除缓存并不是一个原子操作，所以一旦第二步操作失败了，就会发生数据不一致的问题。尽管操作失败的概率非常非常低，但如同墨菲定律——“<strong>If it can go wrong, it will.</strong>&quot;，最恶劣的情况往往不会发生，但不代表一定不会发生。因此我们需要考虑第二步操作失败而带来数据不一致的问题。</p><p>在讨论如何解决第二步操作失败而带来的数据不一致之前，让我们先转移一下视线，先看向导致数据不一致的另外一个”罪魁祸首“，<strong>高并发环境</strong>。</p><h2 id="高并发环境带来的数据不一致问题">高并发环境带来的数据不一致问题</h2><p>高并发环境为什么会导致数据不一致？</p><p>对于上面提到的四种解决方案，我们假设两步操作都能操作成功，假设现在是在一个多线程的环境下，情况又会如何？</p><p>如果我们采用了”先更新数据库，再更新缓存“，假设某热点数据存在于数据库和缓存中，初始的数据为10。</p><p>有线程A和线程B两个线程，都需要更新这条数据，那么可能出现如下情况：</p><ol><li>线程A更新数据为20</li><li>线程B更新数据为30</li><li>线程B更新缓存为30</li><li>线程A更新缓存为20</li></ol><p>两步操作都是成功的，但是还是发生了数据不一致！这是为什么？我们发现线程A的两步操作之间被插入了线程B的操作，而线程B的操作直接导致了数据库与缓存的数据不一致。</p><p>同样的，”先更新缓存，再更新数据库“的方案也会带来数据不一致，这里不再赘述。</p><p>实际上，我们没必要在更新数据库的时候同时更新缓存！从缓存利用率的角度来考虑，假设数据更新完之后，读的次数相对较少，那么缓存利用率就提不起来；而且，如果写入缓存的值并非是数据库中原始的值，而是经过了其他的计算再把值写入缓存，那么“更新缓存”的方案就会带来性能问题</p><p>因此我们考虑另外一类方案，“删除缓存”</p><h2 id="删除缓存就一定能保证数据一致性吗？">删除缓存就一定能保证数据一致性吗？</h2><p>对于“删除缓存”的方案，我们同样有两种选择：</p><ol><li>先更新数据库，再删除缓存</li><li>先删除缓存，再更新数据库</li></ol><p>我们一个一个来分析。</p><ol><li>先更新数据库，再删除缓存</li></ol><p>假设某热点数据存在于数据库中，初始的数据为10。有线程A和线程B两个线程，线程A需要写数据，线程B需要读数据，那么可能会出现如下情况：</p><p>​1）线程B读数据，由于缓存中不存在这条数据，因此读数据库中的数据</p><p>​2）线程B读到数据为10</p><p>​3）线程A更新数据为20</p><p>​4）线程A删除缓存</p><p>​5）线程B将数据10写入缓存</p><p>数据不一致由此发生。</p><ol start="2"><li>先删除缓存，再更新数据库</li></ol><p>假设某热点数据存在于数据库中，初始的数据为10。有线程A和线程B两个线程，线程A需要写数据，线程B需要读数据，那么可能会出现如下情况：</p><p>​1）线程A删除缓存</p><p>​2）线程B读数据，由于缓存中不存在这条数据，因此读数据库中的数据</p><p>​3）线程B读到数据为10</p><p>​4）线程A更新数据为20</p><p>​5）线程B将数据10写入缓存</p><p>数据不一致由此发生。</p><p>这样看来，无论哪个都没法解决数据不一致的问题，那该如何是好？那么我们只能“矮个子挑高个”，选择一个相对来讲较优的方案。我们都知道，写内存的时间短于写硬盘的时间，那么“先更新数据库，再删除缓存”显然是比“先删除缓存，再更新数据库”更优的，因为数据不一致主要发生在写线程的两步操作之间，而删除缓存的时间显然比更新数据库的时间要短得多，留给读线程的“机会”自然也就更少。</p><p>这样看来，我们似乎已经解决了高并发环境下带来的数据不一致问题。但是别忘了我们遗留在前面的一个小tip——如果第二步操作失败了（也就是删除失败），也会导致数据不一致。如何解决？</p><h2 id="无脑重试，能解决数据不一致问题？">无脑重试，能解决数据不一致问题？</h2><p>删除失败了，那就重试呗！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/delete_cache_retry.webp" alt=""></p><p>删除失败了，就不断尝试，直到缓存被删除。但是如果一直删除失败呢？是不是要一直尝试？重试需不需要有时间间隔？如果一直失败会阻塞这个线程，那还能接收其他客户端请求吗？这个线程资源不就被浪费了？</p><p>由此看来，无脑删除并不能解决数据不一致的问题，尤其是这种“同步”删除。基于这个方案，我们提出了一个更好的解决方案，这就是**“异步”删除**。具体来讲就是把缓存删除的任务放进消息队列，让专门的消费者来删除缓存。</p><p>引入消息队列是否会带来额外的维护成本？在我看来是不会的，因为消息队列是非常常见的中间件，不会增加维护成本；而消息队列本身可以做到持久化，在消息被消费之前一般来讲都不会丢失消息，这和“同步”删除简直是大相径庭（“同步”删除会不断地尝试删除缓存，假如此时项目重启，或服务器宕机，那么删除请求就会永久丢失，数据就永远不一致了）</p><p>引入消息队列之后的模型应该是这样的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_cache_mq_database.webp" alt=""></p><p>如果不想写消息队列，有无其他解决方案？</p><p>目前比较流行的解决方案就是，通过中间件来监听数据库的变更日志（如MySQL的Binlog），根据变更日志中提到的操作的数据，去缓存中删除对应的缓存。常用的中间件有阿里巴巴开源的canal，通过监听MySQL的Binlog，自动向消息队列投递变更的数据，消费者再去缓存删除对应的数据。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.24/img/content/application_canal_cache_database.webp" alt=""></p><p>但是这个方案就需要额外维护canal，保证canal的可用性。</p><h2 id="延迟双删策略">延迟双删策略</h2><p>对于解决数据不一致问题，业界还有另外一个知名的解决方案，那就是<strong>延迟双删策略</strong>。</p><p>延迟双删策略就是在原来“先删缓存，再更新数据库”的基础上，让线程休眠一段时间，再去删除对应的缓存，从而避免缓存中出现脏数据，因而保证数据一致性</p><p>那么又引出一个新的问题，“延迟双删策略”的“延迟”，具体要延迟多久？</p><p>一般来讲，延迟的时间应当大于读线程读取数据库+写入缓存的时间，但是在高并发环境下，这个时间非常难衡量，而且仍然会有概率导致数据不一致，所以一般推荐“先更新数据库，再删除缓存”，并在这个方案的基础上采用消息队列或canal来实现异步删除。</p><h2 id="强一致还是弱一致？">强一致还是弱一致？</h2><p>什么是强一致性和弱一致性？</p><p>Bing Copilot给了我这样的答案：</p><blockquote><p>强一致性和弱一致性是分布式系统中的两种数据一致性模型。让我为您解释一下它们的区别：</p><ol><li><strong>强一致性</strong>（也称为线性一致性）：<ul><li>当一个系统中的数据被修改时，其他所有系统的数据都能实时地反映出这个修改。</li><li>也就是说，如果在一个系统中修改了某个数据项，那么这个修改将会立即反映到其他所有的系统中。</li><li>强一致性可以保证从库有与主库一致的数据，即使主库宕机，数据仍然完整。</li></ul></li><li><strong>弱一致性</strong>：<ul><li>在系统中，数据的修改可能不会立即反映到所有系统中。</li><li>也就是说，在某个系统中修改了数据项后，可能需要经过一段时间，这个修改才会在其他系统中体现出来。</li><li>弱一致性允许一些暂时的不一致状态，但最终会达到一致的状态。</li></ul></li></ol></blockquote><p>在一个引入缓存的系统中，我们能做到强一致性吗？其实几乎是不可能的，或者说可以做到，但是需要一点性能作为代价——引入分布式锁，但是引入分布式锁也就违背了我们引入缓存的初衷——加快系统的响应速度。所以当选择了缓存，也就默认了放弃强一致性，性能和一致性往往是不可兼得的。根据本文上面所提到的内容，我们更多的是追求“弱一致性”，也就是追求最终达到数据一致的状态。即使本文上面所提到的方法都失效了，因为缓存有过期时间可以作为一致性的兜底，即使存在数据不一致的情况，当缓存过期，也就达到了最终一致的状态，尽管这个“最终一致”看起来不太体面罢了。</p><h2 id="总结">总结</h2><ol><li>引入缓存可以有效加快系统响应速度。</li><li>多级缓存结构会带来数据不一致。而解决数据不一致问题我们有四种解决方案。</li><li>考虑到高并发带来的数据不一致问题，我们推荐使用“删除缓存”的策略。</li><li>对于“删除缓存”策略而言，更加推荐使用“先更新数据库再删缓存”，“延迟双删策略”看似好用，实则难以估计延迟时间。</li><li>建议采用消息队列+canal中间件监听MySQL的Binlog的方式实现异步删除缓存</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库和缓存的数据一致性问题一直是老生常谈的话题了，它不仅在面试中十分常见，而且在实际开发中也是需要加以考量的因素。借着难得的空暇时光（其实是晚上不太想写代码），笔者今天想和大家简单讨论一下，数据库和缓存的数据一致性问题，以及如何避免or解决数据库和缓存的数据不一致的问题。</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="缓存技术" scheme="https://yonagi04.github.io/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
    <category term="技术" scheme="https://yonagi04.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="https://yonagi04.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>找到了就业的极佳选择</title>
    <link href="https://yonagi04.github.io/posts/2024/54280fcc9a6e/"/>
    <id>https://yonagi04.github.io/posts/2024/54280fcc9a6e/</id>
    <published>2024-08-26T21:35:46.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>那就是去麦当劳做汉堡</p><blockquote class="tiktok-embed" cite="https://www.tiktok.com/@zerkos16/video/7401869137833708832" data-video-id="7401869137833708832" style="max-width: 605px;min-width: 325px;" > <section> <a target="_blank" title="@zerkos16" href="https://www.tiktok.com/@zerkos16?refer=embed">@zerkos16</a> <a title="mcdonalds" target="_blank" href="https://www.tiktok.com/tag/mcdonalds?refer=embed">#mcdonalds</a>: viande10-1 cuisson🥩<a title="tiktok" target="_blank" href="https://www.tiktok.com/tag/tiktok?refer=embed">#tiktok</a><a title="fyp" target="_blank" href="https://www.tiktok.com/tag/fyp?refer=embed">#fyp</a> <a target="_blank" title="♬ Storytelling - Adriel" href="https://www.tiktok.com/music/Storytelling-7031101555747080194?refer=embed">♬ Storytelling - Adriel</a> </section> </blockquote> <script async src="https://www.tiktok.com/embed.js"></script><p>（需要打开vpn后才能观看）</p><hr><p>今天面了腾讯ieg，感觉自己确实应该不太适合写代码，更适合去麦当劳烤汉堡肉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;那就是去麦当劳做汉堡&lt;/p&gt;
&lt;blockquote class=&quot;tiktok-embed&quot; cite=&quot;https://www.tiktok.com/@zerkos16/video/7401869137833708832&quot; data-video-id=&quot;74018691</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简谈设计模式之责任链模式</title>
    <link href="https://yonagi04.github.io/posts/2024/1751e68ae53a/"/>
    <id>https://yonagi04.github.io/posts/2024/1751e68ae53a/</id>
    <published>2024-08-14T22:01:25.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>责任链模式, 又称职责链模式, 为了避免将请求发送者和多个请求处理者耦合在一起, 将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链, 当有请求发送时, 可将请求沿着这条链传递, 直到有对象处理它为止</p><h2 id="责任链模式结构">责任链模式结构</h2><ul><li><strong>抽象处理者</strong>: 定义一个处理请求的接口, 包含一个抽象处理方法和一个后继连接</li><li><strong>具体处理者</strong>: 实现抽象处理者的处理方法, 判断是否能够处理本次请求, 如果可以处理请求则处理, 否则将该请求转发给它的后继者</li><li><strong>客户类</strong>: 创建处理链, 并向链头的的处理者提交请求, 不关心处理细节和请求的传递过程</li></ul><h2 id="责任链模式实现">责任链模式实现</h2><p>假设现在有以下场景, 现在需要开发一个请假系统, 请一天的假需要组长同意, 1~3天的假需要部门经理同意, 3~7天的假需要总经理同意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeaveRequest</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleLeaveRequest(leave);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.nextHandler != <span class="literal">null</span> &amp;&amp; leave.getNum() &gt; <span class="built_in">this</span>.numEnd) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nextHandler.submit(leave);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">0</span>, Handler.NUM_ONE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum + <span class="string">&quot;天, &quot;</span> + leave.getContent());</span><br><span class="line">        System.out.println(<span class="string">&quot;组长审批: 同意&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum + <span class="string">&quot;天, &quot;</span> + leave.getContent());</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批: 同意&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum + <span class="string">&quot;天, &quot;</span> + leave.getContent());</span><br><span class="line">        System.out.println(<span class="string">&quot;经理审批: 同意&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line">        </span><br><span class="line">        groupLeader.setNextHandler(manager);</span><br><span class="line">        manager.setNextHandler(generalManager);</span><br><span class="line">        </span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>降低了对象之间的耦合度</li><li>增强了系统的可扩展性</li><li>增强了给对象指派职责的灵活性</li><li>责任链简化了对象之间的连接</li><li>责任分担</li></ul><p><strong>缺点</strong>:</p><ul><li>不能保证每个请求都被处理</li><li>对比较长的职责链, 请求的处理可能涉及到多个处理对象, 系统性能会受到影响</li><li>职责链建立的合理性要靠客户端来保证, 增加了客户端的复杂性, 可能会因为职责链的错误设置而导致系统出错, 如可能会造成循环调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;责任链模式, 又称职责链模式, 为了避免将请求发送者和多个请求处理者耦合在一起, 将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链, 当有请求发送时, 可将请求沿着这条链传递, 直到有对象处理它为止&lt;/p&gt;
&lt;h2 id=&quot;责任链模式结构&quot;&gt;责任链模式结构&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面对Yonagi&#39;s Sekai被墙，我的一点应对措施</title>
    <link href="https://yonagi04.github.io/posts/2024/6f78fccf1d78/"/>
    <id>https://yonagi04.github.io/posts/2024/6f78fccf1d78/</id>
    <published>2024-08-10T14:19:24.000Z</published>
    <updated>2025-05-18T09:07:25.415Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上，试着用手机访问了一下本站，发现不开梯子已经访问不上了，我大概意识到，可能是我的网站被伟大的GFW给ban掉了。我的运营商是中国移动，目前来看是无法直接访问的，必须得用一些科技，这可能是运营商对Github旗下的一系列域名进行了DNS污染所致（当然，即使同样用的移动网，不同地方的访问情况应该也有差别，但总体上大差不差）</p><p>本站的主站和镜像站，用站长之家测速工具测速结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.21/img/content/yonagiMainStation.webp" alt="主站的测速结果"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.21/img/content/yonagiMirrorStation.webp" alt="镜像站测速结果"></p><p>综上，我强烈建议访客都访问镜像站……主站是托管在Github的，能否访问很大程度上受当地运营商是否对Github域名进行了DNS污染，而镜像站是托管在Netlify上面的，就目前来看，Netlify的访问速度还是要比Github的要快一点的。</p><p>如果访客有VPN的话，我强烈建议开了VPN再来访问，速度会比不开VPN要好很多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上，试着用手机访问了一下本站，发现不开梯子已经访问不上了，我大概意识到，可能是我的网站被伟大的GFW给ban掉了。我的运营商是中国移动，目前来看是无法直接访问的，必须得用一些科技，这可能是运营商对Github旗下的一系列域名进行了DNS污染所致（当然，即使同样用的移动</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之命令模式</title>
    <link href="https://yonagi04.github.io/posts/2024/653b3a7ab71d/"/>
    <id>https://yonagi04.github.io/posts/2024/653b3a7ab71d/</id>
    <published>2024-08-09T21:39:49.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式将一个请求封装为一个对象, 使得发出请求的责任和执行请求的责任分隔开, 这样两者之间通过命令对象进行沟通, 这样方便将命令对象进行存储, 传递, 调用, 增加与管理</p><h2 id="命令模式结构">命令模式结构</h2><ul><li><strong>抽象命令类</strong>: 定义命令的接口, 声明执行命令的方法</li><li><strong>具体命令类</strong>: 具体命令, 实现命令接口; 通常会持有接收者, 并调用接收者的功能来完成命令要执行的操作</li><li><strong>实现者</strong>: 接收者, 真正执行命令的对象. 任何类都可以成为一个接收者, 只要它能够实现命令要求实现的功能</li><li><strong>请求者</strong>: 要求命令对象执行请求, 通常持有命令对象. 它是使用命令对象的入口</li></ul><h2 id="命令模式实现">命令模式实现</h2><p>我们假设有一家餐厅, 客户需要向服务员点单, 服务员再把点单信息提交给厨师.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tableNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDir = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTableNum</span><span class="params">(<span class="type">int</span> tableNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tableNum = tableNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDir</span><span class="params">(String food, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDir.put(food, num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTableNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tableNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDir</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厨师类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Chef makes&quot;</span> + num + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">// 持有接收者对象</span></span><br><span class="line">    <span class="keyword">private</span> Chef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(Chef chef, Order order)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chef = chef;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; foodDir = order.getFoodDir();</span><br><span class="line">        Set&lt;String&gt; keys = foodDir.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String foodName : keys) &#123;</span><br><span class="line">            receiver.makeFood(foodName, foodDir.get(foodName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line">    <span class="comment">// 持有多个命令对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span> &#123;</span><br><span class="line">        command.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command != <span class="literal">null</span>) &#123;</span><br><span class="line">                command.excute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setTableNum(<span class="number">1</span>);</span><br><span class="line">        order1.setFoodDir(<span class="string">&quot;Cola&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setTableNum(<span class="number">2</span>);</span><br><span class="line">        order2.setFoodDir(<span class="string">&quot;Fenta&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Chef</span> <span class="variable">chef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chef</span>();</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(chef, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(chef, order2);</span><br><span class="line">    </span><br><span class="line">        <span class="type">Waiter</span> <span class="variable">waiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waiter</span>();</span><br><span class="line">        waiter.setCommand(cmd1);</span><br><span class="line">        waiter.setCommand(cmd2);</span><br><span class="line">        <span class="comment">// 发起命令</span></span><br><span class="line">        waiter.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>降低系统的耦合度, 命令模式能将调用操作的对象和执行操作的对象相互解耦</li><li>增加或删除命令非常方便</li><li>可以实现宏指令, 命令模式能和组合模式相结合, 将多个命令装配成一个命令, 即宏指令</li><li>方便实现 undo 和 redo 操作</li></ul><p><strong>缺点</strong>:</p><ul><li>使用命令模式会导致系统有过多的实现类</li><li>系统复杂度提高</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;命令模式将一个请求封装为一个对象, 使得发出请求的责任和执行请求的责任分隔开, 这样两者之间通过命令对象进行沟通, 这样方便将命令对象进行存储, 传递, 调用, 增加与管理&lt;/p&gt;
&lt;h2 id=&quot;命令模式结构&quot;&gt;命令模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之策略模式</title>
    <link href="https://yonagi04.github.io/posts/2024/d04ec8bdb432/"/>
    <id>https://yonagi04.github.io/posts/2024/d04ec8bdb432/</id>
    <published>2024-08-08T20:30:37.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式定义了一系列算法, 并将每个算法封装起来, 使它们可以相互替换, 算法的变化不会影响到使用算法的用户.</p><h2 id="策略模式结构">策略模式结构</h2><ul><li><strong>抽象策略类</strong>: 定义所有支持的算法的公共接口</li><li><strong>具体策略类</strong>: 实现策略接口的具体算法</li><li><strong>上下文类</strong>: 持有一个策略类的引用, 通过策略接口调用具体策略类的方法</li></ul><h2 id="策略模式实现">策略模式实现</h2><p>假设一家商店在不同的节日推出不同的促销活动, 由推销员将活动展示给客户.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满100减20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyA</span>();</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategyB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyB</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(strategyA);</span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line">        System.out.println();</span><br><span class="line">        salesMan.setStrategy(strategyB);</span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>策略类之间可以自由切换. 因为策略类都实现了一个接口, 所以他们可以自由切换</li><li>易于拓展. 增加新的策略只需要添加一个具体的策略类, 基本不需要改变原有的代码</li><li>避免使用了多重条件选择语句, 充分体现了面向对象思想</li></ul><p><strong>缺点</strong>:</p><ul><li>客户端必须知道所有的策略类, 并自行决定使用所有的策略类</li><li>策略模式会产生很多策略类, 可以通过享元模式在一定程度上减少对象的数量</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;策略模式定义了一系列算法, 并将每个算法封装起来, 使它们可以相互替换, 算法的变化不会影响到使用算法的用户.&lt;/p&gt;
&lt;h2 id=&quot;策略模式结构&quot;&gt;策略模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象策略类&lt;/strong&gt;: 定义所有支持的算法的公共接口&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之模板方法模式</title>
    <link href="https://yonagi04.github.io/posts/2024/d5d4bc1bfbf5/"/>
    <id>https://yonagi04.github.io/posts/2024/d5d4bc1bfbf5/</id>
    <published>2024-08-08T20:27:56.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>模板方法模式定义了一个算法的骨架, 并允许子类在不改变算法结构的情况下重新定义算法的某些步骤. 通过这种方式, 实现了代码的复用与拓展</p><h2 id="模板方法模式结构">模板方法模式结构</h2><ul><li><strong>抽象类</strong>: 定义了算法的骨架, 包含一个模板方法. 这个模板方法定义了算法的步骤, 并且某些步骤可以调用抽象方法或钩子方法, 允许子类自行实现</li><li><strong>具体类</strong>: 继承自抽象类, 实现抽象方法或钩子方法, 以完成算法的具体步骤</li></ul><h2 id="模板方法模式实现">模板方法模式实现</h2><p>以下是一个简单的模板方法模式实现. 我们以制作咖啡和茶为例, 以饮料类作为抽象类, 而咖啡和茶作为具体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法, 定义了算法步骤</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">perpareBeverage</span><span class="params">()</span> &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (customerWantCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customerWantCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Steeping the tea.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding lemon.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dripping coffee through filter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding Sugar and milk.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">customerWantCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        tea.prepareBeverage();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">        coffee.prepareBeverage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>提高代码复用性: 将相同部分代码放在父类, 不同代码放入不同子类</li><li>实现反转控制: 通过一个父类调用子类的操作, 通过对子类的具体实现拓展不同的行为, 实现了反向控制, 符合开闭原则</li></ul><p><strong>缺点</strong>:</p><ul><li>对每个不同的实现都要实现一个子类, 会使得类个数增加</li><li>父类中的抽象方法由子类实现, 子类执行的结果会影响父类的结果, 这导致一种反向的控制结构, 提高了代码阅读难度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;模板方法模式定义了一个算法的骨架, 并允许子类在不改变算法结构的情况下重新定义算法的某些步骤. 通过这种方式, 实现了代码的复用与拓展&lt;/p&gt;
&lt;h2 id=&quot;模板方法模式结构&quot;&gt;模板方法模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象类&lt;/strong&gt;: 定义</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>客户端秘因</title>
    <link href="https://yonagi04.github.io/posts/2024/f3f7b2c90e6a/"/>
    <id>https://yonagi04.github.io/posts/2024/f3f7b2c90e6a/</id>
    <published>2024-07-31T20:16:51.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有后选后，无后选前，无后无前，算法也甜，条件允许，无脑后端，前途无量，预定高管，其次前端，需求频繁，温饱有余，人上人难，算法数据，收入可观，最好硕博，高端饭碗，测试开发，也可一战，随手一点，月入过万，走投无路，回家种田，日出日落，生活美满，鬼迷心窍，来客户端，表面繁荣，实则内卷，工作清闲，面试火箭，不到三年，全部玩完，65在后，绿帽在前，苦口婆心，金玉良言，奉劝诸位，擦亮双眼，有则改之，无则加勉。</p><p>—— 牛客用户 客户端劝退第一人</p></blockquote><p>我为什么突然想要难得再写一次生活类的blog，主要还是因为今天发生的一点事。前段时间boss上面海投，大小厂都投了一轮，也有一些公司找我要了简历，包括大厂。今天字节跳动的HR小姐姐打电话过来了，说我的简历初审通过，可以进入流程，邀请我参加面试，岗位是抖音直播的客户端开发。我自己确实不怎么懂客户端这块领域，遂表达歉意之后婉拒了面试。今天吃完晚饭，闲的没事刷牛客，就刷到了牛客用户“客户端劝退第二人”的一篇推文了，光看用户名就知道是劝退客户端的，但因为今天正好接到了字节的客户端开发的面试邀约，所以还是点开看了下。大意就是客户端属于是校招容易社招难，前端后端都能晋升往上爬了，客户端的还在加班切图画ui。再刷一刷，就刷到了本文开头的这段话</p><p>然后下面有一句评论，“脉脉 ‘客三消’ 的风还是吹到了牛客”（虽然我感觉牛客和脉脉的差别真不大。脉脉就是社畜们的牛客，牛客就是学生们的脉脉）</p><hr><p>我大一时候确实对安卓客户端开发很感兴趣——以至于我装了Android Studio，试图尝试开发自己的App，包括大一下学期选通识选修课，我也选的是安卓开发（虽然这个开发最多就算个低代码开发），不过后来还是选择走了Java后端开发这条路子。推文的评论区有一个观点我甚是认同，大致是这样的：这几年诞生的新App有几个？大厂还在开发新App吗？现存的这些App，大厂主要是对它修修补补，还是增加一些新功能？（我认同这个观点的最大原因是因为百度贴吧的安卓客户端一直都有bug，而且好像一直都没修过）</p><blockquote><p>如果可以，不要选客户端，付出多，回报小，有时候不是你不努力，不是你不优秀，你做错的，只是选错了方向而已。再努力的人，再聪明的人，在一个船底破了的船上，最后也是同样的结局。</p></blockquote><p>令人感慨，也许这就是选择吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有后选后，无后选前，无后无前，算法也甜，条件允许，无脑后端，前途无量，预定高管，其次前端，需求频繁，温饱有余，人上人难，算法数据，收入可观，最好硕博，高端饭碗，测试开发，也可一战，随手一点，月入过万，走投无路，回家种田，日出日落，生活美满，鬼迷心窍</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
    <category term="闲聊" scheme="https://yonagi04.github.io/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>Java最强本地缓存——Caffeine</title>
    <link href="https://yonagi04.github.io/posts/2024/117a0a91f111/"/>
    <id>https://yonagi04.github.io/posts/2024/117a0a91f111/</id>
    <published>2024-07-25T09:47:32.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p>缓存（Cache）在计算机中无处不在。缓存本质上是一种用空间换时间的手段——通过将数据存储在更快的存储媒介上，减少响应的时间，使得下一次访问这些数据的时候能够获得加速的效果。从缓存类型来看，缓存还分为 <strong>本地缓存</strong> 和 <strong>分布式缓存</strong> 两种类型。分布式缓存（如 Redis 集群）除了要解决数据读取效率问题外，还要解决集群环境下的数据不一致问题。本文将简单地介绍一种高性能的本地缓存库——Caffeine，以及Caffeine 的使用、驱逐策略、刷新策略，以及如何在 SpringBoot 中使用 Caffeine</p><h2 id="Caffeine-简介">Caffeine 简介</h2><p><a href="https://github.com/ben-manes/caffeine">Caffeine</a> 是基于Java 1.8的高性能本地缓存库，由 Guava 演变而来，它的性能比Guava也更好，官方声称在基准测试中， <a href="https://github.com/ben-manes/caffeine/wiki/Benchmarks">Caffeine 的缓存命中率已经接近于最优值</a>，且 <a href="https://github.com/ben-manes/caffeine/wiki/Memory-overhead">Caffeine 的内存占用情况也优于 Guava</a></p><p>实际上，Caffeine 这种本地缓存和 ConcurrentHashMap 很像——都支持并发，都支持 O(1) 时间复杂度的存取。两者的主要区别在于：</p><ul><li>ConcurrentHashMap 会存储所有存入的数据，且数据移除需要进行显式的操作</li><li>Caffeine 将通过给定的配置，自动移除不常用的数据，节约内存空间</li></ul><p>因此，我们可以粗略地将Caffeine视为带有淘汰策略的ConcurrentHashMap</p><p>根据 Caffeine 官方提供的文档，Caffeine提供的功能如下：</p><ul><li><a href="https://github.com/ben-manes/caffeine/wiki/Population-zh-CN">自动加载</a>元素到缓存当中，异步加载的方式也可供选择</li><li>当达到最大容量的时候可以使用基于<a href="https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN">就近度和频率</a>的算法进行<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%AE%B9%E9%87%8F">基于容量的驱逐</a></li><li>将根据缓存中的元素上一次访问或者被修改的时间进行<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4">基于过期时间的驱逐</a></li><li>当向缓存中一个已经过时的元素进行访问的时候将会进行<a href="https://github.com/ben-manes/caffeine/wiki/Refresh-zh-CN">异步刷新</a></li><li>key将自动被<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8">弱引用</a>所封装</li><li>value将自动被<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8">弱引用或者软引用</a>所封装</li><li>驱逐(或移除)缓存中的元素时将会进行<a href="https://github.com/ben-manes/caffeine/wiki/Removal-zh-CN">通知</a></li><li><a href="https://github.com/ben-manes/caffeine/wiki/Writer-zh-CN">写入传播</a>到一个外部数据源当中</li><li>持续计算缓存的访问<a href="https://github.com/ben-manes/caffeine/wiki/Statistics-zh-CN">统计指标</a></li></ul><h2 id="在-Java-中使用-Caffeine">在 Java 中使用 Caffeine</h2><p>为了使用 Caffeine，在 Maven 工程下引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Caffeine 提供了四种缓存添加策略：手动加载，自动加载，手动异步加载和自动异步加载</p><h3 id="手动加载">手动加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找一个缓存元素， 没有查找到的时候返回null</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> cache.getIfPresent(key);</span><br><span class="line"><span class="comment">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span><br><span class="line">graph = cache.get(key, k -&gt; createExpensiveGraph(key));</span><br><span class="line"><span class="comment">// 添加或者更新一个缓存元素</span></span><br><span class="line">cache.put(key, graph);</span><br><span class="line"><span class="comment">// 移除一个缓存元素</span></span><br><span class="line">cache.invalidate(key);</span><br></pre></td></tr></table></figure><p>Cache 接口提供了显式搜索查找、更新和移除缓存元素的能力</p><p><code>cache.put(key, value)</code> 操作将会直接写入或更新缓存中的缓存元素，在缓存中已经存在的该 key 对应的缓存值都会被直接覆盖</p><p><code>cache.get(key, k -&gt; value)</code> 操作来在缓存中不存在该key对应的缓存元素的时候进行计算生成并直接写入至缓存内，而当该key对应的缓存元素存在的时候将会直接返回存在的缓存值。如果缓存的元素无法生成或在生成的过程中抛出了异常导致生成失败，<code>cache.get</code> 可能会返回null</p><p>通过调用 <code>cache.invalidate(key)</code> 方法来移除缓存</p><h3 id="自动加载">自动加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build(key -&gt; createExpensiveGraph(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"><span class="comment">// 批量查找缓存，如果缓存不存在则生成缓存元素</span></span><br><span class="line">Map&lt;Key, Graph&gt; graphs = cache.getAll(keys);</span><br></pre></td></tr></table></figure><p><code>LoadingCache</code> 是一个 <code>Cache</code> 附加上 <code>CacheLoader</code> 能力后的缓存实现</p><p>当缓存不存在时，如果调用了<code>get()</code>方法，则会调用<code>CacheLoader.load()</code>方法加载最新值。通过 <code>getAll()</code> 可以达到批量查找缓存的目的。通常情况下，<code>getAll()</code> 方法会对每个不存在对应缓存的key调用一次 <code>CacheLoader.load()</code> 来生成缓存元素</p><p>使用 <code>LoadingCache</code> 时，需要指定 <code>CacheLoader</code> ，并实现其中的 <code>load()</code> 方法供缓存缺失时的自动加载</p><h3 id="手动异步加载">手动异步加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AsyncCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .buildAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找一个缓存元素， 没有查找到的时候返回null</span></span><br><span class="line">CompletableFuture&lt;Graph&gt; graph = cache.getIfPresent(key);</span><br><span class="line"><span class="comment">// 查找缓存元素，如果不存在，则异步生成</span></span><br><span class="line">graph = cache.get(key, k -&gt; createExpensiveGraph(key));</span><br><span class="line"><span class="comment">// 添加或者更新一个缓存元素</span></span><br><span class="line">cache.put(key, graph);</span><br><span class="line"><span class="comment">// 移除一个缓存元素</span></span><br><span class="line">cache.synchronous().invalidate(key);</span><br></pre></td></tr></table></figure><p><code>AsyncCache</code> 是 <code>Cache</code> 的一个变体，响应结果均为 <code>CompletableFuture</code>。默认情况下，缓存计算使用 <code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，可以覆盖并实现 <code>Caffeine.executor(Executor)</code> 方法</p><p><code>synchronous()</code> 提供了阻塞直到异步缓存生成完毕的能力，它将以 Cache 进行返回</p><h3 id="自动异步加载">自动异步加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AsyncLoadingCache&lt;Key, Graph&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    <span class="comment">// 你可以选择: 去异步的封装一段同步操作来生成缓存元素</span></span><br><span class="line">    .buildAsync(key -&gt; createExpensiveGraph(key));</span><br><span class="line">    <span class="comment">// 你也可以选择: 构建一个异步缓存元素操作并返回一个future</span></span><br><span class="line">    .buildAsync((key, executor) -&gt; createExpensiveGraphAsync(key, executor));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class="line">CompletableFuture&lt;Graph&gt; graph = cache.get(key);</span><br><span class="line"><span class="comment">// 批量查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class="line">CompletableFuture&lt;Map&lt;Key, Graph&gt;&gt; graphs = cache.getAll(keys);</span><br></pre></td></tr></table></figure><p>一个 <code>AsyncLoadingCache</code> 是一个 <code>AsyncCache</code> 加上 <code>AsyncCacheLoader</code> 能力的实现</p><p>与自动加载 <code>LoadingCache</code> 类似，<code>AsyncLoadingCache</code> 也需要指定 <code>CacheLoader</code> ，同时需要实现 <code>load()</code> 方法供供缓存缺失时的自动加载。</p><p>默认以 <code>ForkJoinPool.commonPool()</code>作为线程池来提交，如果想要指定线程池，可以覆盖并实现 <code>AsyncCacheLoader.aysncLoad()</code> 方法</p><h3 id="驱逐策略">驱逐策略</h3><p>驱逐策略在创建缓存的时候进行指定。常用的有基于容量的驱逐和基于时间的驱逐。基于容量的驱逐需要指定缓存容量的最大值。当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。</p><p>驱逐策略可以自由组合，在任意驱逐策略生效后，该缓存将会被清除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建最大容量为1000的缓存</span></span><br><span class="line">Caffeine.newBuilder().maximumSize(<span class="number">1000</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个写入10h后过期的缓存</span></span><br><span class="line">Caffeine.newBuilder().expireAfterWrite(<span class="number">10</span>, TimeUnit.HOURS).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个访问1h后过期的缓存</span></span><br><span class="line">Caffeine.newBuilder().expireAfterAccess(<span class="number">1</span>, TimeUnit.HOURS).build();</span><br></pre></td></tr></table></figure><h3 id="刷新机制">刷新机制</h3><p>刷新机制与驱逐完全不同，它可以通过 <code>LoadingCache.refresh(K)</code> 方法，异步地为 key 对应的缓存元素刷新一个新的值。与驱逐不同的是，在刷新时候如果查询缓存元素，其旧值将会被返回，知道元素刷新完毕后才能返回刷新后的新值</p><p>使用 <code>refreshAfterWrite()</code> 机制，Caffeine将在 key 允许刷新后的首次访问时，立即返回旧值，同时异步地对缓存值进行刷新，使得调用方不至于因为缓存驱逐而被阻塞。刷新机制只能适用于自动加载和自动异步加载</p><p>通过覆写 <code>Cache.reload()</code> 方法，将在刷新时使得旧缓存值参与其中</p><p>刷新操作将会异步执行在一个 <code>Executor</code> 上，默认的线程池实现是 <code>ForkJoinPool.commonPool()</code> ，也可以通过覆盖 <code>Caffeine.executor(Executor)</code> 方法自定义线程池的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caffeine.newBuilder().refreshAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES).build(k -&gt; create(k));</span><br></pre></td></tr></table></figure><h3 id="统计">统计</h3><p>Caffeine 内置了数据收集功能，通过 <code>Caffeine.recordStats()</code> 方法可以打开数据收集功能。<code>Cache.stats()</code> 方法将会返回一个 <code>CacheStats</code> 对象，将会包含一些统计指标，例如</p><ul><li><code>hitRate()</code> 缓存命中率</li><li><code>evictionCount()</code> 被驱逐的缓存数量</li><li><code>averageLoadPenalty()</code> 新值被载入的平均耗时</li></ul><h2 id="在-SpringBoot-中使用-Caffeine">在 SpringBoot 中使用 Caffeine</h2><p>除了上面提及的方法之外，在 SpringBoot框架中，我们有一些更加方便的配置方法和管理功能</p><h3 id="SpringBoot-缓存管理器">SpringBoot 缓存管理器</h3><p>Spring从3.1版本开始就引入了对 Cache 的支持。定义了 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口，来统一不同的缓存技术，支持使用 <code>JCache(JSR-107)</code> 注解来简化开发</p><ul><li>Cache 接口包括了对缓存的各种操作集合，实际操作缓存时，是通过这些接口进行操作</li><li>Cache 接口下提供了各种 xxxCache 的实现，由于 Spring 从2.0版本后把默认的缓存组件由 Guava 替换为 Caffeine，因此这里需要用到的就是 <code>CaffeineCache</code> 类。</li><li>CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的的 Cache。这些 Cache 存在于 CacheManager 的上下文中</li></ul><p>创建缓存管理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCacheManager</span>();</span><br><span class="line">    ArrayList&lt;CaffeineCache&gt; caches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    caches.add(<span class="keyword">new</span> <span class="title class_">CaffeineCache</span>(cacheName(), generateCache()));</span><br><span class="line">    cacheManager.setCaches(caches);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，Spring 只支持手动加载和自动加载缓存，无法支持异步缓存</p><h3 id="使用-Cacheable-注解">使用 @Cacheable 注解</h3><p>为了使用 @Cacheable 注解，需要引入 Maven 依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与 @Cacheable 相关的常用注解包括：</p><ul><li>@Cachable：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而是从缓存中直接返回。</li><li>@CachePut：表示执行该方法后，其值将作为最新结果更新到缓存中</li><li>@CacheEvict：表示执行该方法后，将执行缓存清除操作</li><li>@Caching：组合前三个注解</li></ul><h3 id="常用注解属性">常用注解属性</h3><p>@Cacheable 常用的注解属性如下：</p><ul><li><code>cacheNames/value</code>：缓存组件的名字，即 cacheManager 中缓存的名称</li><li><code>key</code>：缓存数据时使用的 key</li><li><code>keyGenerator</code>：key 和 keyGenerator 二选一</li><li><code>cacheManager</code>：指定使用的缓存管理器</li><li><code>condition</code>：在方法执行开始前检查，在符合 condition 的情况下，进行缓存</li><li><code>unless</code>：在方法执行完成后检查，在符合 unless 的情况下，进行缓存</li><li><code>sync</code>：是否进行同步模式，若使用同步模式，在多个线程同时对一个 key 进行 load 时，其他线程将被阻塞</li></ul><h3 id="缓存同步模式">缓存同步模式</h3><p>@Cacheable 注解支持配置同步模式，在不同的 Caffeine 配置下，对是否开启同步模式进行观察</p><table><thead><tr><th>Caffeine缓存类型</th><th>是否开启同步</th><th>多线程读取不存在/被驱逐的 key</th><th>多线程读取待刷新的 key</th></tr></thead><tbody><tr><td>Cache</td><td>否</td><td>各自独立执行被注解方法</td><td>-</td></tr><tr><td>Cache</td><td>是</td><td>线程1执行被注解方法，线程2阻塞，直到缓存更新完成</td><td>-</td></tr><tr><td>LoadingCache</td><td>否</td><td>线程1执行 <code>load()</code>，线程2被阻塞，直到缓存更新完成</td><td>线程1使用旧值立即返回，并异步更新缓存值；线程2立即返回，不进行更新</td></tr><tr><td>LoadingCache</td><td>是</td><td>线程1执行被注解方法，线程2阻塞，直到缓存更新完成</td><td>线程1使用旧值立即返回，并异步更新缓存值；线程2立即返回，不进行更新</td></tr></tbody></table><ul><li>在 Cache 中，sync 表示是否需要所有线程同步等待</li><li>在 LoadingCache 中，sync 表示在读取不存在/被驱逐的 key 时，是否执行被注解方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;缓存（Cache）在计算机中无处不在。缓存本质上是一种用空间换时间的手段——通过将数据存储在更快的存储媒介上，减少响应的时间，使得下一次访问这些数据的时候能够获得加速的效果。从缓存类型来看，缓存还分为 &lt;strong&gt;本地缓存&lt;/strong&gt; 和 &lt;strong&gt;分布式缓</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="后端技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Caffeine" scheme="https://yonagi04.github.io/tags/Caffeine/"/>
    
    <category term="缓存技术" scheme="https://yonagi04.github.io/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之享元模式</title>
    <link href="https://yonagi04.github.io/posts/2024/ec54d0d33ec7/"/>
    <id>https://yonagi04.github.io/posts/2024/ec54d0d33ec7/</id>
    <published>2024-07-18T15:43:21.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式通过共享相似或相同的对象来减少内存使用和提高性能. 核心思想是把对象的状态分为内部状态和外部状态, 其中内部状态可以共享, 外部状态则由客户端来负责. 通过共享内部状态可以减少需要创建的对象数量, 从而节约内存</p><h2 id="享元模式结构">享元模式结构</h2><ul><li><strong>享元接口</strong>: 定义对象的接口, 通过这个接口, 享元可以接收并作用于外部状态</li><li><strong>具体享元类</strong>: 实现享元接口, 并存储可以共享的内部状态</li><li><strong>非共享享元类</strong>: 不需要共享的享元接口子类. 因为享元接口共享了具体的享元对象, 因此可以不需要</li><li><strong>享元工厂</strong>: 用于管理和创建享元对象</li></ul><h2 id="享元模式实现">享元模式实现</h2><p>假设我们有一个需要绘制许多字符的文本编辑器, 每个字符都有特定的样式（例如字体、大小、颜色等）. 如果为每个字符都创建一个对象, 这将导致大量的内存消耗. 我们可以使用享元模式来共享相同样式的字符对象, 从而减少内存使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> <span class="keyword">implements</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> symbol;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCharacter</span><span class="params">(<span class="type">char</span> symbol)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Character: &quot;</span> + symbol + <span class="string">&quot; at (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Character&gt; characters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Character <span class="title function_">getCharacter</span><span class="params">(<span class="type">char</span> symbol)</span> &#123;</span><br><span class="line">        <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> characters.get(symbol);</span><br><span class="line">        <span class="keyword">if</span> (character == <span class="literal">null</span>) &#123;</span><br><span class="line">            character = <span class="keyword">new</span> <span class="title class_">ConcreteCharacter</span>(symbol);</span><br><span class="line">            characters.put(symbol, character);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CharacterFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">document</span> <span class="operator">=</span> <span class="string">&quot;AABBCC&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : document.toCharArray()) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> factory.getCharacter(c);</span><br><span class="line">            character.display(x, y);</span><br><span class="line">            x += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>减少内存使用</strong>. 通过共享相同或相似的对象, 可以减少内存消耗</li><li><strong>提高系统性能</strong>: 减少了对象的创建和销毁, 提高系统性能</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>复杂性增加</strong>: 需要引入额外的代码来管理共享对象和区分内部状态和外部状态, 增加系统复杂性</li><li><strong>可能导致线程安全问题</strong>: 由于享元对象是共享的, 在多线程环境下需要考虑线程安全问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;享元模式通过共享相似或相同的对象来减少内存使用和提高性能. 核心思想是把对象的状态分为内部状态和外部状态, 其中内部状态可以共享, 外部状态则由客户端来负责. 通过共享内部状态可以减少需要创建的对象数量, 从而节约内存&lt;/p&gt;
&lt;h2 id=&quot;享元模式结构&quot;&gt;享元模式结构&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之外观模式</title>
    <link href="https://yonagi04.github.io/posts/2024/863408da8776/"/>
    <id>https://yonagi04.github.io/posts/2024/863408da8776/</id>
    <published>2024-07-18T15:43:21.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式是一种结构性设计模式, 通过为复杂的子系统提供一个统一的接口, 使得子系统更容易使用.</p><h2 id="外观模式结构">外观模式结构</h2><ul><li><strong>外观</strong>: 提供一个高层接口, 供客户使用, 它知道哪些子系统负责处理请求, 并将客户的请求委派给适当的子系统</li><li><strong>子系统类</strong>: 实现子系统的功能, 处理由外观指派的任务</li></ul><h2 id="外观模式实现">外观模式实现</h2><p>假设有一个复杂的家庭影院系统, 包括DVD, 投影仪, 音响, 灯光等系统, 可以通过外观模式来模拟这个系统的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DVDPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD Player is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String movie)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + movie);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD Player is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Projector is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Projector is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sound is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVolume</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting sound volume to &quot;</span> + level);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sound is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lights are on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dim</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dimming lights to &quot;</span> + level + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lights are off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> SoundSystem soundSystem;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">(DVDPlayer dvdPlayer, Projector projector, SoundSystem soundSystem, Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">        <span class="built_in">this</span>.projector = projector;</span><br><span class="line">        <span class="built_in">this</span>.soundSystem = soundSystem;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">(String movie)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Get ready to watch a movie...&quot;</span>);</span><br><span class="line">        light.dim(<span class="number">10</span>);</span><br><span class="line">        projector.on();</span><br><span class="line">        soundSystem.on();</span><br><span class="line">        soundSystem.setVolume(<span class="number">5</span>);</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        dvdPlayer.play(movie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down movie theater...&quot;</span>);</span><br><span class="line">        dvdPlayer.off();</span><br><span class="line">        soundSystem.off();</span><br><span class="line">        projector.off();</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DVDPlayer</span> <span class="variable">dvdPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVDPlayer</span>();</span><br><span class="line">        <span class="type">Projector</span> <span class="variable">projector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Projector</span>();</span><br><span class="line">        <span class="type">SoundSystem</span> <span class="variable">soundSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoundSystem</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">homeTheater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>(dvdPlayer, projector, soundSystem, light);</span><br><span class="line">        homeTheater.watchMovie(<span class="string">&quot;Inception&quot;</span>);</span><br><span class="line">        homeTheater.endMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>降低了子系统与客户端的耦合度, 子系统的变化不会影响客户类</li><li>对客户屏蔽了子系统组件, 减少了客户处理的对象数目, 子系统使用起来更容易</li></ul><p><strong>缺点</strong>:</p><ul><li>不符合开闭原则</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;外观模式是一种结构性设计模式, 通过为复杂的子系统提供一个统一的接口, 使得子系统更容易使用.&lt;/p&gt;
&lt;h2 id=&quot;外观模式结构&quot;&gt;外观模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;外观&lt;/strong&gt;: 提供一个高层接口, 供客户使用, 它知道哪些子系统负责</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之组合模式</title>
    <link href="https://yonagi04.github.io/posts/2024/68f210011157/"/>
    <id>https://yonagi04.github.io/posts/2024/68f210011157/</id>
    <published>2024-07-18T15:43:21.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式是一种结构型设计模式, 允许将对象组合成树形结构表示 “部分-整体” 的层次结构. 组合模式使得客户端对单个对象和组合对象的使用具有一致性</p><h4 id="组合模式结构">组合模式结构</h4><ul><li><strong>抽象组件</strong>: 定义了组合对象和叶子对象的接口, 包括添加, 删除子组件以及其他共享的行为</li><li><strong>叶子节点</strong>: 代表组合中的叶子对象, 它没有子节点, 定义了对象的基本行为</li><li><strong>组合节点</strong>: 定义有子组件的那些对象, 存储子组件, 并实现抽象组件中的相关操作</li></ul><h4 id="组合模式实现">组合模式实现</h4><p>假设要实现一个文件系统, 包括文件和目录, 目录包含文件和子目录, 可以用组合模式来实现这个系统</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象组件</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FileSystemComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String indent)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String indent)</span> &#123;</span><br><span class="line">        System.out.println(indent + <span class="string">&quot;File: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemComponent&gt; components = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Directory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        components.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileSystemComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> components.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String indent)</span> &#123;</span><br><span class="line">        System.out.println(indent + <span class="string">&quot;Directory: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (FileSystemComponent component : components) &#123;</span><br><span class="line">            component.display(indent + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileSystemComponent</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;File1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileSystemComponent</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;File2.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileSystemComponent</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;File3.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileSystemComponent</span> <span class="variable">directory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;Directory1&quot;</span>);</span><br><span class="line">        <span class="type">FileSystemComponent</span> <span class="variable">directory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;Directory2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        directory1.add(file1);</span><br><span class="line">        directory1.add(file2);</span><br><span class="line"></span><br><span class="line">        directory2.add(file3);</span><br><span class="line">        directory2.add(directory1);</span><br><span class="line"></span><br><span class="line">        directory2.display(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>清晰的层次结构</strong>. 通过组合模式可以清晰地表示对象的部分-整体层次结构</li><li><strong>一致的处理方法</strong>: 客户端可以一致地使用组合对象和叶子对象, 无需关注它们的具体类型, 有助于提高系统的灵活性</li><li><strong>简化客户端代码</strong>: 客户端可以统一处理组合对象和叶子对象, 减少了处理不同对象类型的复杂性</li><li><strong>容易拓展</strong>: 可以很容易地添加新的组合对象和叶子对象而不会影响现有代码</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>类数目会增加</strong></li><li><strong>子组件管理复杂</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组合模式是一种结构型设计模式, 允许将对象组合成树形结构表示 “部分-整体” 的层次结构. 组合模式使得客户端对单个对象和组合对象的使用具有一致性&lt;/p&gt;
&lt;h4 id=&quot;组合模式结构&quot;&gt;组合模式结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象组件&lt;/strong&gt;:</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之桥接模式</title>
    <link href="https://yonagi04.github.io/posts/2024/08471fe57c3b/"/>
    <id>https://yonagi04.github.io/posts/2024/08471fe57c3b/</id>
    <published>2024-07-16T19:52:43.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>桥接模式是一种结构型设计模式, 它将抽象部分和它的实现部分分离, 使它们可以独立变化. 这意味着可以改变它的抽象和它的实现, 而不会相互影响</p><h2 id="桥接模式结构">桥接模式结构</h2><ul><li><strong>抽象 (Abstraction)</strong>: 定义抽象类, 并包含一个对实现类对象的引用</li><li><strong>拓展抽象 (Refined Abstraction)</strong>: 拓展抽象类, 通过组合的方式调用实现类的方法</li><li><strong>实现 (Implementor)</strong>: 定义实现类的接口, 但不具体实现, 它仅提供一个接口, 供具体实现类进行实现</li><li><strong>具体实现 (ConcreteImplementor)</strong>: 具体实现Implementor接口</li></ul><h2 id="桥接模式实现">桥接模式实现</h2><p>假设有一个画图程序, 需要渲染不同图形, 同时还需要在不同操作系统上渲染, 可以使用桥接模式来实现这个程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Implementor</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteImplementorA</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingAPI1</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;API1.circle at &quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot; radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteImplementorB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingAPI2</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;API2.circle at &quot;</span> + x + <span class="string">&quot;:&quot;</span> + y + <span class="string">&quot; radius &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstraction</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawingAPI drawingAPI;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawingAPI = drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;                               <span class="comment">// low-level</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">resizeByPercentage</span><span class="params">(<span class="type">double</span> pct)</span>;       <span class="comment">// high-level</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefinedAbstraction</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y, radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleShape</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius, DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawingAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawingAPI.drawCircle(x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resizeByPercentage</span><span class="params">(<span class="type">double</span> pct)</span> &#123;</span><br><span class="line">        radius *= (<span class="number">1.0</span> + pct / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> <span class="title class_">Shape</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CircleShape</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">DrawingAPI1</span>()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CircleShape</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="keyword">new</span> <span class="title class_">DrawingAPI2</span>()),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.resizeByPercentage(<span class="number">2.5</span>);</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DrawingAPI</strong> 是实现接口，定义了具体的绘制操作。</p><p><strong>DrawingAPI1</strong> 和 <strong>DrawingAPI2</strong> 是具体实现类，分别实现了具体的绘制操作。</p><p><strong>Shape</strong> 是抽象类，包含一个 DrawingAPI 的引用。</p><p><strong>CircleShape</strong> 是具体的图形类，实现了具体的绘制操作，并委托给 DrawingAPI。</p><p><strong>BridgePatternDemo</strong> 是客户端代码，展示了如何使用桥接模式来绘制不同的图形。</p><p><strong>优点</strong>:</p><ul><li>分离抽象接口与实现</li><li>遵循了开闭原则</li><li>提高系统拓展性</li><li>实现细节对客户是透明的</li></ul><p><strong>缺点</strong>:</p><ul><li>增加了系统设计难度</li><li>增加了代码的难度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;桥接模式是一种结构型设计模式, 它将抽象部分和它的实现部分分离, 使它们可以独立变化. 这意味着可以改变它的抽象和它的实现, 而不会相互影响&lt;/p&gt;
&lt;h2 id=&quot;桥接模式结构&quot;&gt;桥接模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象 (Abstraction)&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之装饰者模式</title>
    <link href="https://yonagi04.github.io/posts/2024/1a6c991ad5a8/"/>
    <id>https://yonagi04.github.io/posts/2024/1a6c991ad5a8/</id>
    <published>2024-07-16T19:52:43.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式是一种结构型设计模式, 它允许在不改变对象自身的情况下动态地为对象添加行为和职责. 装饰者模式通过创建一个装饰者类来包裹原始类, 从而增强或修改其功能</p><h2 id="装饰者模式结构">装饰者模式结构</h2><ul><li><strong>组件接口</strong>: 定义了对象的公共操作的接口或抽象类, 定义了对象的公共操作</li><li><strong>具体组件</strong>: 具体的定义类, 实现组件接口</li><li><strong>装饰者</strong>: 这是抽象类, 实现组件接口, 并持有一个组件对象的引用, 它通过组合方式将客户端的请求转发给被装饰的对象, 具体的装饰者类将从这个抽象修饰者继承并拓展其功能</li><li><strong>具体装饰者</strong>: 装饰者模式的核心部分, 具体装饰者类从装饰者类继承, 并通过创建新的方法或重写组件方法来增强或改变被装饰对象的行为</li></ul><h2 id="装饰者模式实现">装饰者模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteComponent: request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ComponentDecorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    protect Component component;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComponentDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        component.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title class_">ComponentDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">       component.request();</span><br><span class="line">       System.out.println(<span class="string">&quot;ConcreteDecorator1: request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator2</span> <span class="keyword">extends</span> <span class="title class_">ComponentDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">       component.request();</span><br><span class="line">       System.out.println(<span class="string">&quot;ConcreteDecorator2: request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentDecorator</span>();</span><br><span class="line">        component.request();</span><br><span class="line">        </span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator1</span>(component);</span><br><span class="line">        component.request();</span><br><span class="line">        </span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ComcreteDecorator2</span>(component);</span><br><span class="line">        component.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>比继承更加灵活,使用也更加方便, 装饰者模式可以通过组合不同的装饰者对象获取不同行为的对象.</li><li>装饰类和被装饰类是独立的, 不会相互耦合</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;装饰者模式是一种结构型设计模式, 它允许在不改变对象自身的情况下动态地为对象添加行为和职责. 装饰者模式通过创建一个装饰者类来包裹原始类, 从而增强或修改其功能&lt;/p&gt;
&lt;h2 id=&quot;装饰者模式结构&quot;&gt;装饰者模式结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组件接口&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用Synthesizer V翻唱了一首曲子……</title>
    <link href="https://yonagi04.github.io/posts/2024/168a7a82570f/"/>
    <id>https://yonagi04.github.io/posts/2024/168a7a82570f/</id>
    <published>2024-07-14T09:41:44.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>前几天嫖了一个盗版的Synthesizer V，装了几个声库，随便扒了一首曲子来玩一玩</p><p>影片现在已经发布在Youtube和Bilibili，欢迎来捧场</p><iframe width="560" height="315" src="https://www.youtube.com/embed/_KD9tpp4qaA?si=5yf-ciNbgs70z-DH" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">     <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1756019580&bvid=BV1W4421D7sJ&cid=1614360225&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天嫖了一个盗版的Synthesizer V，装了几个声库，随便扒了一首曲子来玩一玩&lt;/p&gt;
&lt;p&gt;影片现在已经发布在Youtube和Bilibili，欢迎来捧场&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.</summary>
      
    
    
    
    <category term="音乐" scheme="https://yonagi04.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    <category term="VOCALOID" scheme="https://yonagi04.github.io/categories/%E9%9F%B3%E4%B9%90/VOCALOID/"/>
    
    
    <category term="Synthesizer V" scheme="https://yonagi04.github.io/tags/Synthesizer-V/"/>
    
    <category term="VOCALOID" scheme="https://yonagi04.github.io/tags/VOCALOID/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之适配器模式</title>
    <link href="https://yonagi04.github.io/posts/2024/9e27780ba7a0/"/>
    <id>https://yonagi04.github.io/posts/2024/9e27780ba7a0/</id>
    <published>2024-07-12T20:34:50.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式是结构型设计模式之一, 用于将一个类的接口转换成客户期望的另一个接口. 通过使用适配器模式, 原本由于接口不兼容而无法一起工作的类可以协同工作</p><p>适配器模式通常有两种实现方式</p><ol><li><strong>类适配器模式 (Class Adapter Pattern）</strong>: 使用继承来实现适配器。</li><li>**对象适配器模式 (Object Adapter Pattern) **: 使用组合来实现适配器。</li></ol><h2 id="适配器模式结构">适配器模式结构</h2><ul><li><strong>目标接口</strong>: 当前系统业务所期待的接口, 可以是抽象类也可以是接口</li><li><strong>适配者类</strong>: 它是被访问和适配的现存组件库中的组件接口</li><li><strong>适配器类</strong>: 它是一个转换器, 通过继承或引用适配者的对象, 把适配者接口转换成目标接口, 让客户按目标接口的格式访问适配者</li></ul><h2 id="适配器模式实现">适配器模式实现</h2><ol><li><strong>类适配器模式</strong></li></ol><p>类适配器模式通过继承目标接口和被适配类, 实现适配功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adaptee&#x27;s specific request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>对象适配器模式</strong></li></ol><p>对象适配器模式通过组合的方式, 将被适配者类的实例作为适配器的一个字段, 并在适配器中调用被适配者的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adaptee&#x27;s specific request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ol><li><strong>分离接口和实现</strong>: 适配器模式将客户端和被适配者类的接口分离开, 通过适配器类进行转换, 增强了代码的灵活性和可维护性</li><li><strong>复用现有类</strong>: 通过适配器模式, 可以复用现有的类, 而不需要修改其代码, 从而满足新的需求</li></ol><p><strong>缺点</strong></p><ol><li><strong>复杂性增加</strong>: 使用适配器模式会增加系统的复杂性, 尤其是需要同时适配多个类时, 可能需要大量的适配器类</li><li><strong>性能开销</strong>: 适配器模式会引入额外的接口调用开销, 可能会对性能产生一定的影响</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;适配器模式是结构型设计模式之一, 用于将一个类的接口转换成客户期望的另一个接口. 通过使用适配器模式, 原本由于接口不兼容而无法一起工作的类可以协同工作&lt;/p&gt;
&lt;p&gt;适配器模式通常有两种实现方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;类适配器模式 (Class Ada</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之代理模式</title>
    <link href="https://yonagi04.github.io/posts/2024/c0ee194e5f95/"/>
    <id>https://yonagi04.github.io/posts/2024/c0ee194e5f95/</id>
    <published>2024-07-12T20:33:07.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是一种结构型设计模式, 主要用于为其他对象提供一种代理, 以控制对这个对象的访问. 代理模式可以在不修改目标对象的前提下, 通过代理对象在访问目标对象之前或之后增加额外的操作</p><h2 id="代理模式结构">代理模式结构</h2><ol><li><strong>抽象主题</strong>: 定义了真实主题和代理的共同接口, 这样客户端就可以通过接口来使用真实主题和代理</li><li><strong>真实主题</strong>: 定义了代理所代表的真实对象, 是实际进行业务操作的对象</li><li><strong>代理</strong>: 持有对真实主题的引用, 控制对真实主题的访问, 可以在访问真实主题时增加额外的操作</li></ol><h2 id="代理模式分类">代理模式分类</h2><ol><li><strong>远程代理</strong>: 为一个位于不同地址空间的对象提供本地代表</li><li><strong>虚拟代理</strong>: 根据需要创建开销较大的对象, 通过代理来控制对象的访问和延迟初始化</li><li><strong>保护代理</strong>: 控制对原始对象的访问, 用于对象有不同访问权限的场景</li><li><strong>智能指引</strong>: 在访问实际对象时进行一些额外操作, 例如引用计数, 日志记录等</li></ol><h2 id="代理模式实现">代理模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: Handling request.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">            realRequest = <span class="keyword">new</span> <span class="title class_">RealRequest</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Pre-processing before forwarding request to RealSubject&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Post-processing after RealSubject handled request);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">                           </span></span><br><span class="line"><span class="string">// 客户端代码</span></span><br><span class="line"><span class="string">public class Client &#123;</span></span><br><span class="line"><span class="string">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">        Subject proxy = new Proxy();</span></span><br><span class="line"><span class="string">        proxy.request();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>职责清晰</strong>: 代理模式将真实对象和控制访问的代理对象分离, 使得职责更加清晰</li><li><strong>透明性</strong>: 客户端可以透明地使用代理对象而不需要知道真实对象的存在</li><li><strong>控制访问</strong>: 代理可以在不修改真实对象的情况下修改对真实对象的访问</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>增加复杂性</strong>: 由于引入了代理对象, 会增加系统的复杂性</li><li><strong>性能开销</strong>: 代理模式可能会增加系统的性能开销, 尤其是远程代理或虚拟代理, 因为它们会增加额外的网络通信或延迟</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理模式是一种结构型设计模式, 主要用于为其他对象提供一种代理, 以控制对这个对象的访问. 代理模式可以在不修改目标对象的前提下, 通过代理对象在访问目标对象之前或之后增加额外的操作&lt;/p&gt;
&lt;h2 id=&quot;代理模式结构&quot;&gt;代理模式结构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>美团2023年秋招第一场笔试 个人题解</title>
    <link href="https://yonagi04.github.io/posts/2024/468fdcc71996/"/>
    <id>https://yonagi04.github.io/posts/2024/468fdcc71996/</id>
    <published>2024-07-10T20:58:59.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下题解为个人题解，仅提供大致思路和提供题解代码。本题解使用的编程语言为C++。本次笔试为模拟测试，得分70.5/100，ac数7/9。题解内容仅供参考</strong></p><h1>美团2023年秋季校园招聘 第一场笔试【技术类】 题解（C++）</h1><h2 id="T1-小美的外卖订单">T1. 小美的外卖订单</h2><p>小美正在设计美团外卖的定价信息。已知外卖定价的规则如下：</p><ol><li><p>每道菜有折扣价和原价。折扣价不能超过原价。</p></li><li><p>订单有满 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑥</mi></mrow><annotation encoding="application/x-tex">𝑥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 元减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑦</mi></mrow><annotation encoding="application/x-tex">𝑦</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 元的优惠。当购买的菜的价格总和不小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑥</mi></mrow><annotation encoding="application/x-tex">𝑥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 元时，总价格可以减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑦</mi></mrow><annotation encoding="application/x-tex">𝑦</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 元。“减”的价格不能超过“满”的价格。</p></li><li><p>满减优惠和折扣价是互斥的，当且仅当每个菜都选择了原价才可以触发满减。</p></li><li><p>系统会自动为客户计算最低价格的方案。</p></li></ol><p>在设计定价时，原价、折扣价和满减的价格都必须是正实数。如果设计的定价发生问题，则会提示数据错误。</p><p>请使用等价划分法设计测试用例，来测试该系统的功能。</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个正整数n，代表菜的总数。</span><br><span class="line">接下来的n行，每行输入两个实数ai和bi，代表每道菜的原价是ai，折扣价是bi。</span><br><span class="line">最后一行输入两个实数x和y，代表满元可以减元。</span><br><span class="line">1 &lt;= n &lt;= 1e5</span><br><span class="line">数据中所有实数的绝对值不超过1000。</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果数据有误，则输出一行字符串&quot;error&quot;。</span><br><span class="line">否则输出一个小数，小数点后保留2位即可。该小数代表顾客购买了全部菜各一份时，订单的总价格。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">2</span><br><span class="line">10 5.5</span><br><span class="line">10 6.5</span><br><span class="line">15 3</span><br><span class="line">输出例子：</span><br><span class="line">12.00</span><br><span class="line">例子说明：</span><br><span class="line">虽然触发了满15元减3元，但使用折扣只需要花12元，低于使用满减的价格（20-3=17），因此最终系统会为客户推荐折扣价。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">2</span><br><span class="line">10 5.5</span><br><span class="line">10 6.5</span><br><span class="line">20 10</span><br><span class="line">输出例子：</span><br><span class="line">10.00</span><br><span class="line">例子说明：</span><br><span class="line">触发满20元减10元即可。满减价优于折扣价。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">2</span><br><span class="line">10 10.25</span><br><span class="line">10 3.5</span><br><span class="line">20 4.5</span><br><span class="line">输出例子：</span><br><span class="line">error</span><br><span class="line">例子说明：</span><br><span class="line">折扣价高于原价，数据错误。</span><br></pre></td></tr></table></figure><hr><p>没啥难度，鉴定为纯纯的语法题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[i] || a[i] &lt;= <span class="number">0</span> || b[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y || x &lt;= <span class="number">0</span> || y &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> sum_manjian = <span class="number">0</span>, sum_zhekou = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum_manjian += a[i];</span><br><span class="line">        sum_zhekou += b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum_manjian &gt;= x) &#123;</span><br><span class="line">        sum_manjian -= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, <span class="built_in">min</span>(sum_manjian, sum_zhekou));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用C++语言的话，最后记得用printf并且要控制一下输出的小数位数。 笔者写这道题的时候因为忘记控制小数位数为2位，所以最开始就wa了一发</p><hr><h2 id="T2-小美的字符串匹配度">T2. 小美的字符串匹配度</h2><p>小美有两个长度为𝑛<em>n</em>只包含小写字母的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi></mrow><annotation encoding="application/x-tex">𝑠</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> , 小美定义“两个字符串的匹配度”为𝑖∈[1,𝑛]<em>i</em>∈[1,<em>n</em>]中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑠</mi><mi>𝑖</mi></msub><mo>=</mo><msub><mi>𝑡</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑠_𝑖=𝑡_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的数量，例如&quot;abacd&quot;和&quot;aabdd&quot;的匹配度就是2。</p><p>现在你可以进行最多一次以下操作:<br>对于字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，选择两个索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑖</mi><mo separator="true">,</mo><mi>𝑗</mi></mrow><annotation encoding="application/x-tex">𝑖,𝑗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>𝑖</mi><mo>&lt;</mo><mi>𝑗</mi><mo>≤</mo><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">1≤𝑖&lt;𝑗≤𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>)，交换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑡</mi><mi>𝑖</mi></msub></mrow><annotation encoding="application/x-tex">𝑡_𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝑡</mi><mi>𝑗</mi></msub></mrow><annotation encoding="application/x-tex">𝑡_𝑗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>​。</p><p>小美想知道，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi></mrow><annotation encoding="application/x-tex">𝑠</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">𝑡</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的最大字符串匹配度是多少？</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个整数n</span><br><span class="line">第二行输入一个长度为n的字符串s。</span><br><span class="line">第三行输入一个长度为n的字符串t。</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出一个整数，s和t的最大匹配度。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">5</span><br><span class="line">ababc</span><br><span class="line">babac</span><br><span class="line">输出例子：</span><br><span class="line">3</span><br></pre></td></tr></table></figure><hr><p>先把两个字符串遍历一轮，计算在没有交换的情况下的字符串匹配度</p><p>对于没能匹配的字符，我个人考虑使用vector来存。遍历完数组之后，再把两个vector都遍历一次，就能得到存在交换的情况下最大的字符串匹配度了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">string s, t;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; svec, tvec;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == t[i]) &#123;</span><br><span class="line">res++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">svec.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">tvec.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; svec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tvec.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (svec[i] == tvec[j]) &#123;</span><br><span class="line">exchange = exchange &lt; <span class="number">1</span> ? <span class="number">1</span> : exchange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (svec[j] == tvec[i]) &#123;</span><br><span class="line">exchange = exchange &lt; <span class="number">1</span> ? <span class="number">1</span> : exchange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (svec[i] == tvec[j] &amp;&amp; svec[j] == tvec[i]) &#123;</span><br><span class="line">exchange = exchange &lt; <span class="number">2</span> ? <span class="number">2</span> : exchange;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res + exchange &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T3-小美的树上染色">T3. 小美的树上染色</h2><p>小美拿到了一棵树，每个节点有一个权值。初始每个节点都是白色。</p><p>小美有若干次操作，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，小美就可以把这两个节点同时染红。</p><p>小美想知道，自己最多可以染红多少个节点？</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个正整数n，代表节点的数量。</span><br><span class="line">第二行输入n个正整数ai，代表每个节点的权值。</span><br><span class="line">接下来的n - 1行，每行输入两个正整数u, v，代表节点u和节点v有一条边连接。</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出一个整数，表示最多可以染红的节点数量。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">3</span><br><span class="line">3 3 12</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">输出例子：</span><br><span class="line">2</span><br><span class="line">例子说明：</span><br><span class="line">可以染红第二个和第三个节点。</span><br><span class="line">请注意，此时不能再染红第一个和第二个节点，因为第二个节点已经被染红。</span><br><span class="line">因此，最多染红 2 个节点。</span><br></pre></td></tr></table></figure><hr><p>这道题是一道典型的图论题，我自己是非常讨厌图论的，打比赛的时候碰到图论题都是直接丢给队友做，但是这道图论题硬要说的话其实真没那么难</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/meituan2023q3t3.png" alt=""></p><p>根据这张图可以知道，a和b是可以染色的，因为它们联通且它们的权值之积是完全平方，但是如果染了a和b，就无法给其他节点染色了。因此应当染上f-a或e-a和c-b或d-b。也就是染色要先从叶子节点开始染，如果把中间节点先染色了，那么很可能就没法继续染了</p><p>实现方法：先染外层节点，然后往内层节点推进。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">// 变量解释</span></span><br><span class="line"><span class="comment">// n：节点个数</span></span><br><span class="line"><span class="comment">// a：节点权值</span></span><br><span class="line"><span class="comment">// d：每个节点的边的数量</span></span><br><span class="line"><span class="comment">// red：是否被染色</span></span><br><span class="line"><span class="comment">// vis：是否遍历过</span></span><br><span class="line"><span class="comment">// e：图结构</span></span><br><span class="line">ll n;</span><br><span class="line">ll a[maxn], d[maxn], red[maxn], vis[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全平方判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPow</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll y = (<span class="type">int</span>)<span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">return</span> y * y == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">d[u]++;</span><br><span class="line">d[v]++;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] == <span class="number">1</span>) &#123;</span><br><span class="line">que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> y = e[x][i];</span><br><span class="line"><span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (red[x] == <span class="number">0</span> &amp;&amp; red[y] == <span class="number">0</span> &amp;&amp; <span class="built_in">isPow</span>(a[x] * a[y])) &#123;</span><br><span class="line">red[x] = <span class="number">1</span>;</span><br><span class="line">red[y] = <span class="number">1</span>;</span><br><span class="line">res += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">d[y]--;</span><br><span class="line"><span class="keyword">if</span> (d[y] == <span class="number">1</span>) &#123;</span><br><span class="line">que.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T4-小美的排列询问">T4. 小美的排列询问</h2><p>小美拿到了一个排列。她想知道在这个排列中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是否是相邻的。你能帮帮她吗？</p><p>排列是指一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数组，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 每个元素恰好出现一次。</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个正整数n，代表排列的长度。</span><br><span class="line">第二行输入n个正整数ai，代表排列的元素。</span><br><span class="line">第三行输入两个正整数x和y，用空格隔开。</span><br><span class="line">1 &lt;= n &lt;= 200000</span><br><span class="line">1 &lt;= ai, x, y &lt;= n</span><br><span class="line">保证 x != y</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果x和y在排列中相邻，则输出&quot;Yes&quot;。否则输出&quot;No&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">4</span><br><span class="line">1 4 2 3</span><br><span class="line">2 4</span><br><span class="line">输出例子：</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">5</span><br><span class="line">3 4 5 1 2</span><br><span class="line">3 2</span><br><span class="line">输出例子：</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><p>又是一道送分题，这是真送分啊（不过美团的笔试对面试的影响程度比较低，无论是ak还是一道题都没a出来都可以约面的（<s>都会被泡池子</s>），取决于投递的业务组）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a[i] == x &amp;&amp; a[i + <span class="number">1</span>] == y) || (a[i] == y &amp;&amp; a[i + <span class="number">1</span>] == x)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T5-小美的排列构造">T5. 小美的排列构造</h2><p>小美定义一个数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi></mrow><annotation encoding="application/x-tex">𝑎</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的权值计算如下：</p><p>首先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi></mrow><annotation encoding="application/x-tex">𝑎</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的每一对相邻两项求和，得到一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">𝑏</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 数组。那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">𝑏</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 数组的最大值减最小值即为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi></mrow><annotation encoding="application/x-tex">𝑎</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 数组的权值。</p><p>例如，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">𝑎=[2,1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑏</mi><mo>=</mo><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">𝑏=[3,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">𝑏</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 数组的极差是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi></mrow><annotation encoding="application/x-tex">𝑎</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 数组的权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>现在小美希望你能构造一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的排列，满足权值尽可能小。你能帮帮她吗？</p><p>排列是指一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数组，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 每个元素恰好出现一次。</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个正整数n，代表排列的长度。</span><br><span class="line">2 &lt;= n &lt;= 200000</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个合法的排列。如果有多解输出任意即可。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">3</span><br><span class="line">输出例子：</span><br><span class="line">2 1 3</span><br><span class="line">例子说明：</span><br><span class="line">这个数组的权值为 1。输出[2,3,1]等排列也是合法的。</span><br></pre></td></tr></table></figure><hr><p>这道题是构造题。应付构造题其实没有什么特别好的办法，不像其他的题一样有一个大概的套路，最好的办法就是多写构造题，或者提高一点对数字的敏感度——即使是这样，有时候构造题也不一定能写出来。所以构造题可以很简单，也可以非常非常难</p><p>但是这道构造题算是简单的了——个人感觉这道题放进Codeforce最多就1000分段的题</p><p>什么是权值？<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 数组相邻两项的之和的最大最小之差就是权值。我们需要构造出权值最小的情况，那么就意味着我们需要尽可能构造出一种排列，使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 数组的每相邻两项的和都应该靠近某个值。这道题的简单之处就在于数组无论怎么变换都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的全排列的一种情况，如果稍微变形一下，变成给定任意数组求该数组排列的最小权值，而且数组长度动辄1e5甚至1e7，那就很难了</p><p>那么我们用上一点灵性，就能想到一个点子——我们可以把最大最小值放在一起，这样每相邻的两项的和就接近于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最终得到的权值必然等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。例如，对于数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a = [1, 2, 3, 4, 5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>， 我可以将其变形为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a = [1, 5, 2, 4, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> ，这样得到的权值就等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。这个地方可以用数学来证明，但是算法竞赛和笔试的时间往往不充裕，不允许我们进行数学证明，我们可以写几个样例来试一下这个思路到底是不是正确的</p><p>根据样例1，我们可以得到变形后的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a = [1, 3, 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>，求出的权值就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。读者可以尝试写出更多样例，最终还是会发现在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的情况下，数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 的最小值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最大值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ；在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的情况下，权值就等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>。但是经过我的实测，发现这道题并没有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的数据……作为边界条件居然不设一个数据，出题人要背大锅</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">a[i] = l++;</span><br><span class="line">a[i + <span class="number">1</span>] = r--;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">a[n] = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T6-小美走公路">T6. 小美走公路</h2><p>有一个环形的公路，上面共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 站，现在给定了顺时针第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑖</mi></mrow><annotation encoding="application/x-tex">𝑖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 站到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑖</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑖+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 站之间的距离（特殊的，也给出了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 站到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 站的距离）。小美想沿着公路第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑥</mi></mrow><annotation encoding="application/x-tex">𝑥</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 站走到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑦</mi></mrow><annotation encoding="application/x-tex">𝑦</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 站，她想知道最短的距离是多少？</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个正整数n，代表站的数量。</span><br><span class="line">第二行输入个正整数ai，前n - 1个数代表顺时针沿着公路走，i站到第i + 1站之间的距离；最后一个正整数n代表顺时针沿着公路走，第n站到第 1 站的距离。·</span><br><span class="line">第三行输入两个正整数x和y，代表小美的出发地和目的地。</span><br><span class="line">1 &lt;= n &lt;= 1e5</span><br><span class="line">1 &lt;= ai &lt;= 1e9</span><br><span class="line">1 &lt;= x, y &lt;= n</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个正整数，代表小美走的最短距离</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">3</span><br><span class="line">1 2 2</span><br><span class="line">2 3</span><br><span class="line">输出例子：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">3</span><br><span class="line">1 2 2</span><br><span class="line">1 3</span><br><span class="line">输出例子：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><p>不算难的模拟，记得写着写着不要把方向和距离是啥搞混了就行</p><p>还有就是这道题如果是用C++写的话，会爆int，记得开long long</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; y; i++) &#123;</span><br><span class="line">r += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">cout &lt;&lt; sum - r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T7-小美的好矩阵">T7. 小美的好矩阵</h2><p>小美定义一个矩阵是好矩阵，当且仅当该矩阵满足：</p><ol><li>矩阵仅由’A’、‘B’、'C’三种字符组成。且三种字符都出现过。</li><li>矩阵相邻的字符都不相等。</li></ol><p>现在给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>×</mo><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑛\times𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的矩阵，小美想知道有多少个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>的子矩阵是好矩阵，你能帮帮她吗？</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入两个整数n, m，代表矩阵的行数和列数。</span><br><span class="line">接下来的n行，每行输入一个仅包含大写字母的长度为m的字符串。</span><br><span class="line">1 &lt;= n, m &lt;= 1000</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出一个整数表示答案。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">4 4</span><br><span class="line">DABC</span><br><span class="line">ABAB</span><br><span class="line">BABA</span><br><span class="line">BBAB</span><br><span class="line">输出例子：</span><br><span class="line">1</span><br><span class="line">例子说明：</span><br><span class="line">有4个3*3的子矩阵。</span><br><span class="line">左上角的子矩阵出现了&#x27;D&#x27;，因此不合法。</span><br><span class="line">右上角的是好矩阵。</span><br><span class="line">左下角的存在两个相邻的字母相同，因此不合法。</span><br><span class="line">右下角的子矩阵里没有&#x27;C&#x27;，因此不合法。</span><br></pre></td></tr></table></figure><hr><p>这道题我只过了样例……可能是我代码什么地方数组访问超界了，哎真的很可惜，这道题应该是一道比较简单的模拟题啊</p><p>不给代码了，网上的题解代码应该也不少</p><hr><h2 id="T8-小美的蛋糕切割">T8. 小美的蛋糕切割</h2><p>小美有一个矩形的蛋糕，共分成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">𝑛</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>  行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 列，共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑛</mi><mo>×</mo><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">𝑛\times 𝑚</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个区域，每个区域是一个小正方形，已知蛋糕每个区域都有一个美味度。她想切一刀把蛋糕切成两部分，自己吃一部分，小团吃另一部分。</p><p>小美希望两个人吃的部分的美味度之和尽可能接近，请你输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo><mi>𝑠</mi><mn>1</mn><mo>−</mo><mi>𝑠</mi><mn>2</mn><mo>∣</mo></mrow><annotation encoding="application/x-tex">∣𝑠1−𝑠2∣</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span></span></span></span>的最小值。（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">𝑠1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span></span></span></span> 代表小美吃的美味度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">𝑠2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span></span></span></span> 代表小团吃的美味度）。</p><p>请务必保证，切下来的区域都是完整的，即不能把某个小正方形切成两个小区域。</p><p><strong>时间限制</strong>：C/C++ 1秒，其他语言2秒</p><p><strong>空间限制</strong>：C/C++ 256M，其他语言512M</p><p><strong>输入描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输出两个正整数n和m，代表蛋糕区域的行数和列数。</span><br><span class="line">接下来的n行，每行输入m个正整数a[i,j]，用来表示每个区域的美味度。</span><br><span class="line">1 &lt;= n, m &lt;= 1e3</span><br><span class="line">1 &lt;= a[i, j] &lt;= 1e4</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个整数，代表|s1 - s2|的最小值。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入例子：</span><br><span class="line">2 3</span><br><span class="line">1 1 4</span><br><span class="line">5 1 4</span><br><span class="line">输出例子：</span><br><span class="line">0</span><br><span class="line">例子说明：</span><br><span class="line">把蛋糕像这样切开：</span><br><span class="line">1 1 | 4</span><br><span class="line">5 1 | 4</span><br><span class="line">左边蛋糕美味度之和是8</span><br><span class="line">右边蛋糕美味度之和是8</span><br><span class="line">所以答案是0。</span><br></pre></td></tr></table></figure><hr><p>114514是吧，好臭的题面（<s>哼哼啊啊啊啊啊啊</s>）</p><p>（其实这道题最难绷的地方是题面样例数据是114514，然后题目要求计算”美味度之差“，太他妈搞了 ）(<s>美味しかったです</s>)（一三五红茶，二四六牡蛎，周日红茶，这就是美团homo的生活啊）</p><p>二维前缀和维护美味度，然后遍历二维前缀和的下边界和右边界就能得到最小的差值</p><p>还有一个经典老问题，就是这道题的一些数据求完总和会爆int，记得开long long</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[maxn][maxn];</span><br><span class="line">ll sum[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">sum[i][j] = (sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = INT32_MAX;</span><br><span class="line">ll totalSum = sum[n][m];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll left = sum[n][i];</span><br><span class="line">ll right = totalSum - left;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &lt; res) &#123;</span><br><span class="line">            res = <span class="built_in">abs</span>(left - right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ll up = sum[i][m];</span><br><span class="line">ll down = totalSum - up;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(up - down) &lt; res) &#123;</span><br><span class="line">            res = <span class="built_in">abs</span>(up - down);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T9-小美的字符串变换">T9. 小美的字符串变换</h2><p>这道题没写，时间不够了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;以下题解为个人题解，仅提供大致思路和提供题解代码。本题解使用的编程语言为C++。本次笔试为模拟测试，得分70.5/100，ac数7/9。题解内容仅供参考&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;美团2023年秋季校园招聘 第一场笔试【技术类】 题解（C++）&lt;/h</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
    <category term="笔试" scheme="https://yonagi04.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之建造者模式</title>
    <link href="https://yonagi04.github.io/posts/2024/0cb74690ad0d/"/>
    <id>https://yonagi04.github.io/posts/2024/0cb74690ad0d/</id>
    <published>2024-07-10T20:56:35.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式是一种创建型设计模式, 旨在将复杂对象的构建过程与其表示分离, 使同样的构建过程可以构建不同的表示. 建造者模式主要用于以下情况:</p><ol><li><strong>需要创建的对象非常复杂</strong>: 这个对象由多个部分组成, 且这些部分需要一步步地构建</li><li><strong>不同的表示</strong>: 通过相同的构建过程可以生成不同的表示</li><li><strong>构建过程的控制</strong>: 希望能够有更多的控制, 逐步创建对象, 而不是在一个步骤中完成</li></ol><h2 id="建造者模式结构">建造者模式结构</h2><ol><li><strong>抽象建造者</strong>: 定义了创建产品的各部件的抽象接口</li><li><strong>具体建造者</strong>: 实现了建造者接口, 构建并装配各个部件, 最终生成具体的产品</li><li><strong>产品</strong>: 具体要创建的复杂对象</li><li><strong>指挥者</strong>: 负责安排已有模块的顺序构建一个复杂的对象</li></ol><h2 id="建造者模式实现">建造者模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartC</span><span class="params">(String partC)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product [partA=&quot;</span> + partA + <span class="string">&quot;, partB=&quot;</span> + partB + <span class="string">&quot;,partC=&quot;</span> + partC + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;Part A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;Part B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;Part C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li><strong>易于拓展</strong>: 通过创建新的具体建造者, 可以很容易地增加新的产品表示</li><li><strong>细粒度控制</strong>: 可以一步步地构建对象, 细化对象的创建流程</li><li><strong>封装性</strong>: 将复杂对象的创建封装在建造者中, 客户端无需了解细节</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>更多的代码量</strong>: 为了实现建造者模式, 需要更多的类和接口, 增加了代码量</li><li><strong>复杂性</strong>: 对于简单的对象创建, 建造者模式过于复杂了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;建造者模式是一种创建型设计模式, 旨在将复杂对象的构建过程与其表示分离, 使同样的构建过程可以构建不同的表示. 建造者模式主要用于以下情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;需要创建的对象非常复杂&lt;/strong&gt;: 这个对象由多个部分组成, 且这些部分需要一步步</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之原型模式</title>
    <link href="https://yonagi04.github.io/posts/2024/44e0d8cafc60/"/>
    <id>https://yonagi04.github.io/posts/2024/44e0d8cafc60/</id>
    <published>2024-07-09T20:13:21.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式是一种创建型设计模式, 用于创建对象, 而不必指定它们所属的具体类. 它通过复制现有对象 (即原型) 来创建新对象. 原型模式适用于当创建新对象的过程代价较高或复杂时, 通过克隆现有对象来提高性能</p><h2 id="原型模式结构">原型模式结构</h2><ul><li><strong>原型接口</strong>. 声明一个克隆自身的接口</li><li><strong>具体原型</strong>. 实现克隆的具体方法</li><li><strong>客户端</strong>. 通过调用具体原型中的克隆方法来创建新对象</li></ul><h2 id="原型模式实现">原型模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String field)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现克隆方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="built_in">this</span>.field);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcretePrototype&#123;&quot;</span> + <span class="string">&quot;field = &quot;</span> + field + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 克隆原型对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone();</span><br><span class="line">        </span><br><span class="line">        System.out.println(prototype);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原型模式中, 克隆可以分为浅拷贝和深拷贝</p><ul><li><strong>浅拷贝</strong>: 复制对象时, 只复制对象本身的基本数据类型字段和对象的引用, 而不复制引用对象本身</li><li><strong>深拷贝</strong>: 复制对象时, 不仅复制对象本身的基本数据类型字段和对象的引用, 还复制所有引用对象, 递归地进行复制</li></ul><p>下面是深拷贝和浅拷贝的实例</p><p>浅拷贝:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ConcretePrototype) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcretePrototype&#123;&quot;</span> + <span class="string">&quot;list=&quot;</span> + list + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(String item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">        clone.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.list); <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcretePrototype&#123;&quot;</span> + <span class="string">&quot;list=&quot;</span> + list + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原型模式是一种创建型设计模式, 用于创建对象, 而不必指定它们所属的具体类. 它通过复制现有对象 (即原型) 来创建新对象. 原型模式适用于当创建新对象的过程代价较高或复杂时, 通过克隆现有对象来提高性能&lt;/p&gt;
&lt;h2 id=&quot;原型模式结构&quot;&gt;原型模式结构&lt;/h2&gt;
&lt;u</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之工厂模式</title>
    <link href="https://yonagi04.github.io/posts/2024/d201fecdf36e/"/>
    <id>https://yonagi04.github.io/posts/2024/d201fecdf36e/</id>
    <published>2024-07-09T20:11:33.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是一种创建型设计模式, 旨在将对象的创建过程和使用过程分离. 这样可以在不改变客户端代码的前提下, 灵活创建不同类型的对象</p><h2 id="工厂模式实现">工厂模式实现</h2><ol><li><strong>简单工厂模式</strong></li></ol><p>简单工厂模式使用一个工厂类根据传入的参数决定创建哪种具体产品类的实例. 它不属于设计模式的23种, 但它为理解工厂模式奠定了基础</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreateProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreateProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreateProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreateProductB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown product type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        productA.use();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Product</span> <span class="variable">produceB</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        productB.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>: 封装了创建对象的流程, 可以通过参数直接获取对象, 把对象的创建和业务逻辑层分开, 这样以后就避免了修改客户端代码. 如果要实现新产品直接修改工厂类, 而不需要在源代码中修改, 这样就降低了客户代码修改的可能性, 更容易拓展</p><p><strong>缺点</strong>: 增加新产品时还需要修改工厂类的代码, 违背了开闭原则</p><ol start="2"><li><strong>工厂方法模式</strong></li></ol><p>工厂方法模式使用工厂接口定义一个创建对象的接口, 但由子类决定实例化哪个类, 这样工厂方法模式使得一个类的实例延迟到其子类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreateProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreateProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactoryA</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> factoryA.createProduct();</span><br><span class="line">        productA.use();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactoryB</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productB</span> <span class="operator">=</span> factoryB.createProduct();</span><br><span class="line">        productB.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>:</p><ul><li>用户只需要知道具体工厂的名称就能得到所要的产品, 不需要知道产品的具体创建过程</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类, 无须对原工厂进行任何修改, 满足开闭原则</li></ul><p><strong>缺点</strong>: 每增加一个产品就要增加一个具体产品类和具体工厂类, 增加了系统复杂度</p><ol start="3"><li><strong>抽象工厂模式</strong></li></ol><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类. 通过定义多个工厂接口来实现不同产品族的创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品A接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品B接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using product A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating product B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating product B2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    ProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    ProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        productA1.use();</span><br><span class="line">        productB1.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line">        productA2.use();</span><br><span class="line">        productB2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法模式与抽象工厂模式的区别</p><ol><li><strong>复杂性和用途</strong><ul><li>工厂方法模式: 创建一个具体产品对象, 适合于一个产品等级结构</li><li>抽象工厂模式: 创建一系列相关或相互依赖的对象, 适合于多个产品等级结构</li></ul></li><li><strong>类结构</strong><ul><li>工厂方法模式: 只有一个抽象产品类和多个具体产品类, 以及一个抽象工厂类和多个具体工厂类</li><li>抽象工厂模式: 有多个抽象产品类和多个具体产品类, 以及一个抽象工厂类和多个具体工厂类</li></ul></li><li><strong>拓展性</strong>:<ul><li>工厂方法模式: 增加新的产品需要增加新的具体产品类和具体工厂类</li><li>抽象工厂模式: 增加新的产品族需要增加新的具体工厂类, 增加新的产品等级需要增加修改所有的工厂类</li></ul></li></ol><p><strong>优点</strong>: 当一个产品族中的多个对象被设计在一起工作时, 它能保证客户端始终使用同一个产品族中的对象</p><p><strong>缺点</strong>: 当产品族中需要添加一个新产品时, 所有的工厂类都需要修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂模式是一种创建型设计模式, 旨在将对象的创建过程和使用过程分离. 这样可以在不改变客户端代码的前提下, 灵活创建不同类型的对象&lt;/p&gt;
&lt;h2 id=&quot;工厂模式实现&quot;&gt;工厂模式实现&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;简单工厂模式&lt;/strong&gt;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>大二总结</title>
    <link href="https://yonagi04.github.io/posts/2024/fceb62540e50/"/>
    <id>https://yonagi04.github.io/posts/2024/fceb62540e50/</id>
    <published>2024-07-09T10:42:11.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>大二结束了，从去年8月开始，按时间顺序回顾一下我的大二</p><h2 id="大二上学期">大二上学期</h2><h3 id="迷茫时刻">迷茫时刻</h3><p>我在今年四月份发了一篇博客，大概内容是讲我之前在acm队的一点故事。然后去年8月份因为下半年的区域赛，acm的队伍阵容需要调整，我就趁着这个机会选择从acm隐退了。是的我就打了一把省赛和几次网络赛就选择隐退了，连一把区域赛都没有打，我都不太好意思和外人说我是打过acm的，或者说我已经从acm隐退了。</p><p>然后就是长达三个月的迷茫时间了。从acm隐退之后，我差不多有三四个月的时间没有写过一道算法题（因为acm在役期间我基本上每天都刷了起码15道算法题，平均一道题30~40分钟，每天花接近10个小时的时间在刷Codeforce和Atcoder，写得我真的有点犯恶心），学东西也很慢，也不知道自己以后的技术栈到底往哪个方向发展。我当时是在学C++，因为我当时固执地认为自己大概率会往C++的方向发展，所以就一直在啃C++ Primer。同期也一直在学CSAPP，顺带做了几个CSAPP的Lab（虽然我就做了两个还是三个Lab）。那时候基本上除了上课就在啃C++ Primer和看CSAPP的网课。</p><h3 id="方向初立">方向初立</h3><p>差不多到11月，我刷知乎的时候偶然刷到了知乎上某知名C++答主的一些回答，发现C++可以走后端开发路线，于是我决定开始往后端开发的方向学习。C++后端要学啥呢？C++、STL、各种计算机的专业课，所以我从这个时候开始就直接开啃其他的专业课，《Computer Networking: A Top-Down Approach》也是这个时候买下来的，《Operation System: Three Easy Pieces》也是这个时候开始看的。那时候一方面要兼顾课内的模电数电和复变函数论，另一方面还要继续补充计算机专业课的知识，虽然那段时间我没咋写代码，但还是很忙，每天日程还是排满的</p><p>差不多也是这个时候我才确定要去实习的，此前一直都是想着大三上学期学完后端开发所有的技术，然后大三下学期就去准备考研。不过牛客上面的一篇博客推送打破了我的计划，博客的大概内容是华师的一位同样是26届、同样是C++方向的同学计划去找实习，在牛客上询问需要补充哪些知识点。可能是好胜心所致，我不愿意屈服于我的现状，外加我当时也从研究生师兄那里听说到研究生找工作也很困难，而且基本上都被导师压榨到无法去实习，所以我在那个时候差不多就确定了在本科期间我得去找一份实习的想法。</p><p>12月份的时候我开始学MySQL和Redis，也算是后端开发的关键技能点了吧！学到寒假基本上就学完了（其实是把黑马程序员的网课看完了，顺带还做了笔记）（<s>至于做了笔记之后到现在还能记得多少，我不好说哈哈</s>）</p><p>当时还记得在牛客上发了个帖子，大概内容也是关于找实习的，评论区下面有不少劝我润Java的，我当时还感觉奇怪，C++的环境真的那么糟糕吗？后来才知道，C++本身不算烂，但C++后端真的是烂到底了，本来hc就少（大厂只有腾讯还在用C++写后端，但是新项目已经全部改用Go了；中厂小厂更是无人用C++写后端系统的），项目更是人手一个WebServer和cmu15445，还能找到工作吗？去招聘网站一看，根本没人要C++后端开发。我不禁产生了怀疑</p><h2 id="大二下学期">大二下学期</h2><h3 id="转移目标">转移目标</h3><p>C++后端这条路似乎走不太通，我于是试图转其他的语言，毕竟我的目的是后端开发，而不是C++。我最开始尝试了Go语言，但是感觉Go的语法真的很怪，用起来很不习惯（如果能适应Go的语法，那么很快就能开始上手写东西了，框架也就只有Gin和Gorm，当然这些都是我听说的，我并未尝试过），外加学习Go找不到合适的教程和项目，于是就放弃了</p><p>然后我选择了Java。因为大一上学期学过一段时间的Java，且大一下学期和大二上学期大部分时间都在写C++，所以入门相当快，花了一个星期就基本上把基础的东西学完了，之后就是SpringBoot，SpringCloud，各种后端技术栈。当时我还怀抱着“大二就能进大厂实习”这种美好的幻想</p><h3 id="试图找实习">试图找实习</h3><p>我是在四月把简历写完的，但是之后还一直在陆陆续续地改简历。然后五月份开始就是期末考试，一直断断续续考到七月初，差不多隔一两个星期就有一门考试。这就导致了其实我根本没啥时间可以背八股或者复盘我写过的项目。开始投简历已经是六月份的事情了——可惜这时候正好没啥hc。所以我为啥在这个小节的title加了一个“试图”，就是想说明其实我根本没找到</p><h3 id="陷入焦虑">陷入焦虑</h3><p>这应该是前段时间的状态了，不过最近好了很多。一方面是自己基本上是大厂投了就挂，中小厂投了要么已读不回，要么要了简历，却没了后续，连个面试都没收到；另一方面是看到不少同龄人都已经拿到了实习offer甚至是大厂offer（当然，不是后端），看完之后就更焦虑。一焦虑了就想着背八股投简历，结果一轮投完了啥都没有，打开牛客一看推送又是26届的拿到offer了，简直被气得要吐血，狠狠地恶性循环。不过现在个人感觉，找不到也无所谓吧，反正多少还有点时间。（应该吧？）</p><h2 id="其他">其他</h2><h3 id="换了新电脑">换了新电脑</h3><p>我大一和大二上学期大部分时间都在用我老掉牙的古董电脑——4GB内存，128GB的SATA固态，1TB的机械，8代的英特尔低压处理器，没有独立显卡。看到这些配置就应该感觉生产力会明显受限了——确实是这样的。大一还在acm队的时候，我基本上是左边分屏edge开着codeforce或者atcoder可以看题（别问为什么是edge，因为chrome会更吃内存），右边分屏开vscode敲代码，但是因为这台电脑只有4GB的内存，所以会非常非常卡。去年11月份，终于用省吃俭用攒下来的一点钱买下了我现在的这台电脑。16GB内存，CPU是amd的7735H，显卡是4060，生产力问题当然是成功解决了。我寻思着我要是不换电脑，可能到现在我都没法学java后端（因为java和idea真的好吃内存，老电脑用idea开个项目都能卡死，更别说开什么微服务了）</p><h3 id="买了-学了电吉他">买了/学了电吉他</h3><p>具体信息可以看我之前写过的博客。今年3月份用多余的一点钱买了一把Ibanez GRX40和橘子音箱CR mini，现在弹了几个月了，讲讲用琴感受</p><p>拾音器很垃圾，尤其是双拾音器，开失真的声音非常非常糊……当然可能是我音箱的问题。单拾音器会稍微好一点，但我确实不咋喜欢单拾音器清淡的音色……所以我一般练乐句还是练曲子都是用的双拾音器，然后就是一直被双拾音器折磨。然后就是这玩意的电流声真的超级明显……也有可能是我音箱的问题。但这把琴也才一千来块钱，要什么自行车？</p><p>下半年可能会考虑去闲鱼收一个二手的效果器，当然在此之前先允许我把音箱给换了，这个音箱用着太难受了</p><p>再然后就可能是会换一把琴，下一把琴可能会换PRS SE Custom 24吧</p><h3 id="Yonagi’s-Sekai的建立">Yonagi’s  Sekai的建立</h3><p><code>Yonagi's Sekai</code> 这个网站也是在我大二上学期的时候建起来的。当时是阿里云给每个在校大学生都送了200块钱还是300块钱的代金券，正好能买一台一年份的新加坡的轻量服务器。作为白嫖仙人，这么一台服务器不嫖白不嫖嘛，那当然是要白嫖一台的，然后嫖了就不知道干啥了。我本来是想复活我的qq机器人计划，但是之前我的小号因为挂qq机器人所以被腾讯封了好几次号……所以这个计划就搁置了。</p><p>那么服务器还能拿来干啥呢？我想到了一个绝佳的想法，那就是搞个人网站。说搞就搞，我反手去网上查了点资料，发现WordPress很适合个人建站，而且WordPress有很多好看的主题，于是技术方案就选择了PHP+WordPress，数据库是选用了MySQL。整个网站完全建起来应该花了一天左右的时间，包括建站到开始运行再到买域名，差不多一天吧。~~记得当时还在qq空间打了个广告，宣传了一下自己的网站。~~然后就是在CSDN发了一篇关于WordPress建站的博客，那篇博客的阅读数还挺高的，到现在好像差不多有1w的阅读量了</p><p>大一的时候也嫖过阿里云的一台服务器，不过是三个月的，拿来挂qq机器人。结果挂到后面发现qq机器人的进程经常死掉，查询了阿里云的后台发现服务器的连接数和CPU、网络、内存的占用率非常高，而且经常压不下来。当时还不知道发生了什么，后来学了点网安相关的东西，才知道原来是服务器被打了，大概率是ssh先被爆破，然后服务器变成了黑客的肉鸡（<s>什么ntr剧情</s>）。所以这次拿到服务器之后，我对于服务器的安全运行是非常重视的，到手直接先改了ssh的默认端口，ssh的登录方式也改成了密钥文件+强口令登录，顺带还挂了Cloudflare的防火墙。（<s>后来也发了两篇关于Cloudflare的防火墙设置的博客，感觉更像是给Cloudflare打广告，Cloudflare快付我广告费</s>）</p><p>如果你观察本站（而非镜像站）的域名，你会发现本站的域名改成了<code>yonagi04.github.io</code>，部署的位置改成了Github。这是在我今年三月的时候对网站做的一个大改动，就是把整个网站全部迁移到Github，用Hexo框架来构建网站页面，然后由Github来管理我的网站。我为什么会选择放弃WordPress，选择使用Hexo框架呢？首先就是Hexo完全支持Markdown语法，这是它最吸引我的一点（反观WordPress，完全不支持Markdown语法，其实就不太适合我用Typora撰写的技术类博客）；其次就是Hexo是一个无后端框架，写完的博客会通过Hexo自动生成一个静态的HTML页面，这样我也不需要服务器了；然后就是Hexo的源码都是JS和CSS，总比PHP容易看懂吧？后来也是花了一个下午的时间把网站跑起来，后来又花了差不多几个星期的时间给网站做优化，就变成了现在大家能看到的 <code>Yonagi's Sekai</code>。</p><h2 id="未来（对大三）的一点展望">未来（对大三）的一点展望</h2><p>经典立flag环节。好吧，虽然有时候计划赶不上变化，但计划还是需要的</p><ol><li><p>假如我能去实习的话，希望不要被卡实习</p></li><li><p>可能会学一点前端 （<s>画大饼环节</s>）</p></li><li><p>学一手测试（<s>画大饼环节</s>）</p></li><li><p>明年春招的暑期实习可以顺利找到，不管是测开还是后端都行，能进大厂就更好了</p></li><li><p>继续练吉他，早日达成cover一首anime song的成就</p></li><li><p>每天坚持绕着学校骑车骑一圈（外环西路-星光下道-外环西路）（如果不下雨的话）</p></li><li><p>可能会学一点乐理和视唱练耳，早日能独立扒铺子（<s>画大饼环节</s>）</p></li><li><p>有钱了应该大概也许可能maybe会考虑买一把midi键盘（<s>你有那个实力吗</s>）（<s>吉他都还没完全学会就开始学编曲，笑死人了</s>）</p></li><li><p><s>如果能给开源项目contribute一下就更好了，比如Nacos或者SpringCloud Alibaba之类的</s></p></li><li><p>维持一下绩点，现在的绩点真的太烂了（为什么说是维持呢？因为我感觉这byd绩点真的提不起来了，尽量维持一下，别人挂科了绩点掉下去了我的排名不就上来了吗哈哈哈）</p></li></ol><p>大概就是这样，希望能越过越好吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大二结束了，从去年8月开始，按时间顺序回顾一下我的大二&lt;/p&gt;
&lt;h2 id=&quot;大二上学期&quot;&gt;大二上学期&lt;/h2&gt;
&lt;h3 id=&quot;迷茫时刻&quot;&gt;迷茫时刻&lt;/h3&gt;
&lt;p&gt;我在今年四月份发了一篇博客，大概内容是讲我之前在acm队的一点故事。然后去年8月份因为下半年的区域赛，a</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊地平线4</title>
    <link href="https://yonagi04.github.io/posts/2024/cc501b2c7b3f/"/>
    <id>https://yonagi04.github.io/posts/2024/cc501b2c7b3f/</id>
    <published>2024-07-08T20:42:32.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>昨天趁着Steam里面地平线4（Forza Horizon 4）打折，30多块钱就能买下来，因为最近有点电子ed，想着能不能换个游戏改善一下口味，于是就买了一个，这篇博客就是简单谈谈我的游玩体验</p><p>（当然，这是个三年的老游戏了，网上的评测肯定是层出不穷——所以我这个游玩体验也只针对我个人，不代表所有人，也不代表这个游戏本身的品质）</p><p>先说说游戏本身，最近Steam打折，地平线4和地平线5都迎来了一定幅度的降价，地平线4的游戏本体30多块钱就能买下来，地平线5则需要120多块钱。考虑到我只是想换个别的类型的游戏，改善一下口味顺带缓解一下我的电子ed，所以我选择了地平线4——且没有购买dlc</p><p>在开始之前介绍一下我本人的电脑配置和画面配置。我个人的电脑配置是7735H+4060，没有超频过，内存是DDR5 16G 5200MHZ的双通道。画面配置为全高，游玩时基本能跑到200帧往上</p><p>讲讲游戏内容。游戏的画面非常出彩——这是我打开这个游戏之后的第一印象——对车辆、建筑和外围风景的还原都相当逼真。地图很大，和GTA5这种大世界不好比，但是在我玩过的几款赛车游戏中，这个游戏的地图面积已经是非常大了。游戏中车的种类倒是非常多，但是因为我没有买dlc，所以可以选的车辆就很有限了。（所以，如果对这个游戏非常感兴趣，请务必直接购买豪华版，不要买最便宜的标准版）就驾驶体验而言，我玩过的赛车游戏不多，不太好评价，我只能说可能不太拟真，游戏里面我几乎是瞎几把打方向，车居然就从来没翻过</p><p>接下来说一下缺点。我认为它最大的缺点就是比较缺乏给予玩家的一种“正反馈”，至少针对我本人是这样的。这个游戏的唯一内容好像就是不停地跑图然后开车开到不同的地方打比赛——仅此而已。可能我是那种不怎么爱驾驶的人吧（我连GTA5跑图的时候开车都是直接挂的脚本，用自动循迹帮我开……），我真的很难感受到来自这个游戏的一种“正反馈”驱使我继续玩这个游戏。当然如果你是那种比较喜欢开车、比较享受驾驶乐趣的人，应该就不会出现我这种情况了。</p><hr><p>差不多就是这样吧，上面基本上算是我的一点“暴论”，也仅代表我个人的观点。地平线4总体来讲算是个好游戏，只不过用它来缓解我的电子ed，恐怕还是有点难</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天趁着Steam里面地平线4（Forza Horizon 4）打折，30多块钱就能买下来，因为最近有点电子ed，想着能不能换个游戏改善一下口味，于是就买了一个，这篇博客就是简单谈谈我的游玩体验&lt;/p&gt;
&lt;p&gt;（当然，这是个三年的老游戏了，网上的评测肯定是层出不穷——所以我</summary>
      
    
    
    
    <category term="游戏" scheme="https://yonagi04.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="Forza Horizon 4" scheme="https://yonagi04.github.io/tags/Forza-Horizon-4/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之单例模式</title>
    <link href="https://yonagi04.github.io/posts/2024/f26e6517d377/"/>
    <id>https://yonagi04.github.io/posts/2024/f26e6517d377/</id>
    <published>2024-07-08T20:06:32.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客已经介绍了设计模式及其设计原则, 在这篇博客中笔者会介绍一下单例模式, 也是最简单的一种设计模式</p><h2 id="单例模式">单例模式</h2><p>单例模式属于创建型模式. 它涉及到一个单一的类, 该类负责创建自己的对象, 同时确保只有单个对象被创建, 这个类提供了一种访问其唯一对象的方式, 可以直接访问, 不需要实例化这个类的对象</p><h3 id="单例模式结构">单例模式结构</h3><ul><li><strong>单例类</strong>. 只能创建一个实例的类</li><li><strong>访问类</strong>. 使用单例类</li></ul><h3 id="单例模式实现">单例模式实现</h3><ol><li><strong>饿汉式单例</strong></li></ol><p><strong>特点</strong>: 在类加载时就创建实例, 线程安全, 但是可能会导致资源浪费</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 在类加载时就创建实例instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>懒汉式单例</strong></li></ol><p><strong>特点</strong>: 延迟创建实例, 但是线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单个的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假如这时instance还没有被创建, 那么就创建一个新的实例instance</span></span><br><span class="line">        <span class="keyword">if</span> (instace == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式单例模式在多线程环境下容易导致线程不安全, 这是因为多个线程可能会同时访问 <code>getInstance()</code> 方法并且同时进入 <code>if (instance == null)</code> 代码块, 这样就会创建多个实例, 违背了单例模式的原则.</p><ol start="3"><li><strong>线程安全的懒汉式单例</strong></li></ol><p><strong>特点</strong>: 延迟创建实例, 使用同步方法保证线程安全, 但是会有性能开销</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单个的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance, 使用同步方法保证线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假如这时instance还没有被创建, 那么就创建一个新的实例instance</span></span><br><span class="line">        <span class="keyword">if</span> (instace == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>双重检查锁</strong></li></ol><p><strong>特点</strong>: 提高性能, 减少同步开销, 线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单个的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断实例是否为null, 如果不为null就直接返回实例, 不进入抢锁阶段</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁了再判断一次是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式可能会出现<strong>空指针问题</strong>, 出现问题的原因是JVM在实例对象时会进行优化和指令重排序操作</p><p>为了解决空指针异常问题, 可以使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单个的实例, 使用volatile关键字保证其可见性和有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断实例是否为null, 如果不为null就直接返回实例, 不进入抢锁阶段</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 抢到锁了再判断一次是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者写到这一段的时候突然想到, 如果把上面双重检查锁的代码略改一下, 改成下面这样, 是否可行?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Double-Checked Locking version 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//======================================</span></span><br><span class="line"><span class="comment">// Double-Checked Locking version 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两种改法, 分别是把synchronized同步块内和同步块外的判断语句 <code>if (instance == null)</code> 删掉之后得到的新代码.</p><p>上面这两种改法是否可行呢? 其实都不好. 对于版本1, 假设有线程1和线程2, 进行了如下操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">        Thread 1                    Thread 2</span><br><span class="line">           |                            |</span><br><span class="line">           |                            |</span><br><span class="line">           |                            |</span><br><span class="line">           |                            |</span><br><span class="line">走到synchronized代码块处                 |</span><br><span class="line">拿到锁之后发生了一次线程切换               |</span><br><span class="line">           |                            |</span><br><span class="line">           |                        走到synchronized代码块处, 拿不到锁, 被阻塞</span><br><span class="line">           |                        线程切换</span><br><span class="line">           |                            |</span><br><span class="line">Thread 1创建了一个新实例                 |</span><br><span class="line">Thread 1离开了synchronized代码块         |</span><br><span class="line">锁被释放                                 |</span><br><span class="line">线程切换                                 |</span><br><span class="line">           |                            |</span><br><span class="line">           |                            |</span><br><span class="line">           |                        Thread 2拿到锁</span><br><span class="line">           |                        Thread 2创建了新实例 (这里违背了单例模式原则)</span><br><span class="line">           |                        Thread 2离开了synchronized代码块</span><br><span class="line">           |                        Thread 2返回了创建的实例</span><br><span class="line">           |                        线程切换</span><br><span class="line">           |                            |</span><br><span class="line">Thread 1返回创建的实例                   |</span><br><span class="line">---------------------------------------------------------</span><br></pre></td></tr></table></figure><p>这就和线程不安全的懒汉单例模式一样了</p><p>对于版本2, 其实和使用同步代码块的懒汉单例模式也是一样的, 线程是安全的, 但是性能开销依然存在</p><ol start="5"><li><strong>静态内部类</strong></li></ol><p><strong>特点</strong>: 利用类加载机制实现懒加载, 线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有的构造函数, 避免从外部构造新实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类, 延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHelper</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供一个全局访问的接口, 可以获取已经创建好的单个实例instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>枚举单例</strong></li></ol><p><strong>特点</strong>: 简单, 线程安全, 防止反序列化导致创建新的实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式被破坏的情况">单例模式被破坏的情况</h3><p>除了枚举单例模式之外, 其他单例模式都可以被破坏. 破坏单例模式的方法有两种, 分别为 <strong>序列化</strong> 和 <strong>反射</strong></p><ol><li><strong>序列化破坏单例模式</strong></li></ol><p>因为在序列化和反序列化过程中, 会创建一个新的实例, 即使单例类在内存中有一个唯一的实例, 通过反序列化也能创建多个实例, 这样就破坏了单例模式的初衷</p><p>假设有一个单例类如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">instance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>破坏单例模式的场景</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;singleton.ser&quot;</span>));</span><br><span class="line">            out.writeObject(instance1);</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;singleton.ser&quot;</span>));</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> (Singleton) in.readObject();</span><br><span class="line">            in.close;</span><br><span class="line">            System.out.println(<span class="string">&quot;Instance 1 hash code: &quot;</span> + instance1.hashCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Instance 2 hash code: &quot;</span> + instance2.hashCode());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>SingletonDemo</code>, 发现 <code>instance1</code> 和 <code>instance2</code> 的哈希码并不相同, 说明它们是不同的实例, 这就破坏了单例模式</p><p>为了防止序列化破坏单例模式, 可以在单例类中定义 <code>readResolve</code> 方法, 这个方法在反序列化时会被调用, 返回当前的单例实例, 从而确保反序列化得到的始终是唯一的单例实例</p><p>改进之后的单例类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">instance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加readResolve方法</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 <code>SingletonDemo</code> , 发现 <code>instance1</code> 和 <code>instance2</code> 的哈希码是相同的, 因此它们是同一个实例, 单例模式没有被破坏.</p><ol start="2"><li><strong>反射破坏单例模式</strong></li></ol><p>因为反射允许我们访问私有构造方法, 从而构建多个对象, 这就违背了单例模式的初衷</p><p>假设有一个单例类如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>破坏单例模式的场景</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射创建新的实例</span></span><br><span class="line">            Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查两个实例是否相同</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Instance 1 hash code: &quot;</span> + instance1.hashCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Instance 2 hash code: &quot;</span> + instance2.hashCode());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>SingletonDemo</code>, 发现 <code>instance1</code> 和 <code>instance2</code> 的哈希码并不相同. 说明它们是不同的实例, 单例模式被破坏</p><p>为了防止反射破坏单例模式, 可以在构造方法中添加防御措施, 例如在构造方法中检测实例是否存在, 如果存在就抛出异常</p><p>改进之后的单例类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射创建新的实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Use getInstance() method to get the single instance of this class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 <code>SingletonDemo</code>, 发现反射创建实例的步骤会抛出异常, 阻止了反射破坏单例模式</p><hr><p>最近在学设计模式, 可能会高强度更新设计模式相关的技术博客. 对设计模式感兴趣的读者可以关注我的 <a href="https://blog.csdn.net/qq_73142349">CSDN Channel</a>, <a href="https://juejin.cn/user/288489975843930">掘金 Channel</a>,  <a href="https://yonagi04.github.io" title="原站点,推荐科学上网访问">我的个人博客网站</a> 或 <a href="https://yonagi.xyz" title="推荐国内用户访问">网站的镜像站点</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇博客已经介绍了设计模式及其设计原则, 在这篇博客中笔者会介绍一下单例模式, 也是最简单的一种设计模式&lt;/p&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;单例模式属于创建型模式. 它涉及到一个单一的类, 该类负责创建自己的对象, 同时确保只有单个对象被创建,</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简谈设计模式之设计原则</title>
    <link href="https://yonagi04.github.io/posts/2024/44853bcc7bfb/"/>
    <id>https://yonagi04.github.io/posts/2024/44853bcc7bfb/</id>
    <published>2024-07-08T19:46:50.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是软件工程中解决特定问题的通用解决方案。这些模式提供了设计结构和最佳实践，帮助开发者创建灵活、可重用和可维护的代码。</p><h2 id="设计模式分类">设计模式分类</h2><ul><li><strong>创建型模式</strong></li></ul><p>用于描述&quot;如何创建对象&quot;, 它的特点是“将对象的创建和使用分离”. 包括单例, 原型, 工厂方法, 抽象工厂, 建造者等创建型模式</p><ul><li><strong>结构型模式</strong></li></ul><p>用于描述如何将类或对象按照某种布局组成更大的结构. 包括代理, 适配器, 桥接, 装饰, 外观, 享元, 组合等结构型模式</p><ul><li><strong>行为型模式</strong></li></ul><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法独立完成的任务, 以及怎样分配职责. 包括模板方法, 策略, 命令, 职责链, 状态, 观察者, 中介者, 迭代器, 访问者, 备忘录, 解释器等行为型模式</p><h2 id="设计原则">设计原则</h2><h3 id="开闭原则">开闭原则</h3><p><strong>对拓展开放, 对修改关闭</strong>. 在程序需要拓展的时候, 不能去修改原有的代码, 而应该是利用接口或抽象类进行实现或继承, 使得程序的拓展性更好, 易于维护</p><p>对于接口或抽象类, 只要抽象得合理, 基本上可以保持架构的稳定, 而具体细节又可以通过抽象类派生的实现类或接口的实现类来拓展</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|      Shape          |</span><br><span class="line">+---------------------+</span><br><span class="line">| + draw(): void      |</span><br><span class="line">+---------------------+</span><br><span class="line">         /\</span><br><span class="line">         ||</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">|    Circle           |   |   Rectangle         |</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">| + draw(): void      |   | + draw(): void      |</span><br><span class="line">+---------------------+   +---------------------+</span><br></pre></td></tr></table></figure><h3 id="里氏代换原则">里氏代换原则</h3><p><strong>任何基类出现的地方, 子类一定可以出现</strong> . 即子类可以拓展父类的功能, 但是不能改变父类原有的功能, 子类除了增加新的方法完成新增功能外, 尽量不要重写父类方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|      Bird           |</span><br><span class="line">+---------------------+</span><br><span class="line">| + fly(): void       |</span><br><span class="line">+---------------------+</span><br><span class="line">         /\</span><br><span class="line">         ||</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">|   Sparrow           |   |   Ostrich           |</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">| + fly(): void       |   | + fly(): void       |</span><br><span class="line">+---------------------+   +---------------------+</span><br></pre></td></tr></table></figure><h3 id="单一职责原则">单一职责原则</h3><p><strong>每一个类都应该只有一个职责, 也就是每个类只负责一件事情</strong>. 有助于减少类之间的耦合, 提高代码的可读性和可维护性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">|   UserManager  |</span><br><span class="line">+----------------+</span><br><span class="line">| - addUser()    |</span><br><span class="line">| - removeUser() |</span><br><span class="line">| - updateUser() |</span><br><span class="line">+----------------+</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><h3 id="依赖倒转原则">依赖倒转原则</h3><p><strong>高层模块不应该依赖低层模块, 两者都应该依赖于其抽象; 抽象不应该依赖于细节, 细节应该依赖于抽象</strong>. 有助于减少模块之间的耦合，增强系统的灵活性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|      Service        |</span><br><span class="line">+---------------------+</span><br><span class="line">| + operation(): void |</span><br><span class="line">+---------------------+</span><br><span class="line">         /\</span><br><span class="line">         ||</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">|   ConcreteServiceA  |   |   ConcreteServiceB  |</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">| + operation(): void |   | + operation(): void |</span><br><span class="line">+---------------------+   +---------------------+</span><br></pre></td></tr></table></figure><h3 id="接口隔离原则">接口隔离原则</h3><p><strong>客户端不应该强迫依赖于它们不使用的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|  IShape             |</span><br><span class="line">+---------------------+</span><br><span class="line">| + draw(): void      |</span><br><span class="line">+---------------------+</span><br><span class="line">+---------------------+</span><br><span class="line">|  IColorable         |</span><br><span class="line">+---------------------+</span><br><span class="line">| + color(): void     |</span><br><span class="line">+---------------------+</span><br><span class="line">         /\</span><br><span class="line">         ||</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">|   Square            |   |   Circle            |</span><br><span class="line">+---------------------+   +---------------------+</span><br><span class="line">| + draw(): void      |   | + draw(): void      |</span><br><span class="line">| + color(): void     |   | + color(): void     |</span><br><span class="line">+---------------------+   +---------------------+</span><br></pre></td></tr></table></figure><h3 id="组合优于继承">组合优于继承</h3><p><strong>优先通过组合而不是继承来达到复用代码的目的</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|   Engine            |</span><br><span class="line">+---------------------+</span><br><span class="line">| + start(): void     |</span><br><span class="line">+---------------------+</span><br><span class="line">         ||</span><br><span class="line">         ||</span><br><span class="line">+---------------------+</span><br><span class="line">|    Car              |</span><br><span class="line">+---------------------+</span><br><span class="line">| - engine: Engine    |</span><br><span class="line">| + start(): void     |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="迪米特原则">迪米特原则</h3><p><strong>一个对象应该对其他对象有最少的了解</strong>. 每个模块不应该知道其他模块的内部细节, 对象之间应当通过严格定义的接口进行交互, 而不应该直接访问其他对象的内部结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|      Customer       |</span><br><span class="line">+---------------------+</span><br><span class="line">| + getName(): String |</span><br><span class="line">+---------------------+</span><br><span class="line">         ||</span><br><span class="line">         ||</span><br><span class="line">+---------------------+</span><br><span class="line">|      Order          |</span><br><span class="line">+---------------------+</span><br><span class="line">| - customer: Customer|</span><br><span class="line">| + getCustomerName():|</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="避免重复原则">避免重复原则</h3><p><strong>每一项知识在系统中都应该有一个唯一的、明确的、权威的表示</strong>. 目的是为了避免代码重复, 通过抽象和封装来减少冗余代码, 提高系统的可维护性和可拓展性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|    UserService      |</span><br><span class="line">+---------------------+</span><br><span class="line">| - validateUser()    |</span><br><span class="line">| - saveUser()        |</span><br><span class="line">+---------------------+</span><br><span class="line">         /\</span><br><span class="line">         ||</span><br><span class="line">+----------------------------+     +---------------------+</span><br><span class="line">|  UserController            |     |  UserRepository     |</span><br><span class="line">+----------------------------+     +---------------------+</span><br><span class="line">| - userService: UserService |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;设计模式是软件工程中解决特定问题的通用解决方案。这些模式提供了设计结构和最佳实践，帮助开发者创建灵活、可重用和可维护的代码。&lt;/p&gt;
&lt;h2 id=&quot;设计模式分类&quot;&gt;设计模式分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="设计模式" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://yonagi04.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>暑假开始</title>
    <link href="https://yonagi04.github.io/posts/2024/e9024bb749c1/"/>
    <id>https://yonagi04.github.io/posts/2024/e9024bb749c1/</id>
    <published>2024-07-06T09:24:36.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>暑假开始了</p><p>这应该是我最后一年能这么悠闲地在家里过暑假。明年不管是选择考研还是选择去找工作都不可能待在家里舒舒服服地过暑假了。</p><p>下学期我就是大三生了。感觉日子过得非常快，仿佛昨天还是高考刚放榜，前天还是我刚去读高中。</p><hr><p>我从初中开始就一直保留着写点东西的习惯——高中时候达到了顶峰（因为高中时候没有什么娱乐方式），然后这个习惯一直延续到了现在，比如说我发表在这个网站上面的博客。我偶尔会把我高中时候写的东西翻出来看一下，看着这些东西感觉就像是昨天——这篇昨天刚写，这件事情昨天才发生……很奇妙的感觉。时间流淌的速度实在是太快了，以至于普通人根本就抓不住</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;暑假开始了&lt;/p&gt;
&lt;p&gt;这应该是我最后一年能这么悠闲地在家里过暑假。明年不管是选择考研还是选择去找工作都不可能待在家里舒舒服服地过暑假了。&lt;/p&gt;
&lt;p&gt;下学期我就是大三生了。感觉日子过得非常快，仿佛昨天还是高考刚放榜，前天还是我刚去读高中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我从</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>二次元新游品鉴之鸣潮与学园偶像大师</title>
    <link href="https://yonagi04.github.io/posts/2024/e00baa2d954d/"/>
    <id>https://yonagi04.github.io/posts/2024/e00baa2d954d/</id>
    <published>2024-05-25T09:23:17.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>这几天我个人比较关注的两个二次元新游戏——一个是鸣潮，一个是之前发过的学园偶像大师——两个游戏都开服了，都经过了一段时间的品鉴，今天简单写写游玩体验</p><p>先说鸣潮</p><p>我游玩的版本是PC端，配置是7735H + 4060. 鸣潮游戏画面设置为全高，帧率限制设置为60帧（不知道为什么，pc端都卡60帧），根据小飞机的检测，跑图过程中全程帧率稳定在60帧，显卡占用40%左右，显存占用50%，没有出现卡顿掉帧或者远景比较模糊的情况。至于建模问题我也没有碰到，可能是我运气比较好吧。但是这个游戏还是有特别多的槽点：首先第一个就是我最难以接受的——没法跳剧情，或者说一部分剧情能跳，一部分则不能跳。我不是剧情党，所以我不怎么关注二次元游戏的剧情，只要玩法足够出彩就行了。但是这个游戏没法跳剧情，和原神一样（库洛的游戏剧本策划你也觉得跳过剧情=跳过人生吗？）本来就没法跳剧情了，剧情要是有意思倒是无所谓，但是鸣潮的剧情是真的无聊啊，我第一章的剧情都走完了，愣是不知道现在主角（漂泊者）到底要干什么，除了出现了一个反派和我们的主角battle了一下，其他的剧情我只能说简直是无聊透顶，包括反派和主角battle之前的文戏。第二个我不能接受的就是没有“一键获取”的按钮。我记得战双里面是有这个功能的啊，为什么鸣潮就把这个功能阉割掉了（和鹰角的明日方舟早期版本一样，也没有一键获取按钮，但鹰角后来加上去了），难道是鸣潮的策划觉得让玩家一个一个点完成的任务是很有意思的事情吗？打斗的话个人感觉一般，我甚至感觉手感还不如战双，更别提原神了</p><p>再说学园偶像大师</p><p>优点是剧情很好看，这个之前说过了，不再赘诉。</p><p>不过也有缺点，就是整个produce的流程太长了，节奏很慢，一把打下来至少也得30分钟了，放在中国这种快节奏的环境下可能是行不通的。玩法和赛马娘比较接近，当然也一样的坐牢，没卡没练度就等着寄</p><p>大概就是这样吧，个人对于这两个游戏的评价就是上面这些</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天我个人比较关注的两个二次元新游戏——一个是鸣潮，一个是之前发过的学园偶像大师——两个游戏都开服了，都经过了一段时间的品鉴，今天简单写写游玩体验&lt;/p&gt;
&lt;p&gt;先说鸣潮&lt;/p&gt;
&lt;p&gt;我游玩的版本是PC端，配置是7735H + 4060. 鸣潮游戏画面设置为全高，帧率限</summary>
      
    
    
    
    <category term="游戏" scheme="https://yonagi04.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="二次元游戏" scheme="https://yonagi04.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83%E6%B8%B8%E6%88%8F/"/>
    
    <category term="学園アイドルマスター" scheme="https://yonagi04.github.io/tags/%E5%AD%A6%E5%9C%92%E3%82%A2%E3%82%A4%E3%83%89%E3%83%AB%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC/"/>
    
    <category term="鸣潮" scheme="https://yonagi04.github.io/tags/%E9%B8%A3%E6%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>JUC专题——Java中的锁</title>
    <link href="https://yonagi04.github.io/posts/2024/b64cc63dd695/"/>
    <id>https://yonagi04.github.io/posts/2024/b64cc63dd695/</id>
    <published>2024-05-19T12:49:35.000Z</published>
    <updated>2025-05-18T09:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自《Java并发编程的艺术》</strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a> → 😋<a href="https://yonagi04.github.io/posts/2024/b64cc63dd695/">JUC专题3</a></p></blockquote><h1>Lock接口</h1><p>锁是用来控制多个线程访问共享资源的方式, 一般来说, 一个锁能够防止多个线程同时访问共享资源 (但是有些锁可以允许多个线程并发的访问共享资源, 比如读写锁)</p><p>使用 <code>synchronized</code> 关键字将会隐式地获得锁, 但是它将锁的获取和释放固化了, 也就是先获取再释放. 当然这种方式简化了同步的管理, 可是扩展性没有显式地获取和释放来的好</p><h1>队列同步器</h1><p><strong>队列同步器</strong> 是用来构建锁或者其他同步组件的基础框架, 使用一个 int 成员变量表示同步状态, 通过内置的FIFO队列来完成资源获取线程的排队工作</p><p>同步器的主要使用方式是继承, 子类通过继承同步器并实现它的抽象方法来管理同步状态, 在抽象方法的实现过程中免不了要对同步状态进行过呢更改, 这时候就需要使用同步器提供的 3 个方法(<code>getState()</code> , <code>setState(int state)</code> , <code>compareAndSetState(int expect, int update)</code>) 来进行操作, 因为它们能够保证状态的改变是安全的</p><h2 id="队列同步器的接口">队列同步器的接口</h2><p>重写同步器指定的方法时, 需要使用同步器提供的如下 3 个方法来访问或修改同步状态</p><ul><li><code>getState()</code> : 获取同步状态</li><li><code>setState()</code> : 设置当前同步状态</li><li><code>compareAndSetState()</code> : 使用CAS设置当前状态, 该方法能够保证状态设置的原子性</li></ul><p>同步器可重写的方法如下</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>protected boolean tryAcquire(int arg)</code></td><td>独占式获取同步状态, 实现该方法需要查询当前状态并判断同步状态是否符合预期, 然后再进行CAS设置同步状态</td></tr><tr><td><code>protected boolean tryRelease(int arg)</code></td><td>独占式释放同步状态, 等待获取同步状态的线程将会有机会获取同步状态</td></tr><tr><td><code>protected int tryAcquireShared(int arg)</code></td><td>共享式获取同步状态, 返回大于等于0 的值, 表示获取成功, 反之, 获取失败</td></tr><tr><td><code>protected boolean tryReleaseShared(int arg)</code></td><td>共享式释放同步状态</td></tr><tr><td><code>protected boolean isHeldExclusively()</code></td><td>当前同步器是否在独占模式下被线程占用, 一般该方法表示是否被当前线程所独占</td></tr></tbody></table><p>实现自定义同步组件时, 将会调用同步锁的模板方法</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>void acquire(int arg)</code></td><td>独占式获取同步状态, 如果当前线程获取同步状态成功, 则由该方法返回, 否则, 将会进入同步队列等待, 该方法将会调用重写的 <code>tryAcquire(int arg)</code> 方法</td></tr><tr><td><code>void acquireInterruptibly(int arg)</code></td><td>与 <code>acquire(int arg)</code> 相同, 但是该方法响应中断, 当前线程未获取到同步状态而进入同步队列中, 如果当前线程被中断, 则该方法会抛出 <code>InterruptedException</code> 并返回</td></tr><tr><td><code>boolean tryAcquireNanos(int arg, long nanos)</code></td><td>在<code>acquireInterruptibly(int arg)</code> 基础上增加了超时限制, 如果在超时限制内没有获取到同步状态, 则返回 <code>false</code>, 否则返回 <code>true</code></td></tr><tr><td><code>void acquireShared(int arg)</code></td><td>共享式的获取同步状态, 如果当前线程未获取到同步状态, 将会进入同步队列等待, 与独占式获取的主要区别是同一时刻可以有多个线程获取到同步状态</td></tr><tr><td><code>void acquireSharedInterruptibly(int arg)</code></td><td>与 <code>acquireShared(int arg)</code> 一样, 该方法响应中断</td></tr><tr><td><code>boolean tryAcquireSharedNanos(int arg, long nanos)</code></td><td>在 <code>acquireSharedInterruptibly(int arg)</code> 的基础上增加了超时限制</td></tr><tr><td><code>boolean release(int arg)</code></td><td>独占式的释放同步状态, 该方法会在释放同步状态之后, 将同步队列中第一个节点包含的线程唤醒</td></tr><tr><td><code>boolean releaseShared(int arg)</code></td><td>共享式的释放同步状态</td></tr><tr><td><code>Collection&lt;Thread&gt; getQueuedThreads()</code></td><td>获取等待在同步队列上的线程集合</td></tr></tbody></table><h2 id="队列同步器的实现分析">队列同步器的实现分析</h2><h3 id="同步队列">同步队列</h3><p>同步器依赖于内部的同步队列来完成同步状态的管理, 当前线程获取同步状态失败时, 同步器会将当前线程及其等待状态等信息构造成一个节点并将其加入到同步队列, 同时会阻塞当前线程, 当同步状态释放时, 会把首节点中的线程唤醒, 使其再次尝试获取同步状态</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/node.webp" alt=""></p><p>节点是构成同步队列的基础, 同步器具有头节点(head)和尾节点(tail), 没有成功获取同步状态的线程将会成为节点加入该队列的尾部, 同步队列的基本结构如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.4/img/content/sync-queue.webp" alt=""></p><p>同步器将节点加入到同步队列的过程如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.4/img/content/add-sync-queue.webp" alt=""></p><p>同步队列遵循FIFO, 首节点是同步状态获取成功的节点, 首节点的线程在释放同步状态时, 会唤醒后继节点, 而后继节点将会在获取同步状态成功时将自己设置为首节点</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.4/img/content/headnode.webp" alt=""></p><p>设置首节点是通过获取同步状态成功的线程来完成的, 由于只有一个线程能够成功获取到同步状态, 因此设置头节点的方法不需要用CAS来保证, 它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可</p><h3 id="独占式同步状态获取与释放">独占式同步状态获取与释放</h3><p>通过调用同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态, 该方法对中断不敏感, 也就是由于线程获取同步状态失败后进入同步队列中, 后续对线程进行中断操作时, 线程不会从同步队列中移出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的acquire方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的addWaiter和enq方法</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Ndoe <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">            t.next = node;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点进入同步队列之后, 就进入了自旋, 每个节点都在自省地观察, 当条件满足, 获取到了同步状态, 就从自旋状态中退出, 否则依旧留在自旋过程中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的acquireQueued方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>acquireQueued(final Node node, int arg)</code> 方法中, 当前线程在&quot;死循环&quot;中尝试获取同步状态, 而只有头节点才能尝试获取同步状态, 为什么?</p><ol><li>头节点是成功获取到同步状态的节点, 而头节点的线程释放了同步状态之后, 将会唤醒后续节点, 后续节点的线程被唤醒之后需要检查自己的前驱节点是不是头节点</li><li>维护同步队列的FIFO原则, 该方法中, 节点自旋获取同步状态的行为如图所示</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.4/img/content/get-sync-status.webp" alt=""></p><p>节点与节点之间在循环检查的过程中基本不相互通信, 而是简单的判断自己的前驱节点是否为头节点, 这样就使得节点的释放规则符合FIFO, 并且也便于对过早通知的处理(过早通知是指前驱节点不是头节点的节点由于中断而被唤醒)</p><p>独占式同步状态获取流程如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.5/img/content/exclusive-sync-state.webp" alt=""></p><p>当前线程获取同步状态并执行了相应逻辑之后, 就需要释放同步状态, 使得后续节点能够继续获取同步状态, 通过调用同步器的 <code>release(int arg)</code> 方法可以释放同步状态, 该方法在释放了同步状态之后, 会唤醒其后续节点(进而使后续节点重新尝试获取同步状态)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的release方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结: 在获取同步状态时, 同步器维护一个同步队列, 获取同步状态失败的线程都会被加入到队列中并进行自旋; 移出队列的前提是前驱节点为头节点且能够获取到同步状态. 在释放同步状态时, 同步器调用 <code>tryRelease(int arg)</code> 方法释放同步状态, 然后唤醒头节点的后续节点</p><h3 id="共享式同步状态获取与释放">共享式同步状态获取与释放</h3><p>共享式获取与独占式获取最大的区别在于同一时刻是否能有多个线程同时获取到同步状态.</p><p>通过调用同步器的 <code>acquireShared(int arg)</code> 方法可以共享式地获取到同步状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步器的acquiredShared和doAcquireShared方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = NULL;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                   failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享式获取也需要释放同步状态, 通过调用 <code>releaseShared(int arg)</code> 方法可以释放同步状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独占式超时获取同步状态">独占式超时获取同步状态</h3><p>通过调用同步器的 <code>doAcquireNanos(int arg, long nanoTimeout)</code> 方法可以超时获取同步状态, 即在指定的时间段内获取同步状态, 如果获取到同步状态则返回 true, 否则, 返回 false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanoTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">          <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = out;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>独占式超时获取同步状态的过程如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.9/img/content/exclusive-timeout-sync-state.webp" alt=""></p><h1>重入锁</h1><p>重入锁 ReentrantLock, 顾名思义就是支持重进入的锁,它表示该锁能够支持一个线程对资源的重复加锁. 除此之外还支持获取锁时的公平和非公平性选择</p><p>ReentrantLock虽然没像synchronized关键字一样支持隐式的重进入, 但是在调用 <code>lock()</code> 方法时, 已经获取到锁的进程, 能够再次调用 <code>lock()</code> 方法获取锁而不被阻塞</p><h2 id="实现重进入">实现重进入</h2><p><strong>重进入</strong>是指任意线程在获得到锁之后能够再次获取到锁而不会被阻塞</p><p>ReentrantLock通过组合自定义同步器来实现锁的获取和释放. 以非公平性实现为例, 获取同步状态的代码如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAnsSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功获取锁的线程再次获取锁, 只是增加了同步状态值, 这也就要求 ReentrantLock在释放同步状态时减少同步状态值, 该方法的代码如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平与非公平获得锁的区别">公平与非公平获得锁的区别</h2><p>如果一个锁是公平的, 那么锁的获取顺序就应该符合请求的绝对时间顺序</p><p>公平锁的获取同步状态代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁可能导致线程&quot;饥饿&quot;, 但是极少的线程切换保证了更大的吞吐量</p><h1>读写锁</h1><p>读写锁在同一时刻允许多个读线程访问, 但是在写线程访问时, 其他的读线程和写线程都会被阻塞. 读写锁维护了一个读锁和一个写锁, 通过分离读锁和写锁, 使得并发性相比一般的排他锁有很大的提升</p><p>一般情况下读写锁的性能比排他锁要好, 这是因为大多数场景是读大于写的. 在读大于写的情况下, 读写锁能够提供比排他锁更好的并发性和吞吐量. Java实现读写锁是 ReentrantReadWriteLock, 它的特性如下</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>公平性选择</td><td>支持非公平(默认)与公平的锁获取方式, 吞吐量非公平优于公平</td></tr><tr><td>重进入</td><td>该锁支持重进入, 以读写线程为例: 读线程获取读锁后能够再次获取读锁, 写线程获取写锁之后能够再次获得写锁, 也能获得读锁</td></tr><tr><td>锁降级</td><td>遵循获取写锁, 获取读锁再释放写锁的次序, 写锁能够降级为读锁</td></tr></tbody></table><h2 id="读写锁的接口">读写锁的接口</h2><p>ReadWriteLock仅定义了获取读锁与写锁的两个方法, 即 <code>readLock()</code> 方法和 <code>writeLock()</code> 方法, 而其实现 <code>ReentrantReadWriteLock</code> , 除了接口方法外还提供了一些便于外界监控其内部工作状态的方法</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>int getReadLockCount()</td><td>返回当前读锁被获取的次数. 该次数不等于获取读锁的线程数</td></tr><tr><td>int getReadHoldCount()</td><td>返回当前线程获取读锁的次数</td></tr><tr><td>boolean isWriteLocked()</td><td>判断写锁是否被获取</td></tr><tr><td>int getWriteHoldCount()</td><td>返回当前写锁被获取的次数</td></tr></tbody></table><h2 id="读写锁的实现分析">读写锁的实现分析</h2><h3 id="读写状态的设计">读写状态的设计</h3><p>读写锁依赖于自定义同步器来实现同步功能, 而读写状态就是其同步器的同步状态.</p><p>读写锁的自定义同步器需要在同步状态(一个整型变量)上维护多个读线程和一个写线程的状态, 使得该状态的设计成为读写锁实现的关键</p><p>如果在一个整型变量上维护多种状态, 就一定需要 “按位切割使用” 这个变量, 读写锁将变量切分成了两个部分, 高16位表示读, 低16位表示写</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.9/img/content/read-write-lock-state-divide.webp" alt=""></p><p>假设当前同步状态为S, 当S不等于0时, 当写状态 (S &amp; 0x0000FFFF) 等于 0 时, 则读状态 (S &gt;&gt;&gt; 16) 大于 0, 即读锁已被获取</p><h3 id="写锁的获取和释放">写锁的获取和释放</h3><p>写锁是一个支持重进入的排它锁. 如果当前线程已经获取到了写锁, 则增加写状态. 如果当前线程在获取写锁时, 读锁已经被获取或者该线程不是已经获取到写锁的线程, 那么该线程进入等待状态</p><p>获取写锁的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放和ReentrantLock的释放过程基本类似, 每次释放都减少写状态, 当写状态为 0 时表示写锁已被释放, 从而等待的读写线程可以继续访问写锁, 同时前次写线程的修改对后续线程是可见的</p><h3 id="读锁的获取和释放">读锁的获取和释放</h3><p>读锁是一个支持重进入的共享锁, 它能够被多个线程同时获取, 在没有其他写线程访问时, 读锁总能成功获取到. 如果当前线程已经获取到了读锁, 则增加读状态. 如果当前线程在试图获取读锁时, 写锁已经被其他线程获取, 则该线程进入等待状态</p><p>获取读锁的代码如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁降级">锁降级</h3><p>锁降级是指写锁降级为读锁. 具体来讲, 锁降级是指把持住当前拥有的写锁, 然后获取读锁, 最后在释放写锁的过程</p><p>锁降级中是否有必要获取读锁? 答案是必要的, 目的是为了数据的可见性. 如果一个线程不获取读锁而直接释放了写锁, 此时若另外一个线程获取到了写锁并修改了数据, 当前线程就无法感知到数据另一个线程的数据更新. 假设当前线程获取了读锁, 遵循锁降级的步骤, 另一个试图获取写锁的线程就会被阻塞, 直到当前线程使用完数据并释放掉读锁之后, 另一个线程才能获取到写锁进行更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自《Java并发编程的艺术》&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🚀 &lt;a href=&quot;https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/&quot;&gt;基础（上）&lt;/a&gt; → </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一周的开始，随便写写</title>
    <link href="https://yonagi04.github.io/posts/2024/b5d65469501c/"/>
    <id>https://yonagi04.github.io/posts/2024/b5d65469501c/</id>
    <published>2024-05-13T11:31:58.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>昨天去琶洲吃麵屋猪一，一家日本的拉面店。店子特别小，和日剧里面经常能看到的拉面店差不多大，估摸着50平方不到的小屋子，装修是完完全全的日式风格。我是在美团上面买的套餐，38块钱，一碗拉面+中华海草（类似于海带丝，但是是甜口）。拉面就是很正常的日式拉面——猪骨汤底，猪肩肉，溏心蛋，葱花，还有面。拉面倒是普普通通，个人感觉汤底不错，但除了汤底之外的其他东西都感觉很一般，自己在家都能做出来。我加了一次面，吃得特别饱。这日式拉面虽然看着量不算多，但吃起来还真不算少的</p><p>吃完就慢悠悠走回地铁站，坐地铁回学校。坐地铁到大学城北站，出站之后一个外国佬拦住了我，问我怎么开美团单车。我只能告诉他怎么开锁。“Tap this, and scan this qr code&quot;巴拉巴拉。最后成功地被有中国特色的身份验证环节卡了。这逼养的感觉像是偷渡过来的，连外国人居留卡都没有。我不知道外国人居留卡怎么说，就只能用翻译软件，结果这逼养的也听不懂。最后只能问我能不能帮他开锁，他说他住得不远，五分钟就能到。我就只能帮他扫了码开了锁，目送这byd离开地铁站</p><p>坐上公交车，我反手就把车给锁了。结果一看车的定位，华南师大。闹麻了，华师大的留学生连中文都看不懂，甚至最基本的中文都不会说，说着一口蹩脚的英语（对没错这逼样的英语连都说不好，不过我也是半斤八两就是了）就来中国留学了。反观一下日本，如果不是旅游签的话，日语不过关连签证都会被卡（经常会出现去日本语言学校留学的学生因为电话调研被发现日语不过关而导致签证申请被拒绝）。美国就更不用说了。中国对外国公民的签证条件是不是太宽松了啊？</p><hr><p>明天电信院20级的师兄师姐拍毕业照。想到自己居然已经大二下学期了，马上就要准备找工作或者考研。但是我其实一直没想好以后到底是找工作，还是考研。一方面是感觉自己的技术应该能找到一份看得下去的工作（应该吧），另一方面是考研了也要被导师压榨</p><p>唉，实习都找不到，下学期初一定要找到了，要不然真的没时间了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天去琶洲吃麵屋猪一，一家日本的拉面店。店子特别小，和日剧里面经常能看到的拉面店差不多大，估摸着50平方不到的小屋子，装修是完完全全的日式风格。我是在美团上面买的套餐，38块钱，一碗拉面+中华海草（类似于海带丝，但是是甜口）。拉面就是很正常的日式拉面——猪骨汤底，猪肩肉，溏</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="琐事" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/%E7%90%90%E4%BA%8B/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>美团2024年春招第一场笔试【技术类】 个人题解</title>
    <link href="https://yonagi04.github.io/posts/2024/06587ef49924/"/>
    <id>https://yonagi04.github.io/posts/2024/06587ef49924/</id>
    <published>2024-05-12T13:27:58.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下题解为个人题解，不提供具体思路，仅提供题解代码。本题解使用的编程语言为C++。本次笔试为模拟测试，得分79/100，ac数3/5。题解内容仅供参考</strong></p><h1>美团2024年春季校园招聘 第一场笔试【技术类】 题解（C++）</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/70/v2-6e12abf18ff2b83f47ee63825572016a_1440w.image?source=172ae18b&amp;biz_tag=Post" alt="美团0309春招第一场笔试"></p><h2 id="T1-小美的平衡矩阵">T1. 小美的平衡矩阵</h2><p>小美拿到了一个𝑛∗𝑛的矩阵，其中每个元素是 0 或者 1。<br>小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。<br>现在，小美希望你回答有多少个𝑖∗𝑖的完美矩形区域。你需要回答1≤𝑖≤𝑛的所有答案。</p><p>时间限制：C/C++ 1秒，其他语言2秒</p><p>空间限制：C/C++ 256M，其他语言512M</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入一个正整数n，代表矩阵大小。</span><br><span class="line">接下来的n行，每行输入一个长度为n的 01 串，用来表示矩阵。</span><br><span class="line">1 &lt;= n &lt;= 200</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出n行，第i行输出i*i的完美矩形区域的数量。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1010</span><br><span class="line">0101</span><br><span class="line">1100</span><br><span class="line">0011</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">7</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> s[N][N], ans[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            s[i][j] = g[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k - <span class="number">1</span> &lt;= n &amp;&amp; j + k - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">                    <span class="type">int</span> x = <span class="built_in">get</span>(i, j, i + k - <span class="number">1</span>, j + k - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (x * <span class="number">2</span> == k * k) &#123;</span><br><span class="line">                        ans[k]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T2-小美的数组询问">T2. 小美的数组询问</h2><p>小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用 0 来表示）。<br>现在小美想知道，如果那些未知的元素在区间[𝑙,𝑟][<em>l</em>,<em>r</em>]范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？<br>共有𝑞次询问。</p><p>时间限制：C/C++ 1秒，其他语言2秒</p><p>空间限制：C/C++ 256M，其他语言512M</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入两个正整数n, q，代表数组大小和询问次数。</span><br><span class="line">第二行输入n个整数ai，其中如果输入的ai为 0，那么说明是未知的。</span><br><span class="line">接下来的q行，每行输入两个正整数l, r ，代表一次询问。</span><br><span class="line">1 &lt;= n, q &lt;= 1e5</span><br><span class="line">0 &lt;= ai &lt;= 1e9</span><br><span class="line">1 &lt;= l &lt;= r &lt;= 1e9</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出q行，每行输出两个正整数，代表所有元素之和的最小值和最大值。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 0 3</span><br><span class="line">1 2</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">8 8</span><br></pre></td></tr></table></figure><p>例子说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只有第二个元素是未知的。</span><br><span class="line">第一次询问，数组最小的和是 1+1+3=5，最大的和是 1+2+3=6。</span><br><span class="line">第二次询问，显然数组的元素和必然为 8。</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    ll a[maxn];</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; sum + cnt * l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; sum + cnt * r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="T3-小美的MT">T3. 小美的MT</h2><p>MT 是美团的缩写，因此小美很喜欢这两个字母。<br>现在小美拿到了一个仅由大写字母组成字符串，她可以最多操作𝑘次，每次可以修改任意一个字符。小美想知道，操作结束后最多共有多少个’M’和’T’字符？</p><p>时间限制：C/C++ 1秒，其他语言2秒</p><p>空间限制：C/C++ 256M，其他语言512M</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入两个正整数n, k，代表字符串长度和操作次数。</span><br><span class="line">第二行输入一个长度为n的、仅由大写字母组成的字符串。</span><br><span class="line">1 &lt;= k &lt;= n &lt;= 1e5</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出操作结束后最多共有多少个&#x27;M&#x27;和&#x27;T&#x27;字符。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">MTUAN</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>例子说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改第三个和第五个字符，形成的字符串为 MTTAM，这样共有 4 个&#x27;M&#x27;和&#x27;T&#x27;。</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;M&#x27;</span> || s[i] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt + <span class="built_in">min</span>(k, n - cnt) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T4-小美的朋友关系">T4. 小美的朋友关系</h2><p>小美认为，在人际交往中，但是随着时间的流逝，朋友的关系也是会慢慢变淡的，最终朋友关系就淡忘了。<br>现在初始有一些朋友关系，存在一些事件会导致两个人淡忘了他们的朋友关系。小美想知道某一时刻中，某两人是否可以通过朋友介绍互相认识？<br>事件共有 2 种：<br>1 u v：代表编号 u 的人和编号 v 的人淡忘了他们的朋友关系。<br>2 u v：代表小美查询编号 u 的人和编号 v 的人是否能通过朋友介绍互相认识。</p><p>注：介绍可以有多层，比如 2 号把 1 号介绍给 3 号，然后 3 号再把 1 号介绍给 4 号，这样 1 号和 4 号就认识了。</p><p>时间限制：C/C++ 1秒，其他语言2秒</p><p>空间限制：C/C++ 256M，其他语言512M</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入三个正整数n, m, q，代表总人数，初始的朋友关系数量，发生的事件数量。</span><br><span class="line">接下来的m行，每行输入两个正整数u, v，代表初始编号的人u和编号的人v是朋友关系。</span><br><span class="line">接下来的q行，每行输入三个正整数op, u, v，含义如题目描述所述。</span><br><span class="line">1 &lt;= n &lt;= 1e9</span><br><span class="line">1 &lt;= m, q &lt;= 1e5</span><br><span class="line">1 &lt;= u, v &lt;= n</span><br><span class="line">1 &lt;= op &lt;= 2</span><br><span class="line">保证至少存在一次查询操作。</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每次 2 号操作，输出一行字符串代表查询的答案。如果编号 u 的人和编号 v 的人能通过朋友介绍互相认识，则输出&quot;Yes&quot;。否则输出&quot;No&quot;。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">1 1 5</span><br><span class="line">2 1 3</span><br><span class="line">2 1 4</span><br><span class="line">1 1 2</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>例子说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次事件，1 号和 5 号本来就不是朋友，所以无事发生。</span><br><span class="line">第二次事件是询问，1 号和 3 号可以通过 2 号的介绍认识。</span><br><span class="line">第三次事件是询问，显然 1 号和 4 号无法互相认识。</span><br><span class="line">第四次事件，1 号和 2 号淡忘了。</span><br><span class="line">第五次事件，此时 1 号无法再经过 2 号和 3 号互相认识了。</span><br></pre></td></tr></table></figure><hr><p>本题未AC。但是读者可以根据我提供的思路尝试完成本题：本题实际上要求使用并查集，需要考虑离散化+离线处理，并且要考虑重边的情况</p><hr><h2 id="T5-小美的区间删除">T5. 小美的区间删除</h2><p>小美拿到了一个大小为𝑛的数组，她希望删除一个区间后，使得剩余所有元素的乘积末尾至少有𝑘个 0。小美想知道，一共有多少种不同的删除方案？</p><p>时间限制：C/C++ 1秒，其他语言2秒</p><p>空间限制：C/C++ 256M，其他语言512M</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行输入两个正整数n, k。</span><br><span class="line">第二行输入n个正整数ai，代表小美拿到的数组。</span><br><span class="line">1 &lt;= n, k &lt;= 1e5</span><br><span class="line">1 &lt;= ai &lt;= 1e9</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个整数，代表删除的方案数。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">2 5 3 4 20</span><br></pre></td></tr></table></figure><p>输出例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>例子说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个方案，删除[3]。</span><br><span class="line">第二个方案，删除[4]。</span><br><span class="line">第三个方案，删除[3,4]。</span><br><span class="line">第四个方案，删除[2]。</span><br></pre></td></tr></table></figure><hr><p>本题未完全ac，通过样例数19/20</p><p>读者可根据下面的参考代码，修改参考代码并尝试完成本题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[maxn], cnt2[maxn], cnt5[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x % p == <span class="number">0</span>) &#123;</span><br><span class="line">        x /= p;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io</span>();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> c2 = <span class="number">0</span>, c5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt2[i] = <span class="built_in">get</span>(a[i], <span class="number">2</span>);</span><br><span class="line">        cnt5[i] = <span class="built_in">get</span>(a[i], <span class="number">5</span>);</span><br><span class="line">        c2 += cnt2[i];</span><br><span class="line">        c5 += cnt5[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">        c2 -= cnt2[r];</span><br><span class="line">        c5 -= cnt5[r];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">min</span>(c2, c5) &lt; k) &#123;</span><br><span class="line">            c2 += cnt2[l];</span><br><span class="line">            c5 += cnt5[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;以下题解为个人题解，不提供具体思路，仅提供题解代码。本题解使用的编程语言为C++。本次笔试为模拟测试，得分79/100，ac数3/5。题解内容仅供参考&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;美团2024年春季校园招聘 第一场笔试【技术类】 题解（C++）&lt;/h1</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
    <category term="笔试" scheme="https://yonagi04.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.10</title>
    <link href="https://yonagi04.github.io/posts/2024/8911072fd646/"/>
    <id>https://yonagi04.github.io/posts/2024/8911072fd646/</id>
    <published>2024-05-10T10:23:40.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc123-买卖股票的最佳时机-III（HD）">lc123. 买卖股票的最佳时机 III（HD）</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^5</code></li></ul><hr><p>完成交易的次数是有限的，且次数相对较少，所以比股票IV简单</p><p>能确定的五种状态分别是：</p><ul><li>还没有买过股票</li><li>第一次买了股票，但是没有卖出</li><li>第一次卖出股票</li><li>第一次卖出股票后，再次买入股票</li><li>第二次卖出股票</li></ul><p>显然，第一个状态的利润为 0，因此我们不记录。我们将后面四个状态分别记录为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">buy_1,sell_1,buy_2,sell_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">buy_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天，我们可以不买入股票，也可以以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">price[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ce</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的价格买入股票。此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">buy_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的状态转移方程为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">buy_1 = max(buy_1&#x27;, -prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></p><p>这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">buy_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天的状态，主要和第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天做区分，下文同理</p><p>针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">sell_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 对于第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天，我们可以卖出手里的股票，也可以不卖出。此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">sell_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的状态转移方程为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><msubsup><mi>l</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sell_1 = max(sell_1&#x27;, buy_1&#x27; + prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></p><p>同理可得，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">buy_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">sell_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的状态转移方程应该为</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>l</mi><msubsup><mi>l</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">buy_2 = max(buy_2&#x27;, sell_1&#x27; - prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><msubsup><mi>l</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo separator="true">,</mo><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sell_2 = max(sell_2&#x27;, buy_2&#x27; + prices[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></p><p>在考虑边界条件时，应当注意到：<strong>无论题目中是否允许 “在同一天买入并且在同一天卖出” 这一操作，最终答案都不会受到影响，因为这一操作带来的收益为0</strong></p><p>因此总的状态转移方程是</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>b</mi><mi>u</mi><msub><mi>y</mi><mn>2</mn></msub><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}buy_1 = max(buy_1, -prices[i]) \\sell_1 = max(sell_1, buy_1 + prices[i]) \\buy_2 = max(buy_2, sell_1 - prices[i]) \\ sell_2 = max(sell_2, buy_2 + prices[i])\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-1.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.592em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.916em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.916em' style='width:0.8889em' viewBox='0 0 888.89 916' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V916 H384z M384 0 H504 V916 H384z'/></svg></span></span><span style="top:-5.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.13em;"><span style="top:-5.13em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span><span style="top:-0.81em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>例如在计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">sell_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，我们直接使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{buy}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 而不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><msubsup><mi>y</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">buy_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>  进行转移。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{buy}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">{buy}_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0832em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8362em;"><span style="top:-2.453em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 多考虑的是在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天买入股票的情况，而转移到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{sell}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，考虑的是在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天卖出股票的情况，这样在同一天买入并且卖出收益为零，不会对答案产生影响。同理对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">{buy}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">{sell}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，我们同样可以直接根据第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天计算出的值来进行状态转移。</p><p>那么对于边界条件，我们考虑第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 天时的四个状态：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{buy}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 即为以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi></mrow><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{prices}[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span></span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的价格买入股票，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mn>1</mn><mo>=</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy1=−prices[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{sell}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 即为在同一天买入并且卖出，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{sell}_1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>b</mi><mi>u</mi><mi>y</mi></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">{buy}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span> 即为在同一天买入并且卖出后再以  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prices[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的价格买入股票，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mn>2</mn><mo>=</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy2=−prices[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>；同理可得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><msub><mi>l</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sell_2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。我们将这四个状态作为边界条件，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 开始进行动态规划，即可得到答案。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, prices[i] + buy1);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, prices[i] + buy2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc188-买卖股票的最佳时机-IV（HD）">lc188. 买卖股票的最佳时机 IV（HD）</h2><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 100</code></li><li><code>1 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><hr><p>和上一题类似，但是这次买入卖出次数是不定的</p><p>我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 来表示对于数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo>…</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prices[0\dots i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 中的价格而言，进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 次交易，并且当前手上 <strong>还持有一只股票</strong> ，这种情况下的最大利润；用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sell[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 来表示进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 次交易，并且当前手上 <strong>不持有股票</strong> ，这种情况下的最大利润</p><p>对于  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，我们考虑当前持有的股票是否在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天购入的。如果是，那么在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天时，我们不应该持有股票，对应状态为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sell[i - 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，并且需要扣除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prices[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的购入话费；如果不是，那么在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天时，我们已经持有了股票，对应状态为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy[i - 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 。由此得到状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">buy[i][j] = max{buy[i - 1][j], sell[i - 1][j] - prices[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>同理，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sell[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，如果是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天卖出的，那么在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天时，我们手上持有股票，对于状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">buy[i - 1][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> , 并且需要加入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prices[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 的卖出收益；如果不是，那么第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天时，我们不应该持有股票，对于状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sell[i - 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 。由此得到状态转移方程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>b</mi><mi>u</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mrow><annotation encoding="application/x-tex">sell[i][j] = max{sell[i - 1][j], buy[i - 1][j - 1] + prices[i]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ces</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>由于在所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 天结束之后，手上不持有股票对应的最大利润一定是严格由于手上持有股票对应的最大利润的，然而完成的交易数并不是越多越好，因此最终答案应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>l</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo>…</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sell[n - 1][0\dots k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 中的最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        k = Math.min(k, n / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span>[][] buy = <span class="keyword">new</span> <span class="title class_">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[][] sell = <span class="keyword">new</span> <span class="title class_">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            buy[<span class="number">0</span>][i] = sell[<span class="number">0</span>][i] = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy[i][<span class="number">0</span>] = Math.max(buy[i - <span class="number">1</span>][<span class="number">0</span>], sell[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                buy[i][j] = Math.max(buy[i - <span class="number">1</span>][j], sell[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                sell[i][j] = Math.max(sell[i - <span class="number">1</span>][j], buy[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(sell[n - <span class="number">1</span>]).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc221-最大正方形（MD）">lc221. 最大正方形（MD）</h2><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li></ul><hr><p>首先，能不能组成正方形主要有两个因素：这个格子的值是否为 ‘1’，以及它左边、上边、左上方的格子的值是否为 ‘1’</p><p>我们设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示矩阵中以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 作为正方形右下角所能得到的正方形的边长最大值。此时，根据上面提及的两个因素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 显然受到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的影响。</p><p>由此得到一个状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>然后就是针对边界情况的处理：对于边界的格子，它只能自己作为一个小正方形（前提是这个格子的值是 ‘1’）。所以对于边界，值为 ‘1’ 的，dp值设置为1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;      </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                resLen = Math.max(resLen, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resLen * resLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc123-买卖股票的最佳时机-III（HD）&quot;&gt;lc123. 买卖股票的最佳时机 III（HD）&lt;/h2&gt;
&lt;p&gt;给定一个数组，它的第 &lt;code&gt;i&lt;/code&gt; 个元素是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.9</title>
    <link href="https://yonagi04.github.io/posts/2024/67f8fb0cb1c6/"/>
    <id>https://yonagi04.github.io/posts/2024/67f8fb0cb1c6/</id>
    <published>2024-05-09T11:42:16.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc63-不同路径-II（MD）">lc63. 不同路径 II（MD）</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><hr><p>和昨天的 <a href="https://yonagi04.github.io/posts/2024/27b820fe0090/">最小路径和</a> 比较相似，但是在预处理的时候，需要特别对障碍物进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc97-交错字符串（MD）">lc97. 交错字符串（MD）</h2><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p><p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>0 &lt;= s3.length &lt;= 200</code></li><li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li></ul><p>**进阶：**您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p><hr><p>首先这道题肯定不能用双指针法。根据力扣官方的解释，当样例为 <code>s1 = aabcc</code> , <code>s2 = dbbca</code> , <code>s3 = aadbbcbcac</code> 时，得到的结果与正确答案相悖</p><p>此题应考虑使用DP，理论来讲这道题也能用DFS，当然用DP是最好的。首先对字符串长度做判定：若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo mathvariant="normal">≠</mo><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mn>3</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|s_1| + |s_2| \ne |s_3|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 一定不能由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 交错组成</p><p>符合上述字符串条件之后，应使用DP。定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个元素与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素是否能够交错组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个元素和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素相等，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个元素与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素是否能够交错组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素取决于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素是否能够交错组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i + j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素。也就是说，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 取决于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i - 1, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i - 1, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 为真，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 也为真。同样的，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">s_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i + j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素相等且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j -1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 为真，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 也为真。</p><p>故得到下面的转移方程：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><msub><mi>s</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><msub><mi>s</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp(i, j) = [dp(i - 1, j) \&amp;\&amp; s_1(i - 1) == s_3(p)] || [dp(i, j - 1) \&amp;\&amp; s_2(j - 1) == s_3(p)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">&amp;&amp;</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)]</span><span class="mord">∣∣</span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;&amp;</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)]</span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p = i + j - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，边界条件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">dp(0, 0) = true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题算是假Mid题了，很明显就是以前的Hard题然后被下放到Mid的</p><hr><h2 id="lc72-编辑距离（MD）">lc72. 编辑距离（MD）</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><hr><p>事先声明：这道题其实就是一道Hard题！不要被它的Mid标识所迷惑了，这道题从题目理解到题目解析再到代码量完完全全达到了Hard题的标准！</p><p>这道题还是老样子，使用DP</p><p>这道题要求对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>题目给定了A和B两个单词，所以我们可以有共计6种操作方法</p><p>但是，我们发现：</p><ul><li>对单词A删除一个字符和对单词B插入一个字符是等价的</li><li>对单词B删除一个字符和对单词A插入一个字符是等价的</li><li>对单词A替换一个字符和对单词B替换一个字符是等价的</li></ul><p>那么实际上，操作有且仅有三种：</p><ul><li>在单词A中插入字符</li><li>在单词B中插入字符</li><li>修改单词A的字符</li></ul><p>我们以 <code>A=horse</code>, <code>B=ros</code> 为例子，解释一下如何将这个大问题分解为规模较小的子问题</p><ul><li><strong>在单词A中插入字符</strong> ：如果我们知道 <code>horse</code> 到 <code>ros</code> 的编辑距离为 <code>a</code>，那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>a + 1</code>。这是因为我们可以在 <code>a</code> 次操作之后将 <code>horse</code> 和 <code>ro</code> 变为相同的字符串，只需要额外的 1 次操作，在单词 <code>A</code> 的末尾添加字符 s，就能在 <code>a + 1</code> 次操作后将 <code>horse</code> 和 <code>ro</code> 变为相同的字符串</li><li><strong>在单词B中插入字符</strong> ：如果我们知道 <code>hors</code> 到 <code>ros</code> 的编辑距离为 <code>b</code> ， 那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>b + 1</code></li><li><strong>修改单词A的一个字符</strong> ：如果我们知道 <code>hors</code> 到 <code>ro</code> 的编辑距离是 <code>c</code> ， 那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>c + 1</code></li></ul><p>假设用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离</p><p>综上所述，当我们获得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i - 1, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i - 1, j - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 之后就能计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的值了</p><p>那么就能得到如下的状态转移方程</p><ul><li>若 <code>A</code> 和 <code>B</code> 的最后一个字母相同：</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp(i, j) = min[dp(i, j - 1) + 1, dp(i - 1, j) + 1, dp(i - 1, j - 1)] = 1+min[dp(i, j - 1), dp(i - 1, j), dp(i - 1, j - 1) - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>若 <code>A</code> 和 <code>B</code> 的最后一个字母不同：</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp(i, j) = 1 + min[dp(i, j - 1), dp(i - 1, j), dp(i - 1, j - 1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)]</span></span></span></span></p><p>对于边界情况，一个空串和一个非空串的编辑距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp(i, 0) = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dp(0, j) = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp(i, 0) = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 相当于对 <code>word1</code> 进行 <code>i</code> 次删除操作， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dp(0, j) = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 相当于对 <code>word2</code> 进行 <code>j</code> 次插入操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n + m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left_down</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    left_down += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = Math.min(left, Math.min(down, left_down));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc63-不同路径-II（MD）&quot;&gt;lc63. 不同路径 II（MD）&lt;/h2&gt;
&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.8</title>
    <link href="https://yonagi04.github.io/posts/2024/27b820fe0090/"/>
    <id>https://yonagi04.github.io/posts/2024/27b820fe0090/</id>
    <published>2024-05-08T10:42:03.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc139-单词拆分（MD）">lc139. 单词拆分（MD）</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><hr><p>先定义子问题：当遍历字符串s到下标i时，是否能够用字典中出现的一个或多个单词拼接出s？</p><p>那么根据这个子问题就能推出状态转移方程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo>…</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[j] \&amp;\&amp; check(s[j \dots i-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">&amp;&amp;</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo>…</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">check(s[j \dots i-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ec</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span> 表示子串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo>…</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[j\dots i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 是否出现在字典中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; hash.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc322-零钱转换（MD）">lc322. 零钱转换（MD）</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><hr><p>先定义子问题：凑成金额为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 最少的硬币个数？(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">m \le amount</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">am</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>)</p><p>我们以样例1为例，讲讲我们的转移方程要怎么推</p><p>样例1中，硬币金额分别为[1, 2, 5]，总金额要求是11</p><p>那么我们可以知道，对于金额 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> , 它可以由这么几个方式获得：假设凑成金额 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的硬币个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> ，对于本题，应该有:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[m] = dp[m - 1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[m] = dp[m - 2] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>m</mi><mo>−</mo><mn>5</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[m] = dp[m - 5] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>用文字来表述就是：对于金额 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> , 我们可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 再加上一个金额为 1 的硬币凑成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ， 也可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 再加上一个金额为 2 的硬币凑成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，还可以通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">m - 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 再加上一个金额为 5 的硬币凑成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></p><p>这样我们就能得到子问题之间的递推关系了：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = min(dp[i - coins[j]] + j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc300-最长递增子序列（MD）">lc300. 最长递增子序列（MD）</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><hr><p>定义子问题：遍历数组到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 时，此时最长严格递增子序列的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></p><p>所以对于两个下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i &lt; j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>) ，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i] &lt; nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j] = max(dp[i] + 1, dp[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span></span></span></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc120-三角形最小路径和（MD）">lc120. 三角形最小路径和（MD）</h2><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">输出：11</span><br><span class="line">解释：如下面简图所示：</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：triangle = [[-10]]</span><br><span class="line">输出：-10</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><hr><p>定义子问题：对于一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的点，从顶到这个点的最小路径和是多少？</p><p>根据这个三角形的特征，我们发现：对于点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> ，它只能由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i - 1, j - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i - 1, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 转化而来。由此定义出转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ian</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = Math.min(res, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc64-最小路径和（MD）">lc64. 最小路径和（MD）</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>**说明：**每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 200</code></li></ul><hr><p>我觉得这道题和上一题还是很像的。如果上一题做出来了，这一题应该也很容易就能做出来。整体思路一样，直接放代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc139-单词拆分（MD）&quot;&gt;lc139. 单词拆分（MD）&lt;/h2&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串列表 &lt;code&gt;wordDict&lt;/code&gt; 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 &lt;code&gt;s&lt;/c</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.7</title>
    <link href="https://yonagi04.github.io/posts/2024/ad04d08134a3/"/>
    <id>https://yonagi04.github.io/posts/2024/ad04d08134a3/</id>
    <published>2024-05-07T09:59:41.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc69-x的平方根（EZ）">lc69. x的平方根（EZ）</h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p>**注意：**不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= x &lt;= 2^31 - 1</code></li></ul><hr><p>既然不能使用内置的pow函数，而且不要求精度，那么可以考虑用二分法</p><p>为啥可以用二分法呢？回想一下以前高中数学的时候，老师有讲过一种东西叫做零点法（如果忘了就回去翻一下高中数学必修3和选修2-3，有讲过一种粗略计算零点的方法，就是这个零点法）——所以我们在对一个数做粗略的平方根计算的时候就可以考虑用零点法，也就是计算机科学里的二分法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &gt; x) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt; x) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc50-Pow-x-n-（MD）">lc50. Pow(x, n) （MD）</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-2^31 &lt;= n &lt;= 2^31-1</code></li><li><code>n</code> 是一个整数</li><li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li><li><code>-10^4 &lt;= xn &lt;= 10^4</code></li></ul><hr><p>快速幂板子题</p><p>想了解快速幂的直接看这个 <a href="https://oi-wiki.org/math/binary-exponentiation/">快速幂 - OI Wiki</a></p><p>但是不要盲目抄板子，这道题的n是有负值的，快速幂板子一般n不考虑负值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">return</span> n &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * x;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc70-爬楼梯（EZ）">lc70. 爬楼梯（EZ）</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><hr><p>很经典的dp题，也是最简单的dp题……</p><p>直接给题解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> b;</span><br><span class="line">            b = b + a;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc198-打家劫舍（MD）">lc198. 打家劫舍（MD）</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><hr><p>在我看来，dp问题的关键在于怎么确定子问题和怎么确定子问题之间的“递推关系”（也就是状态转移方程），这两个虽然看着简单，但实际上一点也不简单</p><p>这道题的大问题是 “偷窃所有的房屋能够获得的最高金额”，那么根据大问题我们可以先定义一个子问题 “偷窃 k 间房屋之后，获得的最高金额”，将这个值记录在 <code>dp[k]</code> 中</p><p>根据题意要求——我们只能偷窃不相邻的房屋。那么对于 k，我们有两个选择——偷和不偷，对应的 <code>dp[k]</code> 就分别是 <code>dp[k - 2] + nums[k - 1]</code> 和 <code>[dp - 1]</code></p><p>那么就能得到一个转移方程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[k] = max(dp[k - 2] + nums[k - 1], dp[k - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span></p><p>然后针对数组长度为0做特判即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> b;</span><br><span class="line">            b = Math.max(b, a + nums[i - <span class="number">1</span>]);</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc69-x的平方根（EZ）&quot;&gt;lc69. x的平方根（EZ）&lt;/h2&gt;
&lt;p&gt;给你一个非负整数 &lt;code&gt;x&lt;/code&gt; ，计算并返回 &lt;code&gt;x&lt;/code&gt; 的 &lt;strong&gt;算术平方根&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.6</title>
    <link href="https://yonagi04.github.io/posts/2024/5a89798b5ad4/"/>
    <id>https://yonagi04.github.io/posts/2024/5a89798b5ad4/</id>
    <published>2024-05-06T21:05:20.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc201-数字范围按位与（MD）">lc201. 数字范围按位与（MD）</h2><p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、<code>right</code> 端点）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：left = 5, right = 7</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：left = 0, right = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：left = 1, right = 2147483647</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= left &lt;= right &lt;= 2^31 - 1</code></li></ul><hr><p>可以通过将两个数字不断向右移动，直到数字相等，即数字被缩减为它们的公共前缀。然后，通过将公共前缀向左移动，将0添加到公共前缀的右边以获得最终结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc9-回文数（EZ）">lc9. 回文数（EZ）</h2><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><p>**进阶：**你能不将整数转为字符串来解决这个问题吗？</p><hr><p>考虑进阶情况和非进阶情况。非进阶的话自然是把数字转换为字符串来处理，然后用双指针法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = num.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num.charAt(l) != num.charAt(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要考虑进阶要求，那么可以考虑通过取余和取整的操作来获取数字的最高位和最低位，然后进行比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x / div ?= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> x / div;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (x % div) / <span class="number">10</span>;</span><br><span class="line">            div /= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc66-加一（EZ）">lc66. 加一（EZ）</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><hr><p>从数字的最高位（也就是数组的最后一个下标）开始向低位模拟（也就是数组的低下标位置）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                    digits[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc172-阶乘后的零（MD）">lc172. 阶乘后的零（MD）</h2><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p><p>提示 <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：3! = 6 ，不含尾随 0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：1</span><br><span class="line">解释：5! = 120 ，有一个尾随 0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 104</code></li></ul><p>**进阶：**你可以设计并实现对数时间复杂度的算法来解决此问题吗？</p><hr><p>$n! $尾零的数量即为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 中因子 10 的个数，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>=</mo><mn>2</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">10=2\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，因此转换成求$ n!$ 中质因子 2 的个数和质因子 5 的个数的较小值。</p><p>由于质因子 5 的个数不会大于质因子 2 的个数，我们可以仅考虑质因子 5 的个数。</p><p>而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> 中质因子 5 的个数等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 的每个数的质因子 555 的个数之和，我们可以通过遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 的所有 5 的倍数求出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            res += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc201-数字范围按位与（MD）&quot;&gt;lc201. 数字范围按位与（MD）&lt;/h2&gt;
&lt;p&gt;给你两个整数 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; ，表示区间 &lt;code&gt;[left, right]&lt;/code&gt; ，返回此区间内</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>回到广州之后的第一感觉</title>
    <link href="https://yonagi04.github.io/posts/2024/c49668a95c1d/"/>
    <id>https://yonagi04.github.io/posts/2024/c49668a95c1d/</id>
    <published>2024-05-06T13:37:24.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>回到广州的第一感觉是？</p><p><strong>热</strong></p><p>真的热得不行啊。前几天众所周知广东下暴雨，广州自然也不是特别热；五一节一过，我今天刚回广州就感觉热得不行。从广州东站出来之后坐地铁到体育中心，去对外经贸大厦楼下吃麦当奴，进去就能感觉一股凉气——虽然也不是特别的凉——因为人太多了，但还是比外面凉快得多。吃完麦当奴喝完一杯可乐，走出麦当奴只觉得热，热，热，还是热</p><p>一看天气，原来都31度了，怪不得那么热呢</p><p>冷知识，前几天暴雨的时候，广州气温才20出头</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回到广州的第一感觉是？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;热&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;真的热得不行啊。前几天众所周知广东下暴雨，广州自然也不是特别热；五一节一过，我今天刚回广州就感觉热得不行。从广州东站出来之后坐地铁到体育中心，去对外经贸大厦楼下吃麦当奴，进去就能感觉一</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>五一假期即将结束，随便写点</title>
    <link href="https://yonagi04.github.io/posts/2024/f55bcdea7c52/"/>
    <id>https://yonagi04.github.io/posts/2024/f55bcdea7c52/</id>
    <published>2024-05-05T16:32:30.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>五一节还是回了家。家里老爹老妈都盼着我回家，而且离得不算特别远（广州东站上车，走xx线差不多两个多小时就到了，然后再坐一个小时公交车，就到家），所以我还是回去了</p><p>去年五一节我就没回去。广东某地的同学应该都知道节假日回家的车票有多难买——我就不说去年我没抢到票的事情了，我就只说今年——今年我回家的车票倒是轻松抢到了，但是回广州的没抢到，让我一度怀疑是不是又回不去了。结果在12306找了下，发现老家某三等高铁站还有几张回广州的高铁票，那肯定是要买下来的，花了差不多250左右（昨天看b站一个up的铁路运转视频，从武汉到上海的高铁，才200出头，比我从广州回家还便宜，广铁真的死妈了）。两张车票，加起来差不多要接近500，差不多是我一个月生活费的三分之一了，广铁真的抢钱操他妈的</p><p>去年我没回去，我当时的计划是这样的——去年好像放了三天假还是四天假来着，5月1号留实验室继续加训，毕竟当时马上就要打gdcpc了；5月2号去萤火虫——结果我充电宝忘记充电，待不了多久手机就没电了，甚至没带充电器，连保利世贸展馆的插座都用不了，中午我就狼狈回校，而且差点因为手机没电关机用不了nfc进不了宿舍；3号好像还是加训来着，具体的忘了</p><p>偶然翻到了高三时候的日志本，用来设定每天要完成什么样的试卷刷多少题背多少东西的。节选一点发出来</p><blockquote><p>22.5.8(33天)</p><ol><li>英语卷（预测卷5，14年湖北）</li><li>地理卷（深圳二模）</li><li>物理电磁场选填专项</li><li>数学卷（限时训练）</li></ol><p>22.5.9(32天)</p><ol><li>物理卷（20年山东）</li><li>生物卷（20年山东）</li><li>抄写英语单词</li><li>数学二轮数列 IV</li><li>语文二轮语用题 I</li><li>英语卷（14年安徽）</li></ol><p>…</p><p>22.6.4(3天)</p><ol><li>地理自然地理综合题专项</li><li>生物卷（19年浙江）</li><li>数学卷（预测6，押题6）</li><li>英语卷（预测7）</li><li>语文抄写古诗文</li><li>地理卷（预测3）</li><li>物理卷（xx精选）（这里补充一下，xx是我老家的地名，毕竟是公开的博客网站，我不太想把我自己的所在地发布出来）</li><li>数学圆锥曲线错题整理</li></ol><p>22.6.5(2天)</p><ol><li>生物卷（18年浙江，17年浙江）</li><li>数学卷（预测7）</li><li>抄写英语单词</li><li>地理卷（武汉一模，仿真模拟 II）</li><li>物理卷（17年浙江，考前保温 II）</li><li>语文卷（xx精选）</li><li>英语卷（22年惠州一模）</li><li>物理压轴题整理</li></ol></blockquote><p>一天刷五六套卷子的情况，十分常见。至于最后两天为什么单日刷的试卷反而比二轮复习期间的单日量还要多，我不知道</p><p>也许大多数人都是这样的吧，可能这也是我为什么到现在还忘不了高考忘不了高考出分的原因之一</p><hr><p>我之前还说这个暑假要找到实习，现在看来越来越悬了——5月下旬考概率论，6月中旬考电磁场，6月下旬二战六级，7月上旬考剩下七八门课的期末考试……我都不知道怎么凑出时间来背八股文。我现在 JUC 那一套都还没搞明白，如果真的去面试，除了被记差面评之外不会别的收获，到时候不但找不到实习，反而会影响我以后秋招，那可就麻烦了</p><p>找不到就找不到吧！反正才大二</p><hr><p>我很早开始就养成了每天写写东西的习惯——当然这个写东西不是指那种写什么轻小说写那种很文学的东西，而是就像这篇短文一样，随便写点什么。我最早开始写东西是从我高一开始——当时刚去xx一中，人生地不熟，周围没有一个认识的人，外加我当时还是萌二（早些年还能经常听到这个词，现在基本听不到了），自我介绍也是那种很傻逼二刺螈的——我第一次去班里面，是军训之后，当时老爹知道xx一中军训是去某个傻逼军训基地，就直接给我打了假证明，拿给了班主任，班主任也毫不犹豫给我批了假，所以我第一次去班里面，班里已经有不少人都互相认识了，但是班主任还要我们搞自我介绍我当时搞了一个很傻逼很傻逼的自我介绍，和二次元没啥关系，但就是很傻逼。结果大家居然还能因为我的傻逼自我介绍笑出来，那可真是……</p><p>我好像写跑偏了，那就继续写，这可能是我建博客网站之后第一次写这么长的关于我自己的文章了，之前都是写在自己手机里面的</p><p>当时是怎么决定写东西的呢？是刚刚入学，我因为社恐，不敢和人说话，因此也没什么朋友，然后就开始回忆自己初中和一群萌二……额……玩？学习？的生活，然后就想记录下来</p><p>其实没有记录完。差不多写了三四篇，就没写了，毕竟随便一篇就是4000字5000字，妥妥的千字文，放汉语言文学系都能当日常作业了。后来是快要高中毕业了才给这个系列来了个草草收尾，大概意思就是写了最后中考冲刺巴拉巴拉，大家去了什么学校巴拉巴拉之类的，虽然这个结局非常不好，但总归是有个结尾</p><p>然后再次写文就是高二了，高二我决定开始写日记，记录自己每天的生活，等到高中毕业了就可以拿出来看。然后这一写，就是写到了高三毕业。其实毕业之后乃至于上了大学我还在继续写，但那时候已经是断断续续，不成气候了</p><p>那本日记本，现在还放在我的背包里，每天陪同我去自习室，去图书馆，去上课。经历了大风大浪，它还是它，没有任何改变</p><p>以后有时间，再来聊聊我的一些事情吧，距离高中毕业将要两年，我也得给自己一个交代</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;五一节还是回了家。家里老爹老妈都盼着我回家，而且离得不算特别远（广州东站上车，走xx线差不多两个多小时就到了，然后再坐一个小时公交车，就到家），所以我还是回去了&lt;/p&gt;
&lt;p&gt;去年五一节我就没回去。广东某地的同学应该都知道节假日回家的车票有多难买——我就不说去年我没抢到票的</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="琐事" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/%E7%90%90%E4%BA%8B/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>四月最强的偶像番是？</title>
    <link href="https://yonagi04.github.io/posts/2024/d8aef561f576/"/>
    <id>https://yonagi04.github.io/posts/2024/d8aef561f576/</id>
    <published>2024-05-05T14:43:34.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>谁是四月最强偶像番？</p><p>是虹四格动画版吗？是Girls Band Cry吗？是夜晚水母不会游泳吗？是终末列车去哪里吗？是失忆投捕吗？（大嘘）</p><p>都不是，是我们的——学園アイドルマスター哒！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.5/img/cover/gakumasu.webp" alt=""></p><p>虽然是游戏，但是它的剧情——有一种古早时代恋爱喜剧的味道，一看编剧——原来是伏见司这老贼，怪不得呢</p><p>只不过游戏现在还没开服，剧情只公开了前六话，断章断得十分可恶</p><p>（当然，游戏是一定不会玩的，剧情是一定要看的，这才是合格的云玩家）</p><p>我太喜欢它前面六话的剧情了，所以我要放上来</p><p>第一话&amp;第二话</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">     <iframe src="//player.bilibili.com/player.html?aid=1803819624&bvid=BV1vb421h7UR&cid=1523290036&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div><p>第三话&amp;第四话</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">     <iframe src="//player.bilibili.com/player.html?aid=1353775371&bvid=BV1iz421S75Z&cid=1524428178&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div><p>第五话&amp;第六话</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">     <iframe src="//player.bilibili.com/player.html?aid=1653961786&bvid=BV1nE421571k&cid=1525617268&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div><p>咲季乍一看像是邦邦的ksm（）去年年底发pv的时候我不知道溜了多少次，妈的越看越像是ksm</p><p>kotone可爱捏（）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谁是四月最强偶像番？&lt;/p&gt;
&lt;p&gt;是虹四格动画版吗？是Girls Band Cry吗？是夜晚水母不会游泳吗？是终末列车去哪里吗？是失忆投捕吗？（大嘘）&lt;/p&gt;
&lt;p&gt;都不是，是我们的——学園アイドルマスター哒！&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;data:image/g</summary>
      
    
    
    
    <category term="游戏" scheme="https://yonagi04.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="二次元游戏" scheme="https://yonagi04.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83%E6%B8%B8%E6%88%8F/"/>
    
    <category term="学園アイドルマスター" scheme="https://yonagi04.github.io/tags/%E5%AD%A6%E5%9C%92%E3%82%A2%E3%82%A4%E3%83%89%E3%83%AB%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.5</title>
    <link href="https://yonagi04.github.io/posts/2024/f34c03dc4943/"/>
    <id>https://yonagi04.github.io/posts/2024/f34c03dc4943/</id>
    <published>2024-05-05T11:12:29.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<p>今天的刷题日记是位运算专辑。位运算可以有效提高运算速度，当然它也是比较难掌握的，知道位运算、知道怎么用位运算、能在算法题中灵活用位运算，是完全不同的三件事情。</p><h2 id="lc190-颠倒二进制位（EZ）">lc190. 颠倒二进制位（EZ）</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 00000010100101000001111010011100</span><br><span class="line">输出：964176192 (00111001011110000010100101000000)</span><br><span class="line">解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 11111111111111111111111111111101</span><br><span class="line">输出：3221225471 (10111111111111111111111111111111)</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入是一个长度为 <code>32</code> 的二进制字符串</li></ul><p><strong>进阶</strong>: 如果多次调用这个函数，你将如何优化你的算法？</p><hr><p>将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。</p><p>代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n != <span class="number">0</span>; i++) &#123;</span><br><span class="line">            rev |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc191-位1的个数（EZ）">lc191. 位1的个数（EZ）</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 设置位 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 11</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 1011 中，共有 3 个设置位。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 128</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 10000000 中，共有 1 个设置位。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2147483645</span><br><span class="line">输出：30</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 30 个设置位。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2^31 - 1</code></li></ul><p><strong>进阶</strong>：</p><ul><li>如果多次调用这个函数，你将如何优化你的算法？</li></ul><hr><p>通过让当前的 n 和 n - 1做与运算，直到 n 变成 0 为止，因为每次运算都会使得 n 的最低位的 1 被反转，运算次数就是 n 二进制位中 1 的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc136-只出现一次的数字（EZ）">lc136. 只出现一次的数字（EZ）</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></li><li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li></ul><hr><p>首先介绍位运算中”异或运算“的三个性质</p><ul><li>任何数和 0 做异或运算，其结果都是它本身。即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a⊕0=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></li><li>任何数和它本身做异或运算，其结果是0。即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a⊕a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li>异或运算满足交换律和结合律，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0 = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></li></ul><p>根据本题给出的一个提示：除了某个元素只出现1次，其他元素均出现了两次。那么根据上面提到的三个性质，我们可知：除了我们要找出来的元素，其他的元素全部做异或运算，结果是 0，因为除了我们要找出来的元素，其他元素都出现了两次；而 0 和 一个非 0 值做异或运算，结果是原来这个非 0 值本身</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc137-只出现一次的数字-II（MD）">lc137. 只出现一次的数字 II（MD）</h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li></ul><hr><p>这道题和上一题的区别在于重复元素的个数——重复元素的个数不再是2个，而是3个。这样的话就不能再用上面提到的异或运算来判断了</p><p>因为数组中的元素都在 int 范围内，所以可以依次计算要找出的元素的每个二进制位是 0 还是 1</p><p>具体来讲，考虑要找出元素的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 从 0 开始编号），它可能是 0 或者 1。对于数组中非答案的元素， 每一个元素都出现了 3 次， 对应着 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位的 3 个 0 或者 3 个 1， 无论是哪种情况，它们的和都是 3 的倍数。因此，<strong>要找出的元素的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位就是数组中所有元素的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位之和除以 3 的余数</strong></p><p>这样的话，对于数组中的每一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> ，使用位运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;</mo><mo>&gt;</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">(x &gt;&gt; i) \&amp; i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord mathnormal">i</span></span></span></span>  得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位，并将它们相加再对 3 取余，得到的结果一定是 0 或 1，即为要找出元素的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个二进制位</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                total += ((nums[j] &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (total % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的刷题日记是位运算专辑。位运算可以有效提高运算速度，当然它也是比较难掌握的，知道位运算、知道怎么用位运算、能在算法题中灵活用位运算，是完全不同的三件事情。&lt;/p&gt;
&lt;h2 id=&quot;lc190-颠倒二进制位（EZ）&quot;&gt;lc190. 颠倒二进制位（EZ）&lt;/h2&gt;
&lt;p&gt;颠</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.4</title>
    <link href="https://yonagi04.github.io/posts/2024/c9907a0fceeb/"/>
    <id>https://yonagi04.github.io/posts/2024/c9907a0fceeb/</id>
    <published>2024-05-04T10:58:34.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc502-IPO（HD）">lc502. IPO（HD）</h2><p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p><p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code> ，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p><p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p><p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p><p>答案保证在 32 位有符号整数范围内。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">由于你的初始资本为 0，你仅可以从 0 号项目开始。</span><br><span class="line">在完成后，你将获得 1 的利润，你的总资本将变为 1。</span><br><span class="line">此时你可以选择开始 1 号或 2 号项目。</span><br><span class="line">由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。</span><br><span class="line">因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 10^5</code></li><li><code>0 &lt;= w &lt;= 10^9</code></li><li><code>n == profits.length</code></li><li><code>n == capital.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= profits[i] &lt;= 10^4</code></li><li><code>0 &lt;= capital[i] &lt;= 10^9</code></li></ul><hr><p>如果不限制次数下我们可以获取的最大利润，我们应该如何处理？我们只需将所有的项目按照资本的大小进行排序，依次购入项目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，同时手中持有的资本增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">profits[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，直到手中的持有的资本无法启动当前的项目为止。</p><ul><li><p>如果初始资本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>p</mi><mi>i</mi><mi>t</mi><mi>a</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w≥max⁡(capital)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span> ，我们直接返回利润中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个最大元素的和即可</p></li><li><p>当前的题目中限定了可以选择的次数最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次，这就意味着我们应该贪心地保证选择每次投资的项目获取的利润最大，这样就能保持选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次后获取的利润最大</p></li><li><p>我们首先将项目按照所需资本的从小到大进行排序，每次进行选择时，假设当前手中持有的资本为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>，我们应该从所有投入资本小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 的项目中选择利润最大的项目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，然后此时我们更新手中持有的资本为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>+</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w+profits[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，同时再从所有花费资本小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>+</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w+profits[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的项目中选择，我们按照上述规则不断选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次即可</p></li><li><p>我们利用大根堆的特性，我们将所有能够投资的项目的利润全部压入到堆中，每次从堆中取出最大值，然后更新手中持有的资本，同时将待选的项目利润进入堆，不断重复上述操作</p></li><li><p>如果当前的堆为空，则此时我们应当直接返回</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> profits.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = capital[i];</span><br><span class="line">            arr[i][<span class="number">1</span>] = profits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr &lt; n &amp;&amp; arr[curr][<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">                heap.offer(arr[curr][<span class="number">1</span>]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!heap.isEmpty()) &#123;</span><br><span class="line">                w += heap.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc373-查找和最小的-K-对数字（MD）">lc373. 查找和最小的 K 对数字（MD）</h2><p>给定两个以 <strong>非递减顺序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code> , 以及一个整数 <code>k</code>。</p><p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code>。</p><p>请找到和最小的 <code>k</code> 个数对 <code>(u1,v1)</code>, <code> (u2,v2)</code> …  <code>(uk,vk)</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：</span><br><span class="line">     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li><li><code>nums1</code> 和 <code>nums2</code> 均为 <strong>升序排列</strong></li><li><code>1 &lt;= k &lt;= 10^4</code></li><li><code>k &lt;= nums1.length * nums2.length</code></li></ul><hr><p>两个数组都是升序排列的，所以最小数对一定是(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums_1[0], nums_2[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>) , 最大数对一定是(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><msub><mi>h</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><msub><mi>h</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums_1[length_1 - 1], nums_2[length_2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>) 。本题要求找到最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数对，最直接的办法是可以将所有的数对求出来，然后利用排序或者 TopK 解法求出最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数对即可。实际求解时可以不用求出所有的数对，只需从所有符合待选的数对中选出最小的即可，假设当前已选的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 小数对的索引分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,b_1),(a_2,b_2),(a_3,b_3),\ldots,(a_n,b_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 由于两个数组都是按照升序进行排序的，则可以推出第 n+1n+1n+1 小的数对的索引选择范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>n</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1+1,b_1),(a_1,b_1+1),(a_2+1,b_2),(a_2,b_2+1),(a_3+1,b_3),(a_3,b_3+1),\ldots,(a_n+1,b_n),(a_n,b_n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>假设我们利用堆的特性可以求出待选范围中最小数对的索引为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_{i},b_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，同时将新的待选的数对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_{i}+1,b_{i}),(a_{i},b_{i}+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 加入到堆中，直到我们选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数对即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[o1[<span class="number">0</span>]] + nums2[o1[<span class="number">1</span>]] - nums1[o2[<span class="number">0</span>]] - nums2[o2[<span class="number">1</span>]];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(m, k); i++) &#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !heap.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] indexPair = heap.poll();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(nums1[indexPair[<span class="number">0</span>]]);</span><br><span class="line">            list.add(nums2[indexPair[<span class="number">1</span>]]);</span><br><span class="line">            ans.add(list);</span><br><span class="line">            <span class="keyword">if</span> (indexPair[<span class="number">1</span>] + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;indexPair[<span class="number">0</span>], indexPair[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc67-二进制求和（EZ）">lc67. 二进制求和（EZ）</h2><p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出：&quot;100&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出：&quot;10101&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li><code>a</code> 和 <code>b</code> 仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成</li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就不含前导零</li></ul><hr><p>模拟法，两个字符串从后往前倒推，然后把字符转换成对应的数字再相加，最后去余数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(a.length(), b.length()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.append((<span class="type">char</span>)(carry % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是用python的话，有更简单的做法，可以直接上位运算</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBinary</span>(<span class="params">self, a, b</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        x, y = <span class="built_in">int</span>(a, <span class="number">2</span>), <span class="built_in">int</span>(b, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            ans = x ^ y</span><br><span class="line">            carry = (x &amp; y) &lt;&lt; <span class="number">1</span></span><br><span class="line">            x, y = ans, carry</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc502-IPO（HD）&quot;&gt;lc502. IPO（HD）&lt;/h2&gt;
&lt;p&gt;假设 力扣（LeetCode）即将开始 &lt;strong&gt;IPO&lt;/strong&gt; 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.3</title>
    <link href="https://yonagi04.github.io/posts/2024/41fa4f63b4b9/"/>
    <id>https://yonagi04.github.io/posts/2024/41fa4f63b4b9/</id>
    <published>2024-05-03T11:04:33.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc34-在排序数组中查找元素的第一个和最后一个位置（MD）">lc34. 在排序数组中查找元素的第一个和最后一个位置（MD）</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><hr><p>其实就是对查找元素的左右边界做二分查找</p><p>实际上，可以把查找左右边界拆成两个函数，但是我没整出来；力扣的官方题解是写成一个函数，但我觉得这么写容易混淆，不易于理解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> lower)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getLeftBound</span>(nums, target), r = <span class="built_in">getRightBound</span>(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-2</span> || r == <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r - <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLeftBound</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                res = r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRightBound</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                res = l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="lc153-寻找旋转排序数组中的最小值（MD）">lc153. 寻找旋转排序数组中的最小值（MD）</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><hr><p>必须设计一个时间复杂度为 <code>O(log n)</code> 的算法，那么明显就是要求用二分了</p><p>如果不用二分的话，一次遍历也能找出来，时间复杂度就是 <code>o(n)</code> ，但是不符合这道题的要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是常规的二分法</p><hr><h2 id="lc215-数组中的第k个最大元素（MD）">lc215. 数组中的第k个最大元素（MD）</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><hr><p>这道题偷个懒，直接用java自带的优先队列做这道题</p><p>（实际上，面试中是不允许候选人直接使用现成的优先队列的，这时候只能考虑使用类似于快排的方法或者手写一个优先队列）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; Integer.compare(b, a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc34-在排序数组中查找元素的第一个和最后一个位置（MD）&quot;&gt;lc34. 在排序数组中查找元素的第一个和最后一个位置（MD）&lt;/h2&gt;
&lt;p&gt;给你一个按照非递减顺序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/co</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.2</title>
    <link href="https://yonagi04.github.io/posts/2024/629aa59f6731/"/>
    <id>https://yonagi04.github.io/posts/2024/629aa59f6731/</id>
    <published>2024-05-02T10:29:29.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc74-搜索二维矩阵（MD）">lc74. 搜索二维矩阵（MD）</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-10^4 &lt;= matrix[i][j], target &lt;= 10^4</code></li></ul><hr><p>变相二分查找</p><p>为什么说是变相呢，因为这是个矩阵，理论来讲是不能用二分查找的；但是因为这个矩阵中填入的元素是有序排列的，所以假如我们线从左到右再从上到下遍历这个矩阵，就会发现得到的序列是有序的，而有序的序列就可以使用二分查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> matrix[mid / n][mid % n];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc162-寻找峰值（MD）">lc162. 寻找峰值（MD）</h2><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul><hr><p>使用 <code>O(log n)</code> 的时间复杂度来完成，很明显就要求我们使用二分了，因为也只有用二分法才能达到 <code>O(log n)</code> 的时间复杂度</p><p>怎么用二分呢？根据这道题的题意，峰值是指值严格大于左右相邻值的元素</p><p>那么就可以根据这个要求来确定二分法的边界收缩条件了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc33-搜索旋转排序数组（MD）">lc33. 搜索旋转排序数组（MD）</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><hr><p>旋转数组其实是把原来一个完整有序的数组切割成了两个仍然是有序的部分然后重新拼接，也就是说旋转数组其实是保证了数组的局部是有序的，这仍然可以二分查找</p><p>例如样例1，nums = [4,5,6,7,0,1,2]，其中[4, 5, 6, 7] 和 [0, 1, 2]这两个部分内部仍然是有序的，所以在处理二分查找的时候只需要根据mid所处区间的情况来调整二分边界</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc74-搜索二维矩阵（MD）&quot;&gt;lc74. 搜索二维矩阵（MD）&lt;/h2&gt;
&lt;p&gt;给你一个满足下述两条属性的 &lt;code&gt;m x n&lt;/code&gt; 整数矩阵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按非严格递增顺序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.5.1</title>
    <link href="https://yonagi04.github.io/posts/2024/e8e9f81bd4d0/"/>
    <id>https://yonagi04.github.io/posts/2024/e8e9f81bd4d0/</id>
    <published>2024-05-01T11:12:33.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc53-最大子数组和（MD）">lc53. 最大子数组和（MD）</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><hr><p>先不看进阶要求</p><p>这道题看起来有点像dp……实际上也可以用dp做</p><p>（当然我的做法有点不太像dp就是了，但都是局部最优推全局最优）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (res &lt;= sum) &#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc918-环形子数组的最大和（MD）">lc918. 环形子数组的最大和（MD）</h2><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,-2,3,-2]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 得到最大和 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,-3,5]</span><br><span class="line">输出：10</span><br><span class="line">解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,-2,2,-3]</span><br><span class="line">输出：3</span><br><span class="line">解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 3 * 10^4</code></li><li><code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></li></ul><hr><p>这道题是上一题的进阶Pro Max版本，虽然都是给了Mid难度，但这道题可比上一题难多了——环形数组、递推方程更加难推导、请看会更复杂（最大子数组是在中间，还是在两边？）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">            leftSum += nums[i];</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], leftSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightSum += nums[i];</span><br><span class="line">            res = Math.max(res, rightSum + leftMax[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc35-搜索插入位置（EZ）">lc35. 搜索插入位置（EZ）</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><hr><p>必须使用时间复杂度为 <code>O(log n)</code> 的算法，那么很明显就是二分了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc53-最大子数组和（MD）&quot;&gt;lc53. 最大子数组和（MD）&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/str</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.29</title>
    <link href="https://yonagi04.github.io/posts/2024/c0dd31cb7628/"/>
    <id>https://yonagi04.github.io/posts/2024/c0dd31cb7628/</id>
    <published>2024-04-29T13:31:49.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc22-括号生成（MD）">lc22. 括号生成（MD）</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><hr><p>使用回溯法。如果左括号数量不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，我们可以放一个左括号；如果右括号数量小于左括号的数量，我们可以放一个右括号。当长度正好等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时，直接返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            dfs(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            dfs(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc79-单词搜索（MD）">lc79. 单词搜索（MD）</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><hr><p>深搜题，印证了之前说过的 “回溯就当作dfs来看待” 这个说法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length, m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> dfs(board, vis, i, j, word, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] vis, <span class="type">int</span> i, <span class="type">int</span> j, String word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span>[][] directs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> dfs(board, vis, newi, newj, word, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        res = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc108-将有序数组转换为二叉搜索树（EZ）">lc108. 将有序数组转换为二叉搜索树（EZ）</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵平衡二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-104 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><hr><p>其实就是二分查找，直接二分法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binary(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">binary</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = binary(nums, l, mid);</span><br><span class="line">        root.right = binary(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc22-括号生成（MD）&quot;&gt;lc22. 括号生成（MD）&lt;/h2&gt;
&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>使用Github+Picgo+npm实现免费图床</title>
    <link href="https://yonagi04.github.io/posts/2024/30d4b97b9c26/"/>
    <id>https://yonagi04.github.io/posts/2024/30d4b97b9c26/</id>
    <published>2024-04-29T09:19:02.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文参考自 Akilar，原文地址：<a href="https://akilar.top/posts/3e956346/">https://akilar.top/posts/3e956346/</a></strong></p><h2 id="Picgo的配置">Picgo的配置</h2><blockquote><ol><li>Github图床仓库内容不能超过1GB，因为Github原则上是反对仓库图床化的，超过1GB之后会由人工审核仓库内容，如果仓库被发现用来做图床，轻则删库重则封号</li><li>jsDelivr加速的单文件大小为50MB，这就限制了单张图片大小上限</li></ol></blockquote><ol><li>首先创建一个图床仓库用来放图片，名称随意。以下内容使用[AssetsRepo] 代指图床仓库</li><li>访问<a href="https://github.com/settings/tokens">Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens</a>-&gt;generate new token,创建的<code>Token</code>名称随意，但必须勾选<code>repo</code>项。</li></ol><blockquote><p>Token只会显示一次，必须记牢，如果忘了就只能重新配置</p></blockquote><ol start="3"><li><p>下载Picgo软件，可以直接访问Picgo的github仓库，在<a href="https://github.com/Molunerfinn/picgo/releases">release</a>中下载最新版本的安装包。<br><a href="https://github.com/Molunerfinn/picgo"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=Molunerfinn&amp;repo=picgo&amp;show_owner=true" alt="img"></a></p></li><li><p>打开Picgo，找到图床设置，选择Github图床，根据指示填写对应内容。</p><ul><li>设定仓库名：[UserName]/[AssetsRepo]</li><li>设定分支名：2020年10月后github新建仓库默认分支改为<code>main</code>,在这之前的是<code>master</code>。</li><li>设定Token：填入第二步时申请到的<code>Token</code></li><li>指定存储路径：这是存放图片的路径，这里可以直接写<code>/</code>表示存放在根目录。</li><li>设定自定义域名：在图片上传后，PicGo会按照<code>自定义域名+指定储存路径+上传的图片名</code>的方式生成访问链接，并放到粘贴板上，例如要使用<code>jsDelivr</code>加速，则设置为<code>https://cdn.jsdelivr.net/gh/[UserName]/[AssetsRepo]</code>，上传完毕后，我们就可以通过<code>https://cdn.jsdelivr.net/gh/[UserName]/[AssetsRepo]/指定存储路径/图片名</code>加速访问我们的图片了。</li></ul></li></ol><h2 id="npm图床的使用">npm图床的使用</h2><ol><li><p>首先，注册一个npm的账号。访问<a href="https://www.npmjs.com/signup/">npm注册页面</a></p></li><li><p>找到我们之前在Github创建好的图床仓库，把它clone下来</p></li><li><p>在clone下来的[AssetsRepo]文件夹下打开终端，输入以下指令</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><ol start="4"><li>添加本地npm用户设置</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm adduser</span><br><span class="line"><span class="comment"># 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱</span></span><br><span class="line">npm login</span><br></pre></td></tr></table></figure><ol start="5"><li>运行npm初始化指令，把整个图床仓库打包，按照指示进行配置，需要注意事先确定你的包名没有和别人已经发表过的包名重复，建议使用id+仓库名的方式来定义新包名</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/6000c029.png" alt=""></p><p>最后会输出一段package.json，输入yes即可</p><ol start="6"><li>输入发布命令，我们就可以把包发布在npm上了</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><ol start="7"><li>获取存储在npm仓库的资源的方法</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jsDelivr+github链接</span></span><br><span class="line">https://cdn.jsdelivr.net/gh/[GithubUserName]/[AssetsRepo]/img/index.png</span><br><span class="line"><span class="comment"># jsDelivr+npm链接</span></span><br><span class="line">https://npm.elemecdn.com/[NpmPackageName]/img/index.png</span><br><span class="line"><span class="comment"># unpkg+npm</span></span><br><span class="line">https://unpkg.com/:package@:version/:file</span><br></pre></td></tr></table></figure><ol start="8"><li><p>如果每次都要在本地进行<code>npm publish</code>的话，npm的提交是整个包一起上传的，不存在增量更新，耗时不说，而且还往往需要架梯子才能正常上传。所以我们可以把它交给github action来完成。</p><p>在<a href="https://www.npmjs.com/">npm官网</a>-&gt;头像-&gt;Access Tokens-&gt;Generate New Token,勾选Automation选项，<code>Token</code>只会显示这一次，之后如果忘记了就只能重新生成重新配置了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/0e884db2.png" alt=""></p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/0158bc90.png" alt=""></p><p>​在github的[AssetsRepo]仓库设置项里添加一个名为<code>NPM_TOKEN</code>的<code>secrets</code>，把获取的Npm的Access token输入进去。</p><p>​在本地的<code>[AssetsRepo]</code>文件夹下新建<code>[AssetsRepo]/.github/workflows/autopublish.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node.js</span> <span class="string">Package</span></span><br><span class="line"><span class="comment"># 监测图床分支，2020年10月后github新建仓库默认分支改为main，记得更改</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">publish-npm:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span> <span class="comment"># 改为自己的node.js版本，在终端用node -version查询</span></span><br><span class="line">          <span class="attr">registry-url:</span> <span class="string">https://registry.npmjs.org/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NODE_AUTH_TOKEN:</span> <span class="string">$&#123;&#123;secrets.npm_token&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在[AssetsRepo]文件夹下打开终端，输入以下指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将更改提交</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;npm publish&quot;</span> <span class="comment"># 双引号里面的内容自行修改</span></span><br><span class="line"><span class="comment"># 更新package版本号</span></span><br><span class="line">npm version patch</span><br><span class="line"><span class="comment"># 推送至github触发action</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这四条指令的执行是非常严格的，不能错不能乱。npm每次发布包之前都需要更新一次包版本（也就是第3条指令），更新包版本有两种方法，一种就是上面的指令，直接将末尾的版本号+1，另外一种就是在package.json里面修改（大版本更新需要手动修改）</p><p>如果没有更新版本号就直接发布包，就会导致发布失败</p><hr><p>也算是填上之前挖的一个坑了吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文参考自 Akilar，原文地址：&lt;a href=&quot;https://akilar.top/posts/3e956346/&quot;&gt;https://akilar.top/posts/3e956346/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Picgo的</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Hexo相关" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/Hexo%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Github" scheme="https://yonagi04.github.io/tags/Github/"/>
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
    <category term="npm" scheme="https://yonagi04.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Action实现Hexo博客自动化部署</title>
    <link href="https://yonagi04.github.io/posts/2024/aaf8aa1a07d2/"/>
    <id>https://yonagi04.github.io/posts/2024/aaf8aa1a07d2/</id>
    <published>2024-04-27T10:27:36.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文参考自 Akilar，原文地址：<a href="https://akilar.top/posts/f752c86d/">https://akilar.top/posts/f752c86d/</a></strong></p><p>每次部署<code>Hexo</code>都需要运行指令三件套，随着文章越来越多，编译的时间也随之越来越长，通过<code>Github Action</code>，我们只需要在每次完成博客的编写或修改以后，将改动直接<code>push</code>到远程仓库，之后的编译部署的工作统统交给<code>CI</code>来完成即可。</p><h2 id="常量说明">常量说明</h2><p>本文内容会出现部分常量名来指代一些名词，请读者根据自己实际情况，对照好常量名</p><table><thead><tr><th>常量名</th><th>常量释义</th></tr></thead><tbody><tr><td><strong>[Blogroot]</strong></td><td>本地存放博客源码的文件夹路径</td></tr><tr><td><strong>[SourceRepo]</strong></td><td>存放博客源码的私有仓库名</td></tr><tr><td><strong>[SiteBlogRepo]</strong></td><td>存放编译好的博客页面的公有仓库名<br/>Site指站点，Github中编译好的博客页面仓库名应该为“<a href="http://username.github.io">username.github.io</a>&quot;</td></tr><tr><td><strong>[SiteUsername]</strong></td><td>用户名<br/>Site指站点</td></tr><tr><td><strong>[SiteToken]</strong></td><td>申请到的令牌码<br/>Site指站点, 本文中指代Github Token</td></tr><tr><td><strong>[GithubEmail]</strong></td><td>与github绑定的主邮箱，建议使用Gmail</td></tr><tr><td><strong>[TokenUser]</strong></td><td>Coding配置特有的令牌用户名</td></tr></tbody></table><p>以下内容均以Github为例。若使用Gitee、Coding等进行博客部署，请阅读 Akilar的原文</p><h2 id="Github-Action的使用">Github Action的使用</h2><h3 id="获取Token">获取Token</h3><p>为了确保交由<code>Github Action</code>来持续部署时，<code>Github Action</code>具备足够的权限来进行<code>hexo deploy</code>操作, 需要先获取<code>Token</code></p><p>访问<a href="https://github.com/settings/tokens">Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens</a>-&gt;generate new token,创建的<code>Token</code>名称随意，但必须勾选repo项和workflows项。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/aF4dLUomY6NkunZ.png" alt=""></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/ca384d58.png" alt=""></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/20200923085908748.png" alt=""></p><blockquote><p>Token只会显示一次，请在生成Token之后立即记录下来，否则如果忘记了Token，就必须重新生成重新配置</p></blockquote><p>然后就是创建存放Hexo博客源码的<strong>私有</strong>仓库[SourceRepo]，请注意仓库必须是私有的，因为我们之后要使用Token来上传代码，如果不设置为私有仓库会导致我们的Token泄漏</p><h3 id="配置Github-Action">配置Github Action</h3><p>以下我会给出两个版本的脚本，请自行参考。脚本1为初学者版本，无其他插件/压缩；脚本2包含了其他插件可能需要的指令，请自行参照博客的实际情况修改脚本代码</p><p>在 [Blogroot] 内新建 <strong>.github</strong> 文件夹，然后 在 .github 文件夹内部新建一个 <strong>workflows</strong> 文件夹，最后在 workflows 文件夹内新建一个 <strong>autodeploy.yml</strong> 文件</p><p>在 autodeploy.yml 中输入以下脚本</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本1，供初学者使用，如有其他需要在部署前运行的插件（如gulp、hexo-bangumi-bilibili等，请参考脚本2）</span></span><br><span class="line"><span class="comment"># 当有改动推送到master分支时，启动Action</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span> <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span> <span class="comment">#action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署</span> <span class="comment">#此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd ./public</span></span><br><span class="line"><span class="string">        git init</span></span><br><span class="line"><span class="string">        git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git add .</span></span><br><span class="line"><span class="string">        git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;</span></span><br><span class="line"><span class="string">        git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;.github.io.git&quot; master:main</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 脚本2，仅供有其他需要在部署前运行的插件（如gulp、hexo-bangumi-bilibili等）的博客使用，请根据自己博客的实际情况修改下面的脚本代码</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"><span class="comment"># 当有改动推送到master分支时，启动Action</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span> <span class="comment">#action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install gulp-cli -g #全局安装gulp</span></span><br><span class="line"><span class="string">        npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo bangumi -u #bilibili番剧更新</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string">        gulp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署</span> <span class="comment">#此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd ./public</span></span><br><span class="line"><span class="string">        git init</span></span><br><span class="line"><span class="string">        git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        git add .</span></span><br><span class="line"><span class="string">        git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;</span></span><br><span class="line"><span class="string">        git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;.github.io.git&quot; master:main</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，因为美国一些政治正确的原因，Github于2020年10月后的新建仓库的主分支都改名为 ”main“ 而不是 ”master“，但是Git软件默认的主分支还是 ”master“，所以请用Git查询自己本地的分支，然后把本地的分支推送到Github的 ”main“ 分支上去。例如，我本人的本地分支为 master，那么最后一行就应该为 ”master:main&quot;，如果你的本地分支名称不是 “master”，就必须修改，否则就不能部署成功</p></blockquote><h3 id="在本地设置远程仓库和分支">在本地设置远程仓库和分支</h3><p>以下分为两种情况：使用过Git管理过博客源代码，和没有使用过Git管理博客源代码</p><h4 id="没有使用过Git管理博客源代码">没有使用过Git管理博客源代码</h4><ol><li><p>删除或者先把<code>[Blogroot]/themes/butterfly/.git</code>移动到非博客文件夹目录下,原因是主题文件夹下的<code>.git</code>文件夹的存在会导致其被识别成子项目，从而无法被上传到源码仓库。</p></li><li><p>在博客根目录<code>[Blogroot]</code>路径下运行指令</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">#初始化</span></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git <span class="comment">#[SourceRepo]为存放源码的github私有仓库</span></span><br><span class="line">git checkout -b master <span class="comment"># 切换到master分支，</span></span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 如果不是，后面的所有设置的分支记得保持一致</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加屏蔽项</li></ol><p>因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到github上。这样可以显著减少需要提交的文件量和加快提交速度。<br>打开<code>[Blogroot]/.gitignore</code>,输入以下内容：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure><p>如果你的主题不是butterfly，那么最后一行请改为你使用的主题</p><ol start="4"><li>运行Git，提交代码</li></ol><p>请记住下面三行指令，以后博客部署都是通过这3行指令来完成</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action update&quot;</span> <span class="comment">#引号内的内容可以自行更改作为提交记录。</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br></pre></td></tr></table></figure><h4 id="使用过Git管理过博客源代码">使用过Git管理过博客源代码</h4><ol><li>添加屏蔽项</li></ol><p>因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到github上。这样可以显著减少需要提交的文件量和加快提交速度。<br>打开<code>[Blogroot]/.gitignore</code>,输入以下内容：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure><p>如果你的主题不是butterfly，那么最后一行请改为你使用的主题</p><ol start="2"><li>提交源码到私有仓库</li></ol><p>在博客根目录[Blogroot]下启动终端，使用git指令重设仓库地址。这样在新建仓库，我们仍旧可以保留珍贵的commit history，便于版本回滚</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin <span class="comment"># 删除原有仓库链接</span></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git <span class="comment">#[SourceRepo]为新的存放源码的github私有仓库</span></span><br><span class="line">git checkout -b master <span class="comment"># 切换到master分支，</span></span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 如果不是，后面的所有设置的分支记得保持一致</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action update&quot;</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br></pre></td></tr></table></figure><h3 id="查看部署情况">查看部署情况</h3><p>打开Github的私有源码仓库，找到Action</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img@1.1.3/img/content/githubaction.webp" alt=""></p><p>如果出现了上面这样全部打了勾勾，就算是部署成功了。恭喜你，以后就能够通过Github Action直接一键部署，而不是每次部署之前都要用hexo手动编译等待编译完才能部署了</p><h3 id="后记">后记</h3><p>这里可能有同学要问，github action有啥用？这不就是从<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>的三件套变成了<code>git add .</code>,<code>git commit -m &quot;commit content&quot;</code>,<code>git push</code>三件套吗？<br>其实github action的最大作用就是进一步提高速度和便携性，首先，配置要求提交源码这点，萌新小白就没必要再靠本地不断新建压缩包来备份源码了，借助git的版本管理，不管怎么改都可以快速回滚<br>然后，git提交是增量更新，每次只提交新增或者删改的内容，而hexo deploy是在本地每次重新生成所有静态文件以后再整个提交。github action能帮我们节省大把时间，把最耗时的hexo generate和hexo deploy的工作丢给CI处理。让我们能够专心与编写博客内容，而不是水文3分钟，提交半小时</p><hr><p>以后如果有机会，我会再讲讲如何用Github+npm搭建一个属于自己的免费图床和资源床（挖坑环节）</p><p>（坑已填，请看 <a href="https://yonagi04.github.io/posts/2024/37a28d8d4ce2/%EF%BC%89">https://yonagi04.github.io/posts/2024/37a28d8d4ce2/）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文参考自 Akilar，原文地址：&lt;a href=&quot;https://akilar.top/posts/f752c86d/&quot;&gt;https://akilar.top/posts/f752c86d/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次部署&lt;code&gt;H</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Hexo相关" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/Hexo%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Github" scheme="https://yonagi04.github.io/tags/Github/"/>
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.27</title>
    <link href="https://yonagi04.github.io/posts/2024/170613fe89a6/"/>
    <id>https://yonagi04.github.io/posts/2024/170613fe89a6/</id>
    <published>2024-04-27T10:02:20.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc46-全排列（MD）">lc46. 全排列（MD）</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><hr><p>因为要求返回所有可能的全排列，所以要考虑是否会出现重复遍历的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc39-组合总和（MD）">lc39. 组合总和（MD）</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><hr><p>请注意这道题和其他回溯题不同的一点：数字可以被无限次选取，所以每次遍历</p><p>有点类似于贪心，但有点不太像。我们为了能够减少单次循环的遍历次数，可以先对数组做一次从小到大的排序，这样如果出现现有的数字之和 + 待选数字 &gt; 目标总和的情况，就可以直接break掉</p><p>至于其他的内容，就和传统的回溯题一样了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> idx, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            dfs(candidates, target, i, sum);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc52-N-皇后-II（HD）">lc52. N 皇后 II（HD）</h2><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><hr><p>经典的n皇后问题，当然也是校招面试中常见的hard题</p><p>首先分析题目要求：n皇后要求不能有两个棋子在同一列/行/斜线上。所以我们要考虑用一种数据结构来存储具体哪一行/列/斜线放了棋子，那么之后这些行/列/斜线就不能再放置棋子了</p><p>考虑到这个要求，我们用 Set 这个数据结构来存储棋子的行/列/斜线</p><p>在每次放置棋子之前都要先用这三个数据结构来判断有没有棋子已经放在了和这个格子同一行/列或者同一条斜线上，如果有那么就不能再放置；反之就可以放置，然后做一次dfs遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal1</span> <span class="operator">=</span> row - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diagonal2</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                cnt += dfs(n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似很复杂，其实也没那么难，本质上还是回溯</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc46-全排列（MD）&quot;&gt;lc46. 全排列（MD）&lt;/h2&gt;
&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其 &lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.24</title>
    <link href="https://yonagi04.github.io/posts/2024/fe20f4d2cb77/"/>
    <id>https://yonagi04.github.io/posts/2024/fe20f4d2cb77/</id>
    <published>2024-04-24T13:06:06.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc909-蛇梯棋（MD）">lc909. 蛇梯棋（MD）</h2><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a href="https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786">转行交替方式</a> ，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p><p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p><ul><li>选定目标方格 <code>next</code>，目标方格的编号符合范围 <code>[curr + 1, min(curr + 6, n2)]</code>。<ul><li>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li></ul></li><li>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。</li><li>当玩家到达编号 <code>n2</code> 的方格时，游戏结束。</li></ul><p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n2</code> 的方格上没有蛇或梯子。</p><p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p><ul><li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li></ul><p>返回达到编号为 <code>n2</code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class="line">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class="line">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class="line">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class="line">最后决定移动到方格 36 , 游戏结束。 </span><br><span class="line">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[-1,-1],[-1,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == board.length == board[i].length</code></li><li><code>2 &lt;= n &lt;= 20</code></li><li><code>grid[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n2]</code> 内</li><li>编号为 <code>1</code> 和 <code>n2</code> 的方格上没有蛇或梯子</li></ul><hr><p>虽然这道题力扣给的是mid，但我个人感觉已经算是hard难度了，从题解的码量和题目长度来看都是如此</p><p>我们可以把这个 ”矩阵“ 看成是一个有向图，格子内数字大小之差绝对值为1的格子之间、蛇和梯子可以理解成是连接两个节点的有向边</p><p>根据这道题的题意，要求返回到达编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的格子所需要的最少步数，根据算法基本知识，可以知道这道题很明显要求我们使用bfs。为什么求最少步数要用bfs，多刷几道bfs题就懂了</p><p>既然知道要用bfs，那么不难写出bfs的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下内容为伪码，非题解代码</span></span><br><span class="line">Queue&lt;<span class="type">int</span>[]&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">que.offer(START_POINT);</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">    <span class="type">POINT</span> <span class="variable">P</span> <span class="operator">=</span> que.poll();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*以下为接下来可能走到的节点的处理*/</span></span><br><span class="line">        ......</span><br><span class="line">       <span class="keyword">if</span> (VALUE = n * n) &#123;</span><br><span class="line">            <span class="keyword">return</span> POINT.step + <span class="number">1</span>; <span class="comment">// 走到终点了，直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[VALUE]) &#123;</span><br><span class="line">            vis[VALUE] = <span class="literal">true</span>;</span><br><span class="line">            que.offer(<span class="keyword">new</span> <span class="title class_">int</span>[VALUE, POINT.step + <span class="number">1</span>]); <span class="comment">// bfs</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是怎么判断我们接下来要走到格子对应的横坐标和纵坐标了</p><p>用这个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> next, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (next - <span class="number">1</span>) / n, c = (next - <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        c = n - <span class="number">1</span> - c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span> - r, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就能整理出题解代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] p = que.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> p[<span class="number">0</span>] + i;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; n * n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span>[] rc = id2rc(next, n);</span><br><span class="line">                <span class="keyword">if</span> (board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    next = board[rc[<span class="number">0</span>]][rc[<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (next == n * n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!vis[next]) &#123;</span><br><span class="line">                    vis[next] = <span class="literal">true</span>;</span><br><span class="line">                    que.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next, p[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> next, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (next - <span class="number">1</span>) / n, c = (next - <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            c = n - <span class="number">1</span> - c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span> - r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，难度实际上接近于hard，但是力扣官方给的评级是mid，属于是假mid了</p><h2 id="lc17-电话号码的字母组合（MD）">lc17. 电话号码的字母组合（MD）</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul><hr><p>注意这里有一点，下标是从0开始的，而键盘上面是从数字 2 开始才有字母，不要搞错了。我第一发wa就是因为没注意到这个情况</p><p>但是抛开这一点，这一题实际上是一道非常非常经典的回溯题，回溯入门必做</p><p>回溯是啥？我们在dfs就已经初步接触过回溯了。至于回溯是什么，我给不了很明确的定义，但我给你这段代码，如果你熟悉dfs的话很快就明白了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    vis[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*经过一堆各种各样的处理……*/</span></span><br><span class="line">    dfs(i + <span class="number">1</span>); <span class="comment">// 或者其他各种形式的dfs函数调用</span></span><br><span class="line">    vis[i] = <span class="literal">false</span>; <span class="comment">// 这一步就叫做回溯！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么既然我们把回溯当成dfs来处理，我们很快就能写出这道题的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">strTmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] numMap = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        dfs(numMap, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String[] numMap, String digits, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == digits.length()) &#123;</span><br><span class="line">            res.add(strTmp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numMap[digits.charAt(idx) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            strTmp.append(str.charAt(i));</span><br><span class="line">            dfs(numMap, digits, idx + <span class="number">1</span>);</span><br><span class="line">            strTmp.deleteCharAt(strTmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>lc77. 组合（MD）</h1><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><hr><p>假如上面那道题你吃透了，那么这道题就非常简单</p><p>直接给题解，具体思路看上一题，是一样的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt;= n - (k - tmp.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            tmp.add(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>);</span><br><span class="line">            tmp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至代码结构都没有很大的改动，基本上搬过来稍微改一下就可以ac了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc909-蛇梯棋（MD）&quot;&gt;lc909. 蛇梯棋（MD）&lt;/h2&gt;
&lt;p&gt;给你一个大小为 &lt;code&gt;n x n&lt;/code&gt; 的整数矩阵 &lt;code&gt;board&lt;/code&gt; ，方格按从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n2&lt;/code&gt; 编号，</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.23</title>
    <link href="https://yonagi04.github.io/posts/2024/ef003dfe6d08/"/>
    <id>https://yonagi04.github.io/posts/2024/ef003dfe6d08/</id>
    <published>2024-04-23T10:09:57.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc207-课程表（MD）">lc207. 课程表（MD）</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><hr><p>拓扑排序题</p><p>深搜可以直接a出来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] vis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edges.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc210-课程表II（MD）">lc210. 课程表II（MD）</h2><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><ul><li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li></ul><hr><p>和上一题一样，处理思路总体来讲是相同的，就是这道题多了一个指针，用指针来控制返回数组元素的插入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] res;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] vis;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        idx = numCourses - <span class="number">1</span>;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edges.get(u)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="number">2</span>;</span><br><span class="line">        res[idx--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc208-实现Trie（MD）">lc208. 实现Trie（MD）</h2><p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10^4</code> 次</li></ul><hr><p>字典树经典题</p><p>简单来说就是把单词中的每一个字母都换成对应的索引，然后用索引来查找/存储这个单词</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc207-课程表（MD）&quot;&gt;lc207. 课程表（MD）&lt;/h2&gt;
&lt;p&gt;你这个学期必须选修 &lt;code&gt;numCourses&lt;/code&gt; 门课程，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;numCourses - 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.21</title>
    <link href="https://yonagi04.github.io/posts/2024/1f324b25e50d/"/>
    <id>https://yonagi04.github.io/posts/2024/1f324b25e50d/</id>
    <published>2024-04-21T10:23:44.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc200-岛屿数量（MD）">lc200. 岛屿数量（MD）</h2><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul><hr><p>深搜即可，碰到一个 ’1‘ 就开始深搜，岛屿数+1，直到搜不动了就说明走到边界。注意这里每搜完一个格子都要把这个格子的值改成 ’0‘ ，要不然就会无限循环，根本搜不到尽头的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, x - <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt; row &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, x, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt; col &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc130-被包围的区域（MD）">lc130. 被包围的区域（MD）</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>'X'</code> 或 <code>'O'</code></li></ul><hr><p>和上一题基本类似</p><p>先看样例：样例1中，贴近于边界的 ’O‘ 并没有被标记为 ’X‘；反之，完全没有靠近边界，被 ’X‘ 包围的三个 ’O’ 最后被标记为 ‘X’ 了。这给了我们一个思路：从边界位置开始深搜，如果搜到了一个 ‘O’，就做一个特殊标记（我给的标记是 ‘A’）；最后再对整个矩阵的每个格子做是否有标记的判断即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        row = board.length;</span><br><span class="line">        col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, col - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; col - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, row - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc133-克隆图（MD）">lc133. 克隆图（MD）</h2><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>这张图中的节点数在 <code>[0, 100]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li>每个节点值 <code>Node.val</code> 都是唯一的，</li><li>图中没有重复的边，也没有自环。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><hr><p>这道题看似复杂，实际上……额也没那么简单</p><p>我个人总结一下这道题的难点：</p><ol><li>要怎么处理好克隆出来的新节点和老节点的关系；如果出现了重复遍历的情况，怎么处理</li><li>怎么把邻居列表也克隆出来，换言之，怎么让邻居列表中的节点同样地去克隆出自己的新节点</li></ol><p>如果这道题是初见，且没有看过题解，那么看了样例非常容易晕头转向。假设在面试中，碰到这道题，你没有做过，你能在15分钟之内把它做出来吗？</p><p>这里给一个思路。对于难点1，我们考虑使用哈希表来存储老节点和新克隆节点；对于难点2，考虑使用搜索，当然是用dfs还是bfs随你的便，我个人是用的dfs，递归遍历节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment">    public Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; vis = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> vis.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cloneNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        vis.put(node, cloneNode);</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这道题也是中等难度，但我个人感觉这道题明显比前两题要难。不知道大家有没有这种感觉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc200-岛屿数量（MD）&quot;&gt;lc200. 岛屿数量（MD）&lt;/h2&gt;
&lt;p&gt;给你一个由 &lt;code&gt;&#39;1&#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&#39;0&#39;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Yonagi&#39;s Sekai的最新更新 24.4.20</title>
    <link href="https://yonagi04.github.io/posts/2024/8b92ddcc4300/"/>
    <id>https://yonagi04.github.io/posts/2024/8b92ddcc4300/</id>
    <published>2024-04-20T09:26:19.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>来自Yonagi’s Sekai Official的播报……</p><p>我们已于今日正式对 <code>Yonagi's Sekai</code> 进行版本更新. 以下是更新内容:</p><ol><li>重新设计的导航栏, 相较于以往的导航栏更加整洁, 易于区分</li><li>主页推送流、卡片、文章页均支持透明化</li><li>重新设计的右键功能，与本站风格匹配</li><li>夜间模式新增星空流星效果</li><li>新增日间夜间模式切换的动画效果</li><li>日间夜间模式支持不同背景</li></ol><hr><p>好了更新内容差不多就是这么多。我感觉折腾了那么几天，我都能速通前端了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来自Yonagi’s Sekai Official的播报……&lt;/p&gt;
&lt;p&gt;我们已于今日正式对 &lt;code&gt;Yonagi&#39;s Sekai&lt;/code&gt; 进行版本更新. 以下是更新内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重新设计的导航栏, 相较于以往的导航栏更加整洁, 易于区分&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客更新日志" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
    <category term="折腾" scheme="https://yonagi04.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="Javascript" scheme="https://yonagi04.github.io/tags/Javascript/"/>
    
    <category term="Html" scheme="https://yonagi04.github.io/tags/Html/"/>
    
    <category term="CSS" scheme="https://yonagi04.github.io/tags/CSS/"/>
    
    <category term="前端" scheme="https://yonagi04.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.18</title>
    <link href="https://yonagi04.github.io/posts/2024/698d04467461/"/>
    <id>https://yonagi04.github.io/posts/2024/698d04467461/</id>
    <published>2024-04-19T10:09:32.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>昨天没来得及写，今天补上</p><h2 id="lc103-二叉树的锯齿形遍历（MD）">lc103. 二叉树的锯齿形遍历（MD）</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><hr><p>经典层序遍历</p><p>但是要怎么做到在偶数层倒序遍历呢？可以标记一个boolean变量， 用这个变量判断是否要倒序输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                     que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                Collections.reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc530-二叉搜索树的最小绝对差（MD）">lc530. 二叉搜索树的最小绝对差（MD）</h2><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 10^4]</code></li><li><code>0 &lt;= Node.val &lt;= 10^5</code></li></ul><hr><p>根据二叉搜索树的特性，中序遍历二叉搜索树就能得到一个升序序列，那么根据中序遍历得到的升序序列就能找到最小绝对差</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.min(res, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc230-二叉搜索树中第k小的元素（MD）">lc230. 二叉搜索树中第k小的元素（MD）</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><p>**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p><hr><p>和上一题一样，中序遍历，但是这道题换个做法，我们不用递归了，我们用栈</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc98-验证二叉搜索树（MD）">lc98. 验证二叉搜索树（MD）</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左</p><p>子树</p><p>只包含</p><p>小于</p><p>当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><hr><p>中序遍历，先考虑左子树和中间节点值的大小关系，如果左子树的值不完全小于中间节点值，那么返回false，否则看右子树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">max</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &lt;= max.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天没来得及写，今天补上&lt;/p&gt;
&lt;h2 id=&quot;lc103-二叉树的锯齿形遍历（MD）&quot;&gt;lc103. 二叉树的锯齿形遍历（MD）&lt;/h2&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其节点值的 &lt;strong&gt;锯齿形层序遍历&lt;/strong&gt; </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.17</title>
    <link href="https://yonagi04.github.io/posts/2024/181dff02b8df/"/>
    <id>https://yonagi04.github.io/posts/2024/181dff02b8df/</id>
    <published>2024-04-17T19:48:20.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc236-二叉树的最近公共祖先-MD">lc236. 二叉树的最近公共祖先(MD)</h2><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 10^5]</code> 内。</li><li><code>-10^9 &lt;= Node.val &lt;= 10^9</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><hr><p>左右两边递归遍历二叉树</p><p>如果左右两边遍历结果都不为空(意味着一个节点在左子树, 一个节点在右子树), 那么最近的公共祖先就应该是当前的root节点. 反之, 如果有一侧是空的, 说明两个节点全部在另外一侧, 就得看另外一侧的结果了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc199-二叉树的右视图-MD">lc199. 二叉树的右视图(MD)</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><hr><p>二叉树层次遍历即可, 每遍历一层到最后一个节点就把这个节点的val值存进List</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc637-二叉树的层平均值-EZ">lc637. 二叉树的层平均值(EZ)</h2><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数量在 <code>[1, 104]</code> 范围内</li></ul><ul><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><hr><p>和上一题一样, 层序遍历. 遍历每一层的节点, 统计节点的和, 每一层遍历完之后, 再计算平均值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">ave</span> <span class="operator">=</span> sum / len;</span><br><span class="line">            res.add(ave);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc102-二叉树层序遍历-MD">lc102. 二叉树层序遍历(MD)</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><hr><p>还是老样子, 数组+队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc236-二叉树的最近公共祖先-MD&quot;&gt;lc236. 二叉树的最近公共祖先(MD)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>.vimrc文件的自定义配置——包括括号补全、代码高亮等</title>
    <link href="https://yonagi04.github.io/posts/2024/4330d2f23764/"/>
    <id>https://yonagi04.github.io/posts/2024/4330d2f23764/</id>
    <published>2024-04-17T18:42:07.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>这几天难得用回Linux写代码。用Linux写代码必然逃不开用vim（emacs另说，那玩意可比vim难用多了，当然vim本身也很难用）。因为重装过系统，原来的vimrc配置文件肯定没了，所以就重新搞了一个</p><p>放在下面，一方面是mark一下，另一方面是，说不定以后会有人看到，可以直接复制粘贴拿去用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax on &quot;自动语法高亮</span><br><span class="line">&quot;winpos 5 5          &quot; 设定窗口位置  </span><br><span class="line">&quot;set lines=40 columns=155    &quot; 设定窗口大小  </span><br><span class="line">&quot;set nu              &quot; 显示行号  </span><br><span class="line">set go=             &quot; 不要图形按钮  </span><br><span class="line">&quot;color asmanian2     &quot; 设置背景主题  </span><br><span class="line">set guifont=Courier_New:h10:cANSI   &quot; 设置字体  </span><br><span class="line">&quot;syntax on           &quot; 语法高亮  </span><br><span class="line">&quot;autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  </span><br><span class="line">&quot;autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行  </span><br><span class="line">&quot;set ruler           &quot; 显示标尺  </span><br><span class="line">set showcmd         &quot; 输入的命令显示出来，看的清楚些  </span><br><span class="line">&quot;set cmdheight=1     &quot; 命令行（在状态行下）的高度，设置为1  </span><br><span class="line">&quot;set whichwrap+=&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  </span><br><span class="line">&quot;set scrolloff=3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  </span><br><span class="line">set novisualbell    &quot; 不要闪烁(不明白)  </span><br><span class="line">&quot;set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容  </span><br><span class="line">&quot;set laststatus=1    &quot; 启动显示状态行(1),总是显示状态行(2)  </span><br><span class="line">set foldenable      &quot; 允许折叠  </span><br><span class="line">set foldmethod=manual   &quot; 手动折叠  </span><br><span class="line">&quot;set background=dark &quot;背景使用黑色 </span><br><span class="line">set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  </span><br><span class="line">&quot; 显示中文帮助</span><br><span class="line">if version &gt;= 603</span><br><span class="line">    set helplang=cn</span><br><span class="line">    set encoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot; 设置配色方案</span><br><span class="line">&quot;colorscheme murphy</span><br><span class="line">&quot;字体 </span><br><span class="line">&quot;if (has(&quot;gui_running&quot;)) </span><br><span class="line">&quot;   set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 </span><br><span class="line">&quot;endif </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=ucs-bom,utf-8,cp936</span><br><span class="line">set fileencoding=utf-8&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;新建.c,.h,.sh,.java文件，自动插入文件头 </span><br><span class="line">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; </span><br><span class="line">&quot;&quot;定义函数SetTitle，自动插入文件头 </span><br><span class="line">func SetTitle() </span><br><span class="line">    &quot;如果文件类型为.sh文件 </span><br><span class="line">    if &amp;filetype == &#x27;sh&#x27; </span><br><span class="line">        call setline(1,&quot;\#########################################################################&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;\# Author: 冷倾殇&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;\# mail: 1500428751@qq.com&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;\#!/bin/bash&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;&quot;) </span><br><span class="line">    else </span><br><span class="line">        call setline(1, &quot;/*************************************************************************&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: 冷倾殇&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: 1500428751@qq.com &quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;&quot;)</span><br><span class="line">    endif</span><br><span class="line"> &quot;   if &amp;filetype == &#x27;cpp&#x27;</span><br><span class="line"> &quot;       call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)</span><br><span class="line"> &quot;       call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)</span><br><span class="line"> &quot;       call append(line(&quot;.&quot;)+8, &quot;&quot;)</span><br><span class="line"> &quot;   endif</span><br><span class="line"> &quot;   if &amp;filetype == &#x27;c&#x27;</span><br><span class="line"> &quot;       call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)</span><br><span class="line"> &quot;       call append(line(&quot;.&quot;)+7, &quot;&quot;)</span><br><span class="line"> &quot;   endif</span><br><span class="line">    &quot;新建文件后，自动定位到文件末尾</span><br><span class="line">    autocmd BufNewFile * normal G</span><br><span class="line">endfunc </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;键盘命令</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nmap &lt;leader&gt;w :w!&lt;cr&gt;</span><br><span class="line">nmap &lt;leader&gt;f :find&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; 映射全选+复制 ctrl+a</span><br><span class="line">map &lt;C-A&gt; ggVGY</span><br><span class="line">map! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span><br><span class="line">map &lt;F12&gt; gg=G</span><br><span class="line">&quot; 选中状态下 Ctrl+c 复制</span><br><span class="line">vmap &lt;C-c&gt; &quot;+y</span><br><span class="line">&quot;去空行  </span><br><span class="line">nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; </span><br><span class="line">&quot;比较文件  </span><br><span class="line">nnoremap &lt;C-F2&gt; :vert diffsplit </span><br><span class="line">&quot;新建标签  </span><br><span class="line">map &lt;M-F2&gt; :tabnew&lt;CR&gt;  </span><br><span class="line">&quot;列出当前目录文件  </span><br><span class="line">map &lt;F3&gt; :tabnew .&lt;CR&gt;  </span><br><span class="line">&quot;打开树状文件目录  </span><br><span class="line">map &lt;C-F3&gt; \be  </span><br><span class="line">&quot;C，C++ 按F5编译运行</span><br><span class="line">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;</span><br><span class="line">func! CompileRunGcc()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    if &amp;filetype == &#x27;c&#x27;</span><br><span class="line">        exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">        exec &quot;! ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;cpp&#x27;</span><br><span class="line">        exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">        exec &quot;! ./%&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;java&#x27; </span><br><span class="line">        exec &quot;!javac %&quot; </span><br><span class="line">        exec &quot;!java %&lt;&quot;</span><br><span class="line">    elseif &amp;filetype == &#x27;sh&#x27;</span><br><span class="line">        :!./%</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">&quot;C,C++的调试</span><br><span class="line">map &lt;F8&gt; :call Rungdb()&lt;CR&gt;</span><br><span class="line">func! Rungdb()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -g -o %&lt;&quot;</span><br><span class="line">    exec &quot;!gdb ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;实用设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 设置当文件被改动时自动载入</span><br><span class="line">set autoread</span><br><span class="line">&quot; quickfix模式</span><br><span class="line">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span><br><span class="line">&quot;代码补全 </span><br><span class="line">set completeopt=preview,menu </span><br><span class="line">&quot;允许插件  </span><br><span class="line">filetype plugin on</span><br><span class="line">&quot;共享剪贴板  </span><br><span class="line">set clipboard+=unnamed </span><br><span class="line">&quot;从不备份  </span><br><span class="line">set nobackup</span><br><span class="line">&quot;make 运行</span><br><span class="line">:set makeprg=g++\ -Wall\ \ %</span><br><span class="line">&quot;自动保存</span><br><span class="line">set autowrite</span><br><span class="line">&quot;set ruler                   &quot; 打开状态栏标尺</span><br><span class="line">set cursorline              &quot; 突出显示当前行</span><br><span class="line">set magic                   &quot; 设置魔术</span><br><span class="line">set guioptions-=T           &quot; 隐藏工具栏</span><br><span class="line">set guioptions-=m           &quot; 隐藏菜单栏</span><br><span class="line">&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span><br><span class="line">&quot; 设置在状态行显示的信息</span><br><span class="line">set foldcolumn=0</span><br><span class="line">set foldmethod=indent </span><br><span class="line">set foldlevel=3 </span><br><span class="line">set foldenable              &quot; 开始折叠</span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 语法高亮</span><br><span class="line">set syntax=on</span><br><span class="line">&quot; 去掉输入错误的提示声音</span><br><span class="line">set noeb</span><br><span class="line">&quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set confirm</span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">&quot; Tab键的宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot; 不要用空格代替制表符</span><br><span class="line">set noexpandtab</span><br><span class="line">&quot; 在行和段开始处使用制表符</span><br><span class="line">set smarttab</span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line">&quot; 历史记录数</span><br><span class="line">set history=1000</span><br><span class="line">&quot;禁止生成临时文件</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;搜索忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot;搜索逐字符高亮</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">&quot;行内替换</span><br><span class="line">set gdefault</span><br><span class="line">&quot;编码设置</span><br><span class="line">set enc=utf-8</span><br><span class="line">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line">&quot;语言设置</span><br><span class="line">set langmenu=zh_CN.UTF-8</span><br><span class="line">set helplang=cn</span><br><span class="line">&quot; 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line">&quot;set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span><br><span class="line">&quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]</span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">&quot;set laststatus=2</span><br><span class="line">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line">set cmdheight=2</span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line">&quot; 保存全局变量</span><br><span class="line">set viminfo+=!</span><br><span class="line">&quot; 带有如下符号的单词不要被换行分割</span><br><span class="line">set iskeyword+=_,$,@,%,#,-</span><br><span class="line">&quot; 字符间插入的像素行数目</span><br><span class="line">set linespace=0</span><br><span class="line">&quot; 增强模式中的命令行自动完成操作</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set backspace=2</span><br><span class="line">&quot; 允许backspace和光标键跨越行边界</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line">set report=0</span><br><span class="line">&quot; 在被分割的窗口间显示空白，便于阅读</span><br><span class="line">set fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=1</span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line">&quot; 为C程序提供自动缩进</span><br><span class="line">set smartindent</span><br><span class="line">&quot; 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line">au BufRead,BufNewFile *  setfiletype txt</span><br><span class="line">&quot;自动补全</span><br><span class="line">:inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">:inoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt;</span><br><span class="line">:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line">:inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt;</span><br><span class="line">:inoremap [ []&lt;ESC&gt;i</span><br><span class="line">:inoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt;</span><br><span class="line">:inoremap &quot; &quot;&quot;&lt;ESC&gt;i</span><br><span class="line">:inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span><br><span class="line">function! ClosePair(char)</span><br><span class="line">    if getline(&#x27;.&#x27;)[col(&#x27;.&#x27;) - 1] == a:char</span><br><span class="line">        return &quot;\&lt;Right&gt;&quot;</span><br><span class="line">    else</span><br><span class="line">        return a:char</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line">filetype plugin indent on </span><br><span class="line">&quot;打开文件类型检测, 加了这句才可以用智能补全</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; CTags的设定  </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let Tlist_Sort_Type = &quot;name&quot;    &quot; 按照名称排序  </span><br><span class="line">let Tlist_Use_Right_Window = 1  &quot; 在右侧显示窗口  </span><br><span class="line">let Tlist_Compart_Format = 1    &quot; 压缩方式  </span><br><span class="line">let Tlist_Exist_OnlyWindow = 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  </span><br><span class="line">let Tlist_File_Fold_Auto_Close = 0  &quot; 不要关闭其他文件的tags  </span><br><span class="line">let Tlist_Enable_Fold_Column = 0    &quot; 不要显示折叠树  </span><br><span class="line">autocmd FileType java set tags+=D:\tools\java\tags  </span><br><span class="line">&quot;autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  </span><br><span class="line">&quot;let Tlist_Show_One_File=1            &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">&quot;设置tags  </span><br><span class="line">set tags=tags  </span><br><span class="line">&quot;set autochdir </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;其他东东</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;默认打开Taglist </span><br><span class="line">let Tlist_Auto_Open=1 </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; </span><br><span class="line">&quot; Tag list (ctags) </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; </span><br><span class="line">let Tlist_Ctags_Cmd = &#x27;/usr/bin/ctags&#x27; </span><br><span class="line">let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 </span><br><span class="line">let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim </span><br><span class="line">let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口</span><br><span class="line">&quot; minibufexpl插件的一般设置</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1 </span><br><span class="line">let g:miniBufExplModSelTarget = 1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天难得用回Linux写代码。用Linux写代码必然逃不开用vim（emacs另说，那玩意可比vim难用多了，当然vim本身也很难用）。因为重装过系统，原来的vimrc配置文件肯定没了，所以就重新搞了一个&lt;/p&gt;
&lt;p&gt;放在下面，一方面是mark一下，另一方面是，说不定以</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="折腾" scheme="https://yonagi04.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="Linux" scheme="https://yonagi04.github.io/tags/Linux/"/>
    
    <category term="Vim" scheme="https://yonagi04.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Yonagi&#39;s Sekai的最新更新 24.4.17</title>
    <link href="https://yonagi04.github.io/posts/2024/3de3063195cc/"/>
    <id>https://yonagi04.github.io/posts/2024/3de3063195cc/</id>
    <published>2024-04-17T10:32:20.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>最近在考虑美化Yonagi’s Sekai， 看完了网上流传的一些参考资料之后，决定说干就干</p><p>目前的更新</p><ul><li>侧边栏新增加访客地区所在时间和访客所在地区天气（插件实现）</li><li>调节了主页背景图片局部的亮度和对比度（PS改的）</li><li>实现主页背景图片一图流全屏显示，相较于以前的方格背景，会更加精致（js代码实现）</li><li>实现随机跳转访问文章功能（js代码实现）</li></ul><p>只能说还得是Hexo，如果是WordPress我都不知道要怎么改。只能说比起PHP，我还是比较懂前端的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在考虑美化Yonagi’s Sekai， 看完了网上流传的一些参考资料之后，决定说干就干&lt;/p&gt;
&lt;p&gt;目前的更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;侧边栏新增加访客地区所在时间和访客所在地区天气（插件实现）&lt;/li&gt;
&lt;li&gt;调节了主页背景图片局部的亮度和对比度（PS改的）&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="博客更新日志" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
    <category term="折腾" scheme="https://yonagi04.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="Javascript" scheme="https://yonagi04.github.io/tags/Javascript/"/>
    
    <category term="Html" scheme="https://yonagi04.github.io/tags/Html/"/>
    
    <category term="CSS" scheme="https://yonagi04.github.io/tags/CSS/"/>
    
    <category term="前端" scheme="https://yonagi04.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JUC专题——Java并发基础</title>
    <link href="https://yonagi04.github.io/posts/2024/c7a9814e39de/"/>
    <id>https://yonagi04.github.io/posts/2024/c7a9814e39de/</id>
    <published>2024-04-16T16:57:13.000Z</published>
    <updated>2025-05-18T09:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自《Java并发编程的艺术》</strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>线程</h1><p>现代操作系统调度的最小单元是 <strong>线程</strong> , 也叫 <strong>轻量级进程</strong> . 一个进程里可以创建多个线程, 线程拥有各自的计数器, 堆栈和局部变量, 并且能够访问共享的内存变量</p><h2 id="线程优先级">线程优先级</h2><p>现代操作系统使用时分的形式调度运行的线程, 操作系统会分出一个个时间片, 线程会分配到若干时间片, 当线程的时间片用完了就会发生线程调度, 并等待下次分配. 时间片多少决定了线程使用处理器资源的多少, 而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性</p><p>在 Java 线程中, 通过整型成员变量 <code>priority</code> 控制优先级, 优先级的范围是 1~10, 线程构建时可以通过 <code>setPriority()</code> 方法来修改优先级, 默认的优先级为 5. 优先级高的线程分配时间片的数量要多于优先级低的线程.</p><p>设置优先级时, 对于频繁阻塞(休眠或 I/O操作) 的线程需要设置较高优先级, 对于偏重计算的线程需要设置较低的优先级, 确保处理器不会被独占.</p><p>在不同JVM和不同操作系统上, 线程规划会存在差异, 有的操作系统会忽视对线程优先级的设定</p><h2 id="线程状态">线程状态</h2><p>Java 线程在生命周期中可能处于如下的6种状态. 在给定的任意时刻, 线程只能处于其中一个状态</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>NEW</strong></td><td>线程被创建, 但是没有调用 <code>start()</code> 方法</td></tr><tr><td><strong>RUNNABLE</strong></td><td>允许状态, Java 线程将操作系统中就绪和运行两种状态笼统地称为 “运行中”</td></tr><tr><td><strong>BLOCKED</strong></td><td>阻塞状态, 表示线程被锁阻塞</td></tr><tr><td><strong>WAITING</strong></td><td>等待状态, 表示线程进入等待状态, 进入该状态表示当前线程需要等待其他线程做出特定动作</td></tr><tr><td><strong>TIME_WAITING</strong></td><td>超时等待, 该状态不同于WAITING, 它是可以在指定的时间自行返回的</td></tr><tr><td><strong>TERMINATED</strong></td><td>终止状态, 线程已经执行完毕</td></tr></tbody></table><p>线程创建之后, 调用 <code>start()</code> 方法开始运行, 执行 <code>wait()</code> 方法, 线程进入等待状态, 进入等待状态的线程需要依靠其他线程的通知才能回到运行状态, 而超时等待状态相当于在等待状态的基础上增加了超时限制, 也就是超时时间到达时会自动恢复到运行状态. 当线程调用同步方法时, 在没有获取到锁的情况下, 线程会进入阻塞状态. 线程在执行 <code>Runnable</code> 的 <code>run()</code> 方法之后会进入到终止状态</p><h2 id="Daemon线程">Daemon线程</h2><p>Daemon线程是一种支持型线程, 因为它主要被用作程序中后台调度和支持性工作. 这意味着, 当一个JVM中不存在非Daemon线程时, JVM会退出</p><p>可以通过 <code>Thread</code> 的 <code>Thread.setDaemon(true)</code> 将一个线程设置为 Daemon线程</p><p><strong>必须在启动线程之前就设置好这个线程是否是Daemon线程, 不能在启动之后再设置, 否则会报错</strong></p><h1>启动和终止线程</h1><h2 id="构建线程">构建线程</h2><p>在运行线程之前要构造一个线程对象, 线程对象在构造时候需要提供线程所需要的属性, 如线程所属的线程组, 优先级, 是否为Daemon线程等信息</p><h2 id="启动线程">启动线程</h2><p>线程对象在初始化完成之后, 调用 <code>start()</code> 方法就能启动线程.</p><h2 id="中断">中断</h2><p>中断表示一个运行中的线程是否被其他线程进行了终端操作. 其他线程通过调用该线程的 <code>interrupt()</code> 方法对其进行中断操作</p><p>线程通过检查自身是否被中断来进行响应, 线程通过方法 <code>inInterrupted()</code> 来进行判断是否被中断, 也可以调用静态方法 <code>Thread.interrupted()</code> 对当前线程的中断标记位进行复位.</p><h2 id="终止线程">终止线程</h2><p>中断操作是一种简便的线程间交互方式, 且这种交互方式最适合用来取消或停止任务. 除了中断以外, 还可以利用一个boolean变量来控制是否需要停止任务并终止该线程</p><h1>线程间通信</h1><h2 id="volatile-和-synchronized">volatile 和 synchronized</h2><p>关键字 <strong>volatile</strong> 可以用来修饰字段, 告知程序任何对该变量的访问均需要从共享内存获取, 而对于它的改变必须刷新回到共享内存, 它能保证所有线程对变量访问的可见性</p><p>关键字 <strong>synchronized</strong> 可以修饰方法或者以同步块的形式来进行使用, 它主要保证多个线程在同一时刻只有一个线程处于方法或同步代码块中, 保证线程对变量访问的可见性和排他性</p><h2 id="等待-通知机制">等待/通知机制</h2><p>一个线程修改了一个对象的值, 而另一个线程感知到了变化, 然后进行相应的操作, 整个过程开始于一个线程, 而最终执行又是另一个线程.</p><p>Java 通过内置的 <strong>等待/通知</strong> 机制解决了这个问题</p><p>等待/通知机制是所有Java对象都具备的, 因为这些方法被定义在 <code>java.lang.Object</code> 内部</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>notify()</code></td><td>通知一个在对象上等待的线程, 使其从 <code>wait()</code> 方法返回, 返回的前提是该线程拿到了对象的锁</td></tr><tr><td><code>notifyAll()</code></td><td>通知所有等待在该对象上的线程</td></tr><tr><td><code>wait()</code></td><td>调用该方法的线程进入 <code>WAITING</code> 状态, 只有等待另外线程的通知或者被中断才会返回, 需要注意, 调用 <code>wait()</code> 方法之后, 会释放对象的锁</td></tr><tr><td><code>wait(long)</code></td><td>超市等待一段时间, 这里的参数单位是毫秒</td></tr><tr><td><code>wait(long, int)</code></td><td>对于超时时间更细粒度的控制, 可以精确到纳秒</td></tr></tbody></table><p>等待/通知机制, 是指一个线程 A 调用了对象 O 的 <code>wait()</code> 方法进入等待状态, 而另一个对象 B 调用了对象 O 的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法, 线程 A 收到通知后从对象 O 的 <code>wait()</code> 方法返回, 进而执行后续操作. 上述两个线程通过对象 O 完成交互, 而对象上的 <code>wait()</code> 和 <code>notify()/notifyAll()</code> 就像是开关信号一样, 用来完成等待方和通知方之间的交互工作</p><p>使用 <code>wait()</code> 和 <code>notify() / notifyAll()</code> 需要注意的细节</p><ol><li>使用 <code>wait()</code> , <code>notify()</code> 和 <code>notifyAll()</code> 时需要先对调用对象加锁</li><li>调用 <code>wait()</code> 方法后, 线程状态由 <code>RUNNING</code> 变为 <code>WAITING</code>, 并将当前线程放置到对象的等待队列</li><li><code>notify()</code> 或 <code>notifyAll()</code> 方法调用之后, 等待线程仍然不会从 <code>wait()</code> 返回, 需要调用 <code>notify()</code> 或 <code>notifyAll()</code> 的线程释放锁之后, 等待线程才有机会从 <code>wait()</code> 返回</li><li><code>notify()</code> 方法将等待队列中的一个等待线程从等待队列中移到同步队列中, 而 <code>notifyAll()</code> 方法则是将等待队列中所有的线程全部移到同步队列, 被移动的队列状态由 <code>WAITING</code> 变为 <code>BLOCKED</code></li><li>从 <code>wait()</code> 方法返回的前提是获得了调用对象的锁</li></ol><h2 id="管道输入-输出流">管道输入/输出流</h2><p>管道输入/输出流主要用于线程之间的数据传输, 而传输的媒介是内存</p><p>管道输入/输出流有四种实现: PipedOutputStream, PipedInputStream, PipedReader, PipedWriter, 前两种面向字节, 后两者面向字符</p><h2 id="Thread-join-的使用"><code>Thread.join()</code> 的使用</h2><p>如果一个线程 A 执行了 <code>thread.join()</code> 语句, 其含义是: 当前线程 A 等待thread线程终止之后才从 <code>thread.join()</code> 返回. 线程 Thread 除了提供 <code>join()</code> 方法之外, 还提供了 <code>join(long millis)</code> 和 <code>join(long millis, int nanos)</code> 两个具备超时特性的方法. 这两个超时方法表示如果线程thread在给定的超时时间内没有终止, 那么将会从超时方法中返回</p><h2 id="ThreadLocal-的使用">ThreadLocal 的使用</h2><p>ThreadLocal, 即线程变量, 是一个以 ThreadLocal对象为键, 任意对象为值的存储结构, 这个结构被携带在线程上, 也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值</p><p>可以通过 <code>set(T)</code> 方法来设置一个值, 在当前线程下可以通过 <code>get()</code> 方法获取到原先设置的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自《Java并发编程的艺术》&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🚀 &lt;a href=&quot;https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/&quot;&gt;基础（上）&lt;/a&gt; → </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.16</title>
    <link href="https://yonagi04.github.io/posts/2024/f607678b7a83/"/>
    <id>https://yonagi04.github.io/posts/2024/f607678b7a83/</id>
    <published>2024-04-16T13:41:07.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc112-路径总和（MD）">lc112. 路径总和（MD）</h2><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><hr><p>左右子树递归地查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc129-求根节点到叶节点数字之和（MD）">lc129. 求根节点到叶节点数字之和（MD）</h2><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 = 12 + 13 = 25</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><hr><p>深搜即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> prevsum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevsum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc124-二叉树中的最大路径和（HD）">lc124. 二叉树中的最大路径和（HD）</h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><hr><p>左右子树，递归查找</p><p>这里借用一下leetcode官方题解的配图, 看了配图就很容易理解了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/1.PNG" alt="1"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/2.PNG" alt="2"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/3.PNG" alt="3"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/4.PNG" alt="4"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/5.PNG" alt="5"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/6.PNG" alt="6"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/solution-static/124/7.PNG" alt="7"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewPath</span> <span class="operator">=</span> root.val + leftGain + rightGain;</span><br><span class="line">        maxSum = Math.max(maxSum, priceNewPath);</span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc222-完全二叉树的节点个数（EZ）">lc222. 完全二叉树的节点个数（EZ）</h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p>**进阶：**遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p><hr><p>最简单的方法：层级遍历，遍历一层，统计这一层的节点个数，然后就能计算出总节点个数</p><p>但是这种方法没有利用好完全二叉树的特性</p><p>当完全二叉树的底层节点全部填满时，完全二叉树就是满二叉树，根据数据结构相关知识，假设满二叉树高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ， 那么满二叉树的节点数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 ^ n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>利用这个特性，就能很快计算出完全二叉树的节点个数——左右两边分别计算高度，假如高度相等就能用二叉树高度直接计算节点个数；假如不等就左右子树分别递归计算高度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCnt</span> <span class="operator">=</span> <span class="number">0</span>, rightCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            leftNode = leftNode.left;</span><br><span class="line">            leftCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            rightNode = rightNode.right;</span><br><span class="line">            rightCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftCnt == rightCnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftCnt) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc112-路径总和（MD）&quot;&gt;lc112. 路径总和（MD）&lt;/h2&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; 和一个表示目标和的整数 &lt;code&gt;targetSum&lt;/code&gt; 。判断该树中是否存在 &lt;strong&gt;根节点到叶子节点&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JUC专题——Java并发机制的底层实现原理</title>
    <link href="https://yonagi04.github.io/posts/2024/6cc2fd2cd422/"/>
    <id>https://yonagi04.github.io/posts/2024/6cc2fd2cd422/</id>
    <published>2024-04-16T10:31:07.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自《Java并发编程的艺术》</strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>volatile 的应用</h1><p>volatile 是轻量级的 synchronized, 它在多处理器开发中保证了共享变量的 “可见性”. 可见性的意思是当一个线程修改一个共享变量时, 另外一个线程能读到这个修改的值. 如果 volatile变量修饰符使用恰当的话, 它比 synchronized 的使用和执行成本更低, 因为它不会引起线程上下文切换和调度</p><h2 id="volatile-的定义和实现原理">volatile 的定义和实现原理</h2><p>Java 语言规范中对 volatile 的定义如下: <strong>Java 编程语言允许线程访问共享变量, 为了保证共享变量能被准确和一致地更新, 线程应该确保通过排他锁单独获得这个变量</strong> . 如果一个变量被声明为 volatile, 那么 Java 线程内存模型保证所有线程看到这个变量的值是一致的</p><p>volatile 的两条实现原则</p><ol><li><strong>Lock前缀指令会引起处理器缓存写回到内存</strong> .</li><li><strong>一个处理器缓存回写到内存会导致其他处理器的缓存无效</strong> .</li></ol><h2 id="volatile-的使用优化">volatile 的使用优化</h2><p>JDK7的并发包中新增了一个队列集合类 <code>LinkedTransferQueue</code> , 它在使用 volatile 变量时, 通过一种追加字节的方式来优化队列出队和入队的性能. LinkedTransferQueue的代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PaddedAtomicReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AtomicReference</span>&lt;T&gt; &#123;</span><br><span class="line">    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line">        <span class="built_in">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReference</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么追加字节能优化性能?</strong> 先看看 LinkedTransferQueue 这个类, 它使用一个内部类类型定义了队列的头节点和尾节点, 而内部类 PaddedAtomicReference 相对于父类 AtomicReference 只做了一件事情, 就是将共享变量追加到64字节.</p><p><strong>为什么追加到64字节能提高并发编程的效率?</strong> 因为对于三级缓存的缓存行为64字节宽的CPU而言, 如果队列的头节点和尾节点都不足64字节, 处理器会将它们都读到同一个缓存行中, 在多处理器下每个处理器都会缓存同样的头, 尾节点, 当一个处理器试图修改头节点时, 会把整个缓存行锁定, 在缓存一致性机制的作用下, 其他处理器就不能访问自己缓存行下的尾节点, 而队列的入队和出队需要不停修改头节点和尾节点, 在多处理器环境下将会严重影响到队列的入队和出队效率. 使用64字节填满高速缓存的缓存行, 避免头节点和尾节点都加载到同一个缓存行, 使头尾节点修改时不会相互锁定</p><p><strong>是否在使用 volatile 变量时都需要追加到64字节?</strong></p><p>并非如此, 在两种场景下不应该使用这种模式</p><ul><li><strong>缓存行非64字节宽的处理器</strong></li><li><strong>共享变量不会被频繁地写</strong></li></ul><h1>synchronized 的实现原理和应用</h1><p>synchronized实现同步的基础: Java中的每个对象都能作为锁</p><ul><li>对于普通同步方法, 锁是当前实例对象</li><li>对于静态同步方法, 锁是当前类的 Class 对象</li><li>对于同步方法块, 锁是 synchronized 括号中配置的对象</li></ul><h2 id="Java-对象头">Java 对象头</h2><p>synchronized用的锁是存在 Java 对象头的, 如果对象是数组类型, 则虚拟机用3个字宽存储对象头, 如果对象是非数组类型, 则用2字宽存储对象头. 在32位虚拟机中, 1字宽等于4字节, 即32bit</p><p>Java 对象头中的 Mark Word里默认存储对象的 HashCode, 分代年龄和锁标记位. 32位JVM的 Mark Word的默认存储结构如表所示</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>在运行期间, Mark Word里存储的数据会随着锁标志位的变化而变化. Mark Word可能变化为以下 4 种数据</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/JUC-synchronized-markword.png" alt=""></p><h2 id="锁的升级与对比">锁的升级与对比</h2><p>在 JDK1.6 中, 锁一共有 4 种形态, 级别由低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态, 重量级锁状态</p><p>锁可以升级但不能降级, 意味着偏向锁升级为轻量级锁之后不能再降级为偏向锁. 这种锁升级却不能降级的策略目的是为了提高获得锁和释放锁的效率</p><ol><li>偏向锁</li></ol><p>当一个线程访问同步块并获得锁时, 会在对象头和栈帧的锁记录中存储锁偏向的线程ID, 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁, 只需要简单地测试对象头的Mark Word中是否存储了指向当前线程的偏向锁. 如果测试成功, 表示线程已经获得了锁, 如果测试失败, 则需要再测试一下Mark Word中偏向锁的标识是否设置为1: 如果没有设置, 则使用CAS竞争锁, 如果设置了, 则尝试使用CAS将对象头的偏向锁指向当前线程</p><p>(1) 偏向锁的撤销</p><p><strong>只有当其他线程试图竞争偏向锁时, 持有偏向锁的线程才会释放锁</strong></p><p>偏向锁的撤销, 首先要暂停拥有偏向锁的线程, 然后检查持有偏向锁的线程是否活着, 如果线程处于不活动状态, 则将对象头设置成无锁状态; 如果线程仍然或者, 拥有偏向锁的栈会被执行, 遍历偏向对象的锁记录, 栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程, 要么恢复到无锁或者标记对象不适合作为偏向锁, 最后唤醒暂停的线程</p><p>(2) 关闭偏向锁</p><p>Java6 和 Java7 默认启用了偏向锁, 关闭可以使用参数 <code>-XX:BiasedLockingStartupDelay=0</code></p><ol start="2"><li>轻量级锁</li></ol><p>(1) 轻量级锁加锁</p><p>线程在执行同步代码块之前, JVM会在当前线程的栈帧中创建用于存储锁记录的空间, 并将对象头中的 Mark Word复制到锁记录中. 然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针, 如果成功, 当前线程获得锁, 如果失败, 表示其他线程竞争锁, 当前线程就会通过自旋来获得锁</p><p>(2) 轻量级锁解锁</p><p>轻量级锁解锁时, 会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头, 如果成功, 则表示没有竞争发生, 如果失败, 则表示锁存在竞争, 锁会膨胀为重量级锁</p><p>因为自旋会消耗CPU, 为了避免无用的自旋, 当锁升级到重量级锁之后, 就不会再恢复到轻量级锁状态了. 其他线程试图获取这个锁时都会被阻塞</p><ol start="3"><li>锁的优缺点对比</li></ol><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗, 和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争, 会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞, 提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程, 使用自旋会消耗CPU</td><td>追求响应时间, 同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不会使用自旋, 不消耗CPU</td><td>线程阻塞, 响应时间缓慢</td><td>追求吞吐量, 同步块执行实际长</td></tr></tbody></table><h1>原子操作的实现原理</h1><p>原子操作意为 “不可被中断的一个或一系列操作”</p><p>在 Java 中 通过 <strong>锁</strong> 和 <strong>CAS循环</strong> 的方式实现原子操作</p><p>(1) 使用 CAS循环 实现原子操作</p><p>自旋CAS实现基本思路就是循环进行CAS操作直到成功为止</p><p>使用CAS实现原子操作会带来三大问题: <strong>ABA问题</strong> , <strong>循环时间长开销大</strong> , <strong>只能保证一个共享变量的原子操作</strong></p><ol><li><strong>ABA问题</strong></li></ol><p>因为 CAS需要在操作值的时候, 检查值是否变化, 如果没有变化就更新, 但是如果一个值原来是 A, 变成了B, 又变回了A, 那么使用CAS进行检查时就会发现值没有变化, 但实际上已经发生过变化了. ABA问题的解决方案是使用版本号, 每次变量更新就把版本号加1.</p><ol start="2"><li><strong>循环时间长开销大</strong></li></ol><p>自旋CAS如果长时间不成功, 会给CPU带来非常大的执行开销. 如果JVM能支持处理器提供的pause指令, 那么效率会有一定的提升</p><ol start="3"><li><strong>只能保证一个共享变量的原子操作</strong></li></ol><p>当对一个共享变量执行操作时, 我们可以使用循环CAS的方式来保证原子操作, 但是对多个共享变量进行操作时, 循环CAS就无法保证操作的原子性, 这时候就可以用锁</p><p>(2) 使用锁机制实现原子操作</p><p>锁机制保证了只有获得锁的线程才能操作锁定的内存区域. JVM内部实现了很多锁, 有偏向锁, 轻量级锁和互斥锁, 但是除了偏向锁, 其他实现锁的方式都使用了循环CAS: 当一个线程想进入同步块时使用循环CAS来获取锁, 当它想退出同步块使用循环CAS释放锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自《Java并发编程的艺术》&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🚀 &lt;a href=&quot;https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/&quot;&gt;基础（上）&lt;/a&gt; → </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.15</title>
    <link href="https://yonagi04.github.io/posts/2024/e73f31672b4b/"/>
    <id>https://yonagi04.github.io/posts/2024/e73f31672b4b/</id>
    <published>2024-04-15T10:08:21.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc105-从前序和中序遍历序列构造二叉树（MD）">lc105. 从前序和中序遍历序列构造二叉树（MD）</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><hr><p>用一个栈和一个指针辅助构造。依次遍历前序序列的每一个节点，如果index和栈顶节点不同，就把当前节点作为栈顶节点的左儿子；如果index恰好指向栈顶节点，那么不断弹出栈顶节点并移动index</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preorderVal</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stk.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">                stk.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorderVal);</span><br><span class="line">                stk.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc106-从中序和后序遍历序列构造二叉树（MD）">lc106. 从中序和后序遍历序列构造二叉树（MD）</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><hr><p>和上一题思路一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="literal">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> inorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">postorderVal</span> <span class="operator">=</span> postorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stk.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stk.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stk.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorderVal);</span><br><span class="line">                stk.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc117-填充每个节点的下一个右侧节点指针-II（MD）">lc117. 填充每个节点的下一个右侧节点指针 II（MD）</h2><p>给定一个二叉树：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 6000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li></ul><hr><p>暂时不考虑进阶要求，其实是我写不出来</p><p>有点类似于二叉树层级遍历，思路上总体相似</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            que.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    next = que.poll();</span><br><span class="line">                    node = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    next = que.poll();</span><br><span class="line">                    node.next = next;</span><br><span class="line">                    node = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(next.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    que.offer(next.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc114-二叉树展开为链表（MD）">lc114. 二叉树展开为链表（MD）</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><hr><p>找到左子树最右边的节点以便于右子树连接过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = root.right;</span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="literal">null</span>;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc105-从前序和中序遍历序列构造二叉树（MD）&quot;&gt;lc105. 从前序和中序遍历序列构造二叉树（MD）&lt;/h2&gt;
&lt;p&gt;给定两个整数数组 &lt;code&gt;preorder&lt;/code&gt; 和 &lt;code&gt;inorder&lt;/code&gt; ，其中 &lt;code&gt;preord</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.9</title>
    <link href="https://yonagi04.github.io/posts/2024/14a8a650a0d6/"/>
    <id>https://yonagi04.github.io/posts/2024/14a8a650a0d6/</id>
    <published>2024-04-09T13:20:55.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc104-二叉树最大深度（EZ）">lc104. 二叉树最大深度（EZ）</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 10^4]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><hr><p>左子树右子树分别递归</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc100-相同的树（EZ）">lc100. 相同的树（EZ）</h2><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2], q = [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,1], q = [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li></ul><hr><p>左右两边递归地去查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc226-翻转二叉树（EZ）">lc226. 翻转二叉树（EZ）</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><hr><p>左右两边，递归地去交换节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc101-对称二叉树（EZ）">lc101. 对称二叉树（EZ）</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？</p><hr><p>递归地去判断（没错今天的题都是递归题）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc104-二叉树最大深度（EZ）&quot;&gt;lc104. 二叉树最大深度（EZ）&lt;/h2&gt;
&lt;p&gt;给定一个二叉树 &lt;code&gt;root&lt;/code&gt; ，返回其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的 &lt;strong&gt;最大深度&lt;/strong&gt; 是指从根节点到最远叶子节点的最长</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.8</title>
    <link href="https://yonagi04.github.io/posts/2024/779fd516e825/"/>
    <id>https://yonagi04.github.io/posts/2024/779fd516e825/</id>
    <published>2024-04-08T16:10:39.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc92-反转链表-II（MD）">lc92. 反转链表 II（MD）</h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p><hr><p>如果要实现进阶要求，可以考虑使用双指针</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png" alt=""></p><p>简单来说就是这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            next.next = pre.next;</span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc19-删除链表的倒数第N个节点（MD）">lc19. 删除链表的倒数第N个节点（MD）</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p>**进阶：**你能尝试使用一趟扫描实现吗？</p><hr><p>和上一题一样，如果要实现进阶要求，可以用双指针</p><p>自行推导一下就可以了。这里解释一下为什么一开始要先做一个循环n次的fast指针移动：此处我们假设链表长度为len，快指针移动的总长度应该为len，如果我们一开始就先进行预处理，先做循环n次的fast指针移动，那么后面快慢指针一起移动的时候就只需要移动len-n次，此时慢指针就正好指到倒数的第n个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc82-删除排序链表的重复元素-II（MD）">lc82. 删除排序链表的重复元素 II（MD）</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><hr><p>如果出现了前一个节点的值等于后一个节点的值，跳过去即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc61-旋转链表（MD）">lc61. 旋转链表（MD）</h2><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 2 * 10^9</code></li></ul><hr><p>首先，这种旋转肯定不是简简单单的“旋转”，其实只需要判断旋转后链表的头节点是哪一个节点，然后断开它和上一个节点的联系，然后修改尾节点指向即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k == <span class="number">0</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">iter</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            iter = iter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> len - k % len;</span><br><span class="line">        <span class="keyword">if</span> (add == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        iter.next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; add; i++) &#123;</span><br><span class="line">            iter = iter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> iter.next;</span><br><span class="line">        iter.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc86-分隔链表（MD）">lc86. 分隔链表（MD）</h2><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,4,3,2,5,2], x = 3</span><br><span class="line">输出：[1,2,2,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [2,1], x = 2</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-200 &lt;= x &lt;= 200</code></li></ul><hr><p>先用两个链表分开存，最后把两个链表连接起来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">small</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallHead</span> <span class="operator">=</span> small;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">large</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeHead</span> <span class="operator">=</span> large;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                small.next = head;</span><br><span class="line">                small = small.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                large.next = head;</span><br><span class="line">                large = large.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        large.next = <span class="literal">null</span>;</span><br><span class="line">        small.next = largeHead.next;</span><br><span class="line">        <span class="keyword">return</span> smallHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc92-反转链表-II（MD）&quot;&gt;lc92. 反转链表 II（MD）&lt;/h2&gt;
&lt;p&gt;给你单链表的头指针 &lt;code&gt;head&lt;/code&gt; 和两个整数 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; ，其中 &lt;code&gt;left </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.7</title>
    <link href="https://yonagi04.github.io/posts/2024/d2a92e35a04d/"/>
    <id>https://yonagi04.github.io/posts/2024/d2a92e35a04d/</id>
    <published>2024-04-07T14:52:54.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc224-基本计算器（HD）">lc224. 基本计算器（HD）</h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 10^5</code></li><li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li><li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</li><li>‘-’ 可以用作一元运算(即 “-1” 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</li><li>输入中不存在两个连续的操作符</li><li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li></ul><hr><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。</p><p>因此，我们考虑使用一个取值为 {-1,+1} 的整数 sign 代表「当前」的符号。根据括号表达式的性质，它的取值：</p><ul><li>与字符串中当前位置的运算符有关；</li><li>如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 - 号开头的括号，则意味着此后的符号都要被「翻转」。</li></ul><p>考虑到第二点，我们需要维护一个栈 ops，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。</p><p>在得到栈 ops 之后， sign 的取值就能够确定了：如果当前遇到了 + 号，则更新 sign←ops.top()；如果遇到了遇到了 - 号，则更新 sign←−ops.top()。</p><p>然后，每当遇到 ( 时，都要将当前的 sign 取值压入栈中；每当遇到 ) 时，都从栈中弹出一个元素。这样，我们能够在扫描字符串的时候，即时地更新 ops 中的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.push(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = que.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = -que.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                que.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                que.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc2-两数相加（MD）">lc2. 两数相加（MD）</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><hr><p>手动模拟</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jinwei</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + jinwei;</span><br><span class="line">            jinwei = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jinwei == <span class="number">1</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(jinwei);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc21-合并两个有序链表（EZ）">lc21. 合并两个有序链表（EZ）</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><hr><p>双指针法</p><p>还有一个，这种链表题，我们一般习惯设一个nude node，作为链表头，这样处理起来会简单很多</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> || list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                p.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc138-随机链表的复制-MD">lc138. 随机链表的复制(MD)</h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li><li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点</li></ul><hr><p>这道题的思路是这样的：把链表中的每个节点拆分成两个完全相同的节点，例如对于链表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to B \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, 可以改成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>B</mi><mo>→</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A \to A&#x27; \to B \to B&#x27; \to C \to C&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p><p>然后去调整复制出来的节点的random指向</p><p>最后断开复制节点和原节点的联系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            newNode.next = node.next;</span><br><span class="line">            node.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> node.next;</span><br><span class="line">            newNode.random = node.random == <span class="literal">null</span> ? <span class="literal">null</span> : node.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> node.next;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            newNode.next = (newNode.next == <span class="literal">null</span>) ? <span class="literal">null</span> : newNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc224-基本计算器（HD）&quot;&gt;lc224. 基本计算器（HD）&lt;/h2&gt;
&lt;p&gt;给你一个字符串表达式 &lt;code&gt;s&lt;/code&gt; ，请你实现一个基本计算器来计算并返回它的值。&lt;/p&gt;
&lt;p&gt;注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 &lt;c</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.6</title>
    <link href="https://yonagi04.github.io/posts/2024/9b28afeb1b5f/"/>
    <id>https://yonagi04.github.io/posts/2024/9b28afeb1b5f/</id>
    <published>2024-04-06T15:05:30.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc54-螺旋矩阵（MD）">lc54. 螺旋矩阵（MD）</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><hr><p>手动模拟一下就可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; t &lt;= b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= r; j++) &#123;</span><br><span class="line">                res.add(matrix[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t + <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">                res.add(matrix[i][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r - <span class="number">1</span>; j &gt; l; j--) &#123;</span><br><span class="line">                    res.add(matrix[b][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt; t; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">            b--;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc20-有效的括号（EZ）">lc20. 有效的括号（EZ）</h2><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li></ul><hr><p>栈的入门题，简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stk.isEmpty() &amp;&amp; stk.peek() == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc155-最小栈（MD）">lc155. 最小栈（MD）</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li></ul><hr><p>关键是在于怎么保存这个最小值，以及在pop之后如何获取到上一次的最小值（回滚之后如何获取最小值）</p><p>介于考虑到栈可能会pop，而pop前后的最小值可能是有变化的，所以在原来储存基本数据的栈之外，我们还需要额外创建一个专门储存最小值的栈，这样即使是发生了pop我们也能获得pop后的最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        minStk.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stk.push(val);</span><br><span class="line">        minStk.push(Math.min(minStk.peek(), val));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        minStk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h2 id="lc150-逆波兰表达式求值（MD）">lc150. 逆波兰表达式求值（MD）</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><hr><p>这道题的难度，不应该被评为mid，应该改成easy，因为这道题就是学数据结构的时候最基本的一道例题——后缀表达式计算。我不相信有哪个学校哪个计算机学院的计算机专业讲数据结构这门课的时候是没有讲过这个经典例子的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(s)) &#123;</span><br><span class="line">                deq.push(deq.pop() + deq.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(s)) &#123;</span><br><span class="line">                deq.push(-deq.pop() + deq.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(s)) &#123;</span><br><span class="line">                deq.push(deq.pop() * deq.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> deq.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> deq.pop();</span><br><span class="line">                deq.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deq.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc54-螺旋矩阵（MD）&quot;&gt;lc54. 螺旋矩阵（MD）&lt;/h2&gt;
&lt;p&gt;给你一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的矩阵 &lt;code&gt;matrix&lt;/code&gt; ，请按照 &lt;strong&gt;顺时针螺旋顺序&lt;/strong&gt; ，返</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Girls Band Cry 第一话观后感</title>
    <link href="https://yonagi04.github.io/posts/2024/3e6ca66f3067/"/>
    <id>https://yonagi04.github.io/posts/2024/3e6ca66f3067/</id>
    <published>2024-04-06T13:05:18.000Z</published>
    <updated>2025-05-18T09:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<p>我本来是打算我个人要看的四月新番差不多都更新了3话左右再来写动画栏目的新blog的，但是当我看完了《Girls Band Cry》的第一话之后，我坐不住了，必须先写一篇，简单介绍剧情，然后讲讲我个人的评价和我希望它以后未来的走向</p><p>第一话的内容量我个人感觉还是很大的，也挖了不少坑，后面我会继续讲到</p><hr><p>开局就是女主nina在新干线上，此时新干线已经到了东京站，女主还趴在窗台上睡觉</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-1.webp" alt=""></p><p>（这一点和我有点像，我自己也喜欢坐高铁的时候选靠窗座位，然后这样趴在窗台上面睡觉）</p><p>然而nina已经睡过头了。一个保洁阿姨叫醒了nina，nina慌忙下车，然后就开始了——额换乘地铁。在东京站转啊转转啊转，怎么找都找不到换乘的入口，不过好在最后还是坐上了地铁</p><p>（这么一看，和我第一次来广州的时候有点像，都是第一次来一个人生地不熟的大城市，也是不知所措）</p><p>然后，在地铁上，nina的手机没电了</p><p>（日本不流行充电宝吗）</p><p>nina大概率是在网上已经租好了房子，到了川崎就直奔房租中介。结果房租中介已经关门了，没办法拿到钥匙，也没办法让房租中介的人带她过去自己租的房子</p><p>然后nina就只能根据房子的地点，自己一个人摸过去</p><p>（有一说一这一段我看了感觉挺好笑的，不是因为别的，而是因为——经典乡下人进城环节）</p><p>最后nina当然很成功地摸到了自己的房子</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-2.webp" alt=""></p><p>一栋小型公寓。根据后面给出的场景来看，大概是一个1R的房子，且房租是50000日元，折合人民币大约2400~2500元左右吧，考虑到住的地方，其实房租也不算便宜</p><p>nina居然试图翻配电箱找找里面有没有钥匙……结果吵到了邻居家，不过邻居家也算好人，邀请她在他们家住一晚，但是nina却润了</p><p>nina就润到了一个餐厅里面，找了个充电宝给手机充电。家里人给nina打电话，此时的bgm变得非常地压抑，nina对家里的电话也非常冷淡（这是挖的第一个坑：为什么女主和家里的关系这么糟糕？）</p><p>打完了电话就开始翻Instagram，结果看到自己追的乐队吉他手（也是本片女主之一）momoka正好在川崎站前路演</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-3.webp" alt=""></p><p>然后nina上去和吉他手momoka搭话。过程中冒出来俩路人</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-4.webp" alt=""></p><p>然后momoka就带着nina润了</p><p>最后momoka比了这个手势，太他妈潮了这才是玩乐队的，隔壁什么破琵琶什么r组什么买狗都远不如我们gbc</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-5.webp" alt=""></p><p>然后momoka和nina就一起润到了吉野家。nina就是纯纯乡下土包子，从来没吃过吉野家的牛肉饭，直接嗯造。说到这里，这个地方也给我们挖了第二个坑：nina家有三个家训，而且是白纸黑字写出来的、明文规定的，这里我们就不列举出来了，但我们都知道正常的家庭包括日本家庭是不存在所谓明确的、白纸黑字写出来的所谓 ”家训“ 这些东西的，更多的是靠道德观念来维持家庭秩序，至于家训一般都只有传统封建大家庭才有这些东西，那么nina的家庭到底是一个什么样的环境？她为什么要选择脱离她的家庭来东京？（其实开头已经和我们说了一点，但是没有明说，我希望这个坑能够好好补上）（这里momoka也吐槽了一下 “大小姐吗”，但从nina的反应来看，nina并非是一个大小姐，也不是出身于权贵家庭）</p><p>其实还有第三个坑：nina的叔叔给nina提供的关于东京的信息相当不靠谱——川崎并非在东京，而是在神奈川；新川崎站也并非在川崎站附近。还得是有momoka帮了nina，要不然nina会一直陷入错误的信息之中。这个番所处的时期已经至少是2020年了，从主角使用的手机可以看出来（至少是iPhone11），这些基本信息哪怕Google一下都能知道这些信息是错误的，那么为什么nina家里还能给nina提供错误情报？是故意为之还是无意的呢？如果是故意的，为什么nina家庭要阻止nina？如果是无意的，回到第二个坑：nina的家庭到底是一个什么样的环境？</p><p>（当然，可能是我想的比较多了，有点 ”过度解读“ 的感觉。但我个人认为，nina和她的家庭之间的问题到本片中后期肯定要讲明白的，讲不明白的话这片只能算个烂片，因为连最开始挖的坑都填不上）</p><p>然后就是nina一边嗯造牛肉饭一边和momoka闲谈。最后nina嗯造完了牛肉饭，离开之前，向着店里的两位店员摆出了这个手势，也是本文的封面</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-6.webp" alt=""></p><p>然后店员的反应是这样的，店员直接震怒。冷知识，这里的两个店员是本片的主角tomo和rupa</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-7.webp" alt=""></p><p>nina完全不知道这个手势到底是什么意思，都4202年了，有点好笑了（此次可以补充到第三个坑）</p><p>然后nina和momoka回到了momoka的住所。nina第一次拿起了吉他，当然也借着这个机会，了解到了momoka的一些情况，原来看似成熟的momoka，今年也才20岁。和nina一样，momoka也是17岁时辍学来到东京组乐队，到现在已经是三年时间了，只不过，momoka第二天就决定离开东京，回到北海道，毕竟她和她原来的乐队吵架了，在曲子的所有权方面彻底闹崩了。</p><p>这里也挖了momoka的一个坑：momoka和原来的乐队闹崩了。感觉这里也是个坑，也许会成为以后剧情大爆特爆的一条导火索，mark一下</p><p>这里还有一个nina的坑：nina说自己离开家的时候带了点钱，资金上短时间内不成问题。momoka说既然不缺钱，那应该过得很轻松了，想干啥就能干啥。结果却踩了nina的大雷，nina和momoka当场就爆了，然后nina毫不犹豫地离开了momoka的住所。为什么nina会那么急？nina到底是为了什么才来东京的？（其实这一集后面也有说到一点，但我个人感觉无法构成合理的答案，像是在谜语人）</p><p>可惜nina走得很急，手机忘记带了。momoka带上nina的手机追了上去，在一座天桥上面找到了nina（什么嘛，又是天桥。上上次我印象最深的关于天桥的剧情是推子里面阿夸在天桥两次救下黑川茜，上次则是mygo里面soyo在天桥上说”大概我一辈子也忘不了crychic“，怎么这次又是天桥了）momoka向nina道歉，问nina是为了什么梦想来到东京的，然而nina的答复是</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-8.webp" alt=""></p><p>”什么都没有，我不为什么，我不是为了梦想来到这里的，只是我没有容身之处“</p><p>”明明我没有错，但气氛却好像是我做的不对一样，我又不想认输&quot;</p><p>谜语人环节，可能后续剧情会解释吧</p><p>然后momoka也向nina解释了自己为什么离开乐队。</p><p>然后就是唱k环节，momoka发现nina很会唱歌，当然这不是最重要的环节，后面live更重要一些</p><p>第二天，nina在momoka的家中醒来。此时momoka已经离开了家，家里除了nina和猫之外，其他的全是搬家工人。momoka给nina留下了她的吉他</p><p>nina背着吉他回到了她的住所，打开琴包一看，吉他琴身上面写着</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/Anime/girlsbandcry-content/girlsbandcry-epi1-9.webp" alt=""></p><p>然后nina就急忙润出了家，去了之前momoka路演的地方。说实话这段剧情我没搞懂，有点像是为了拉momoka入团而搞出来的剧情</p><p>下雨天，nina抱着一把吉他在雨中跑，吉他没有背带，然后nina不小心摔了一跤，吉他也摔在地上</p><p>（槽点槽点！我自己的琴如果小磕小碰我都得心疼得不行，狠狠摔到地上那可真不得了……而且抱着琴直接在雨中跑……不怕进水了把电吉他里面电路搞坏吗……）（算了当作一个桥段来看待了，这些小细节不要在意）</p><p>然后nina就跑到了之前momoka路演的地方，然后就和mygo第10话灯上台念诗一样——直接跑到话筒之前——额深情告白？——额表达心意？</p><p>momoka也为此而感动，然后——然后就live了，然后就没了！（当然我们都知道，momoka肯定是被拉进来了）</p><hr><p>个人感觉，满分10分，我给8分。个人感觉信息量偏大，虽然本集出场的主角不多，但是挖的坑和暴露给观众的信息可一点都不少。我很担心花田到最后还能不能hold得住，能不能把坑全部都填了；live演出很不错，nina的声优的歌力真的超强，比mygo的羊宫妃那强多了；3d动画表现力真的很强，我自己是不怎么看3d片子的，但这个片子真的把3d的优势运用到了极致，在一些细节方面真的画得很好，比如人物的动作、各种小表情，都表现得很棒</p><p>个人预测：我个人感觉，这片子不可能发展成mygo那样带扭曲要素的了，最多就是把乐队每个人所谓的“心结”都解开，最后建团的王道向剧情，和Bang Dream第一季差不多。想看扭曲大概率还得看同期的《夜晚的水母不会游泳》</p><hr><p>没想到一写就是半个多小时，一写就是2700+字（至少Typora上面显示的是2700+）。希望后续这片能给大家带来更多惊喜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我本来是打算我个人要看的四月新番差不多都更新了3话左右再来写动画栏目的新blog的，但是当我看完了《Girls Band Cry》的第一话之后，我坐不住了，必须先写一篇，简单介绍剧情，然后讲讲我个人的评价和我希望它以后未来的走向&lt;/p&gt;
&lt;p&gt;第一话的内容量我个人感觉还是很</summary>
      
    
    
    
    <category term="动画" scheme="https://yonagi04.github.io/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
    <category term="动画" scheme="https://yonagi04.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="动画吐槽" scheme="https://yonagi04.github.io/tags/%E5%8A%A8%E7%94%BB%E5%90%90%E6%A7%BD/"/>
    
    <category term="新番" scheme="https://yonagi04.github.io/tags/%E6%96%B0%E7%95%AA/"/>
    
  </entry>
  
  <entry>
    <title>JVM专题——垃圾回收</title>
    <link href="https://yonagi04.github.io/posts/2024/bb3aa242277e/"/>
    <id>https://yonagi04.github.io/posts/2024/bb3aa242277e/</id>
    <published>2024-04-05T15:38:29.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">https://javaguide.cn/java/jvm/jvm-garbage-collection.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a></p></blockquote><h1>堆内存基本结构</h1><p>回顾堆内存的结构. Java 自动内存管理的主要区域是 Java 堆, 因此 Java 堆也被称为 GC 堆</p><p>在 JDK1.7及以前的版本, 堆内存分为以下三部分:</p><ol><li>新生代</li><li>老年代</li><li>永久代</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/hotspot-heap-structure.png" alt=""></p><p>JDK1.8 之后, 永久代被元空间取代</p><p>具体的关于堆内存基本结构相关信息, 请看<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a></p><h1>内存分配与回收原则</h1><h2 id="对象优先在Eden区分配">对象优先在Eden区分配</h2><p>大多数情况下, 对象在新生代中Eden区分配, 当Eden区没有足够空间进行分配时, 虚拟机会发起一次 Minor GC. 如果执行 Minor GC 之后, Eden区足够存储对象, 那么就会在Eden区分配对象内存; 否则会通过 <strong>分配担保机制</strong> 将新生代对象暂时存储到老年代</p><h2 id="大对象直接进入老年代">大对象直接进入老年代</h2><p>大对象就是指需要大量连续内存空间的对象(例如字符串, 数组)</p><p>大对象直接进入老年代的行为是由虚拟机动态决定的, 它与具体使用的垃圾回收器和相关参数有关. 大对象进入老年代是一种优化策略, 旨在避免将大对象放入新生代, 从而减少新生代的垃圾回收频率和成本</p><ul><li>G1垃圾回收器会根据 <code>-XX:G1HeapRegionSize</code> 参数设置堆区域的大小和 <code>-XX:G1MixedGCLiveThresholdPercent</code> 参数设置的阈值, 来决定哪些对象会直接进入老年代</li><li>Parallel Scavenge垃圾回收器中, 默认情况下, 是没有一个固定的阈值来决定何时直接在老年代分配大对象, 而是由虚拟机根据当前的堆内存情况和历史数据动态决定</li></ul><h2 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h2><p>虚拟机给每个对象都分配了一个对象年龄计数器. 大部分情况下, 对象首先在 Eden 区分配, 如果对象在 Eden区出生且经过第一次 Minor GC后仍能存活, 且能被Survivor收纳的话, 将被移动到 Survivor空间, 并将对象年龄设置为1</p><p>对象每在Survivor熬过一次Minor GC, 年龄就会增长1岁. 当它的年龄增加到一定程度(默认为15), 就会被晋升到老年代.</p><h2 id="主要进行GC的区域">主要进行GC的区域</h2><p>部分收集 (Partial GC):</p><ul><li>新生代收集(Minor GC/Young GC): 只对新生代进行垃圾收集</li><li>老年代收集(Major GC/Old GC): 只对老年代进行垃圾收集, 注意Major GC在有些语义下也指整堆收集</li><li>混合收集(Mixed GC): 对整个新生代和部分老年代进行垃圾收集</li></ul><p>整堆收集(Full GC): 收集整个Java堆和方法区</p><h2 id="空间分配担保">空间分配担保</h2><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间</p><p>JDK6 Update24 之前, 在发生Minor GC之前, 虚拟机必须检查老年代最大可用的连续空间是否大于新生代所有对象总空间, 如果这个条件成立, 那么这一次Minor GC可以保证是安全的, 如果不成立, 则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败, 如果允许, 则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 则尝试进行一次Minor GC; 如果小于, 或者 <code>-XX:HandlePromotionFailure</code> 被设置为是不允许的, 那么这一次就要进行Full GC</p><p>JDK6 Update24之后, 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小, 就会进行 Minor GC, 否则进行 Full GC</p><h1>对象死亡判断</h1><h2 id="引用计数算法">引用计数算法</h2><p>在对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一; 当引用失效时, 计数器值减一; 任何时刻计数器为零的对象就是不可能再被使用的, 这一点有点类似于C++智能指针中的shared pointer共享指针</p><p>它的原理很简单, 且效率很高, 但实际上主流的Java 虚拟机都没有使用这个算法来管理内存, 因为这个算法无法解决对象之间循环引用的问题. 如果对象a和对象b互相引用, 除此之外没有其他对象再引用这两个对象, 但是由于引用计数器不为零, 所以使用引用计数算法无法让垃圾收集器回收它们</p><h2 id="可达性分析">可达性分析</h2><p>目前主流的支持垃圾回收的商用程序语言都是通过 <strong>可达性分析</strong> 来判断对象是否存活</p><p>这个算法的基本思路就是通过一系列称为 &quot;GC Roots&quot;的根对象作为起始节点集, 从这些结点开始, 根据引用关系向下搜索, 搜索过程中所走过的路径称为 <strong>“引用链”</strong> . 如果从GC Roots到某个对象没有一条通路, 那么说明这个对象已经死亡了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/jvm-gc-roots.png" alt=""></p><p>例如, 上图的 Object6~Object10 之间虽然互有引用关系, 但是由于它们到GC Roots没有一条通路, 所以它们都是属于要被回收的对象</p><p>可以作为GC Roots的对象:</p><ul><li>在虚拟机栈中引用的对象, 例如各个线程中被调用的方法堆栈中使用的参数, 局部变量, 临时变量等</li><li>在方法区中类静态属性引用的对象, 例如Java类的引用类型静态变量</li><li>在方法区中常量引用的对象, 例如字符串常量池中的引用</li><li>在本地方法栈中JNI引用的对象</li><li>Java 虚拟机内部的引用, 如基本数据类型对应的Class 对象, 一些常驻的异常对象, 系统类加载器</li><li>所有被同步锁持有的对象</li><li>反应Java虚拟机内部情况的JMXBean, JVMTI中注册的回调,本地代码缓存等</li></ul><p><strong>对象可以被回收, 就代表一定会被回收吗?</strong></p><p>真正宣告一个对象&quot;死亡&quot;, 需要经过两个阶段, 可达性分析法不可达的对象第一次标记并进行一次筛选, 筛选的条件是这个对象是否有必要执行 <code>finalize</code> 方法, 当对象没有覆盖 <code>finalize</code> 方法, 或 <code>finalize</code> 方法已经被虚拟机调用过时, 虚拟机将这两种情况视为没有必要执行</p><p>被判定为需要执行的对象会被放在一个队列里进行第二次标记, 除非这个对象与引用链上的任何一个对象建立关联, 否则就会被真的回收</p><h2 id="引用">引用</h2><p>JDK1.2之后, Java的引用分为 <strong>强引用</strong> , <strong>弱引用</strong> , <strong>软引用</strong> , <strong>虚引用</strong> 四类</p><ul><li><p>强引用: 强引用是最传统的引用关系, 无论任何情况下, 只要强引用关系存在, 垃圾收集器就不会回收掉被引用的对象. 当内存空间不足, 虚拟机宁愿抛出OutOfMemoryError错误, 也不会随意回收具有强引用的对象</p></li><li><p>软引用: 软引用用来描述一些还有用, 但非必须的对象. 只被软引用关联着的对象, 在系统将要发生内存溢出异常前, 会把这些对象列进回收范围之中进行第二次回收, 如果这一次回收还没有足够的内存, 才会抛出内存溢出异常.</p></li><li><p>弱引用: 弱引用也用来描述一些非必须对象, 但是它的强度比软引用更弱, 被弱引用关联的对象只能生存到下一次垃圾收集发生为止</p></li><li><p>虚引用: 虚引用是最弱的引用关系. 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来获得一个对象实例. 为一个对象设置虚引用的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</p><p>虚引用和软引用, 弱引用的差别在于: 虚引用必须与引用队列联合使用, 当垃圾回收器准备回收一个对象时, 如果发现它还有虚引用, 就会在回收对象的内存之前, 把这个虚引用加入到与之关联的引用队列之中. 程序可以通过判断引用队列中是否已经加入了虚引用, 来了解这个对象是否将要被垃圾回收</p></li></ul><p>实际上使用软引用的情况比使用弱引用, 虚引用的情况要多得多. 这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度, 避免出现内存溢出等问题</strong></p><h2 id="如何判断一个类是无用的类？">如何判断一个类是无用的类？</h2><ul><li>该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 <code>ClassLoader</code> 已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法</li></ul><h1>垃圾回收算法</h1><h2 id="标记-清除算法">标记-清除算法</h2><p>标记-清除算法分为 “标记” 和 “清除” 阶段: 首先标记出所有不需要回收的对象, 在标记完成之后统一回收掉所有没有被标记的对象</p><p>它会带来两个明显的问题</p><ol><li><strong>效率问题</strong> : 标记和清除两个过程效率都不高</li><li><strong>空间问题</strong> : 标记清除后会产生大量不连续的内存碎片</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/mark-and-sweep-garbage-collection-algorithm.png" alt=""></p><h2 id="标记-复制算法">标记-复制算法</h2><p>为了解决标记-清除算法面对大量可复制对象时执行效率低的问题, 标记-复制算法诞生了. 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块. 当这一块的内存用完了就将还活着的对象复制到另一块内存上, 然后再把已经使用过的内存空间清理掉.</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/copying-garbage-collection-algorithm.png" alt=""></p><p>但是这个算法仍然存在一些问题</p><ol><li><strong>可用内存变小</strong> : 可用内存缩小为原来的一半</li><li><strong>不适合老年代</strong> : 如果存活对象数量比较大, 复制性能会变得很差</li></ol><h2 id="标记-整理算法">标记-整理算法</h2><p>标记-整理算法是根据老年代的特点提出的一种标记算法, 标记过程仍然和标记-清除算法一样, 但后续步骤不是直接对可回收对象回收, 而是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/mark-and-compact-garbage-collection-algorithm.png" alt=""></p><p>因为多了整理这一步, 所以效率也不高, 适用于老年代这种垃圾回收频率不高的场景</p><h2 id="分代收集算法">分代收集算法</h2><p>一般将Java堆分为新生代和老年代, 这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p><h1>垃圾收集器</h1><p>JDK默认垃圾收集器</p><ul><li>JDK8: Parallel Scavenge(新生代) + Parallel Old(老年代)</li><li>JDK9~JDK20: G1</li></ul><h2 id="Serial-收集器">Serial 收集器</h2><p>Serial 收集器是一个单线程收集器, 它在进行垃圾收集工作时候必须暂停其他所有的工作线程, 直到它收集结束</p><p><strong>新生代采用标记-复制算法, 老年代采用标记-整理算法</strong></p><p>Serial 收集器简单且高效, 且因为没有线程交互的开销, 自然可以获得很高的单线程收集效率. Serial收集器对于运行在客户端模式的虚拟机来说是一个不错的选择</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/serial-garbage-collector.png" alt=""></p><h2 id="ParNew-收集器">ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本, 除了使用多线程之外, 其余行为和 Serial 收集器完全一样</p><p>它是许多运行在服务端模式下虚拟机的首要选择, 除了 Serial 收集器外, 只有它能和CMS收集器配合工作</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/parnew-garbage-collector.png" alt=""></p><h2 id="Parallel-Scavenge-收集器">Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器 也是使用标记-复制算法的多线程收集器</p><p>Parallel Scaveng 收集器的特点是它的关注点与其他收集器不同, CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量. 吞吐量就是CPU中用于运行用户代码的时间和CPU总消耗时间的比值. Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间和最大吞吐量, 如果对于收集器工作不了解, 手工优化存在困难时, 可以使用 Parallel Scavenge 收集器配合自适应调节策略</p><p><strong>新生代使用标记-复制算法, 老年代使用标记-整理算法</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/parallel-scavenge-garbage-collector.png" alt=""></p><h2 id="Serial-Old-收集器">Serial Old 收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本, 它也是单线程收集器, 使用标记-整理算法. 这个收集器的主要意义是供客户端模式下的HotSpot虚拟机使用. 在服务端模式下, 它有两种用途: 一种是在 JDK5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用, 另外一种就是作为CMS收集器发生失败时的后备预案</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/serial-garbage-collector.png" alt=""></p><h2 id="Parallel-Old-收集器">Parallel Old 收集器</h2><p>Parallel Old 是 Parallel 收集器的老年代版本, 支持多线程并发收集, 使用标记-整理算法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/parallel-scavenge-garbage-collector.png" alt=""></p><h2 id="CMS-收集器">CMS 收集器</h2><p>CMS 收集器是一种以获取最短回收停顿时间为目标的收集器. 非常适合在注重用户体验的应用上使用</p><p>CMS 收集器也是 HotSpot虚拟机第一款真正意义上的并发收集器, 实现了垃圾收集线程和用户现场同时工作</p><p>CMS收集器是采用标记-清除算法实现的, 收集过程分为4个步骤</p><ol><li><strong>初始标记</strong> : 暂停所有线程, 并记录下直接与root相连的对象, 速度很快</li><li><strong>并发标记</strong> : 同时开启 GC 和用户线程, 用一个闭包结构去记录可达对象. 但在这个阶段结束, 这个闭包结构不能保证包含所有的可达对象. 因为用户线程可能会不断的更新引用域, 所以 GC 线程无法保证可达性分析的实时性. 所以这个算法里会跟踪记录这些发生引用更新的地方</li><li><strong>重新标记</strong> : 重新标记阶段就是为了修正并发标记阶段因为用户程序继续运行而导致标记变动的那一部分对象的标记记录, 这一阶段的停顿时间比初始标记阶段停顿时间长, 远比并发标记阶段时间短</li><li><strong>并发清除</strong> : 开启用户线程, 同时 GC 线程对未标记的区域做清扫</li></ol><p>CMS的优点: <strong>并发收集, 地停顿</strong></p><p>CMS的缺点:</p><ol><li>对CPU资源非常敏感</li><li>由于CMS收集器无法处理浮动垃圾, 所以可能导致 “Con-current Mode Failure” 失败进而导致另一次完全 “Stop the world” 的 Full GC 的产生</li><li>标记-清除算法会导致收集结束后产生大量的空间碎片</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/cms-garbage-collector.png" alt=""></p><p>从 JDK9 开始, CMS收集器已被弃用</p><h2 id="G1-收集器">G1 收集器</h2><p>G1 收集器是一款面向服务器的垃圾收集器, 主要针对具备多核处理器和大容量内存的机器, 以极高概率满足GC停顿时间要求的同时, 还具备高吞吐性能特征</p><p><strong>G1 收集器在后台维护了一个优先列表, 每次根据允许的收集时间, 优先选择回收价值最大的 Region.</strong> 这种使用 Region 划分内存空间以及有优先级的区域回收方式, 保证了 G1 收集器在有限时间内可以尽可能高的收集效率</p><p>G1收集器的运作大致分为以下步骤</p><ol><li><p><strong>初始标记</strong> : 仅仅标记 GC Roots 能直接关联到的对象, 并且修改 TAMS 指针的值, 让下一阶段用户线程并发运行时, 能正确地在可用的 Region 中分配新对象. 这个阶段需要停顿线程, 但耗时很短, 并且是借用进行 Minor GC 时同步进行的</p></li><li><p><strong>并发标记</strong> : 从 GC Roots 开始对堆中对象进行可达性分析, 递归扫描整个堆中的对象图, 找出要回收的对象, 这阶段耗时较长, 但可以与用户线程并发进行. 当对象图扫描完成之后, 还要重新处理STAB记录下的在并发时有引用变动的对象</p></li><li><p><strong>最终标记</strong> : 对用户线程做短暂的暂停, 用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录</p></li><li><p><strong>筛选回收</strong> : 负责更新 Region 的统计数据, 对各个 Region 的回收价值和成本进行排序, 根据用户所期望的停顿时间来制定回收计划, 可以自由选择任意多个 Region 构成回收集, 然后把决定回收的那一部分 Region 的存活对象复制到空 Region 中, 再清理掉整个旧 Region 的全部空间. 这个操作涉及到存活对象的移动, 是必须暂停用户线程, 由多条收集器线程并行完成的</p></li></ol><p>从 JDK9 开始, G1收集器为默认垃圾收集器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: &lt;a href=&quot;https://javaguide.cn/java/jvm/jvm-garbage-collection.html&quot;&gt;https://java</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.5</title>
    <link href="https://yonagi04.github.io/posts/2024/d9034cd7e83d/"/>
    <id>https://yonagi04.github.io/posts/2024/d9034cd7e83d/</id>
    <published>2024-04-05T14:03:25.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc128-最长连续序列-MD">lc128. 最长连续序列(MD)</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><hr><p>先预处理(把数组里面的数存入哈希表), 然后遍历哈希表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            hash.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hash.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentRes</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (hash.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    currentRes++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, currentRes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc228-汇总区间-EZ">lc228. 汇总区间(EZ)</h2><p>给定一个  <strong>无重复元素</strong> 的 <strong>有序</strong> 整数数组 <code>nums</code> 。</p><p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表</em> 。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 20</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li><li><code>nums</code> 按升序排列</li></ul><hr><p>还是双指针, 用双指针确定连续区间, 如果右指针碰到断开区间了就存到列表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">summaryRanges</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(Integer.toString(nums[low]));</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                tmp.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                tmp.append(Integer.toString(nums[high]));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc56-合并区间-MD">lc56. 合并区间(MD)</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><hr><p>其实这道题唯一的难点仅在于如何用Java语言对二维数组进行自定义排序</p><p>剩下的我感觉没什么难度了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; l) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc73-矩阵置零-MD">lc73. 矩阵置零(MD)</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法**。**</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用  <code>O(*mn*)</code> 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个仅使用常量空间的解决方案吗？</li></ul><hr><p>不考虑进阶条件3了</p><p>最简单的方法就是直接开一个二维数组, 和传进来的数组一样大, 空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>还有一个方法就是开两个数组, 这样空间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>我们这里采用第二个方法, 常量空间的进阶要求不考虑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = <span class="literal">true</span>;</span><br><span class="line">                    col[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc48-旋转图像-MD">lc48. 旋转图像(MD)</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><hr><p>这道题我个人的印象还是很深的, 不是在leetcode, 而是在Atcoder. Atcoder以前有一次比赛就出了这道题, 印象里好像是放在第三题还是第四题</p><p>这道题的关键是要发现旋转前后同一个数的坐标位置变化</p><p>矩阵中心点是不需要旋转的, 遍历矩阵时需要注意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc128-最长连续序列-MD&quot;&gt;lc128. 最长连续序列(MD)&lt;/h2&gt;
&lt;p&gt;给定一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 &lt;cod</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM专题——内存结构</title>
    <link href="https://yonagi04.github.io/posts/2024/f5e67a38b282/"/>
    <id>https://yonagi04.github.io/posts/2024/f5e67a38b282/</id>
    <published>2024-04-05T09:38:09.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: <a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a></p></blockquote><h1>运行时数据区域</h1><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域. 这些区域有各自的用途, 以及创建和销毁的时间, 有的区域随着虚拟机进程的启动而一直存在, 有些区域则是依赖于用户线程的启动和结束而建立和销毁. 根据 Java 虚拟机规范 的规定, JVM 所管理的内存将会包括以下几个运行时区域</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/java-runtime-data-areas-jdk1.7.png" alt="Java运行时数据区域(JDK1.7)"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/java-runtime-data-areas-jdk1.8.png" alt="Java运行时数据区域(JDK1.8)"></p><p><strong>线程私有的</strong> :</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的</strong> :</p><ul><li>堆</li><li>方法区</li><li>直接内存(非运行时数据区的一部分)</li></ul><h2 id="程序计数器">程序计数器</h2><p>程序计数器是一块较小的内存空间, 它可以看作是当前线程所执行的字节码的行号指示器. 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令, 它是程序控制流的指示器, 分支, 循环, 跳转, 异常处理, 线程恢复都需要依赖这个计数器来完成</p><p>由于 JVM 的多线程是通过线程轮流切换, 分配处理器执行实际的方式来实现的, 在任何一个确定的时刻, 一个处理器都只会执行一条线程中的指令. 因此, 为了线程切换之后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 各条线程之间计数器互不影响, 独立存储, 所以这类内存区域为线程私有的内存</p><p><strong>注意: 此内存区域是唯一一个在 Java虚拟机规范 中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></p><h2 id="虚拟机栈">虚拟机栈</h2><p>和程序计数器一样, 虚拟机栈也是线程私有的, 它的生命周期和线程相同. 虚拟机栈描述的是 Java 方法执行的线程内存模型: 每个方法被执行的时候, JVM 都会同步创建一个栈帧用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息. 每一个方法被调用到执行完毕的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p><p>局部变量表存放了编译期可知的各种 JVM 基本数据类型(boolean, byte, char , short, int, float, long, double), 对象引用和returnAddress类型. 这些数据类型在局部变量表中的存储空间以局部变量槽来表示, 其中64位的数据会占据两个槽, 其余的只占据一个. 局部变量表所需的内存空间在编译期间就完成分配, 当进入一个方法时, 这个方法需要在栈帧中分配多大的局部变量空间是完全确定的, 在方法运行期间不会改变局部变量表的大小</p><p>操作数栈主要用于方法调用的中转站, 用于存放方法执行过程中产生的中间计算结果. 此外, 计算过程中产生的临时变量也会放在操作数栈中</p><p>动态链接主要服务一个方法需要调用其他方法的场景. Class 文件的常量池中保存有大量的符号引用比如方法引用的符号引用. 当一个方法要调用其他方法, 需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用. 动态链接的作用就是为了将符号引用转换为调用方法的直接引用, 这个过程也被叫做动态连接</p><p>栈空间不是无限的, 如果函数调用陷入无限循环, 就会导致栈压入过多栈帧, 导致栈空间过深. 当线程请求栈的深度超过 JVM 虚拟机栈的最大深度时, 就会抛出 <code>StackOverflowError</code></p><p><strong>栈帧随着方法调用而创建, 随着方法结束而销毁, 无论是正常完成还是异常完成都算方法结束</strong></p><p>除了 <code>StackOverflowError</code> , 栈还可能出现 <code>OutOfMemoryError</code> 错误, 这是因为如果栈的内存大小可以动态扩展, 虚拟机在动态扩展栈时无法申请到足够的内存空间, 则会抛出 <code>OutOfMemoryError</code></p><h2 id="本地方法栈">本地方法栈</h2><p>本地方法栈和虚拟机栈非常相似, 差别仅在于虚拟机栈为虚拟机执行 Java 方法服务, 本地方法栈则为虚拟机使用到的本地方法服务</p><p>和虚拟机栈一样, 本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></p><h2 id="堆">堆</h2><p>堆是 JVM 所管理的内存中最大的一块, Java 堆是所有线程共享的一块内存区域, 在虚拟机启动时创建. 该内存区域的唯一目的就是对象实例, Java中几乎所有的对象实例都在这里分配内存.</p><p>Java 堆是垃圾收集器管理的内存区域, 因此也被称为 “GC堆”. 从回收内存的角度看, 由于现代垃圾收集器大部分都是基于分代收集理论设计的, 所以 Java 堆还可以细分为: 新生代和老年代, 再细致一点: Eden, Survivor, Old空间. 进一步划分的目的是为了更好的回收内存或更快的分配内存</p><p>在JDK7及以前的版本, 堆分为下面三个部分:</p><ol><li>新生代</li><li>老生代</li><li>永久代</li></ol><p>JDK8 之后永久代已被元空间取代, 元空间使用的是本地内存</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/hotspot-heap-structure.png" alt=""></p><p>大部分情况下, 对象首先在 Eden区分配, 在一次新生代垃圾回收之后, 如果对象还存活, 则会进入 S0或S1 , 并且对象的年龄会+1, 当年了增加到一定程度(默认为15岁), 就会晋升到老年代.</p><p>堆中最经常出现的就是 <code>OutOfMemoryError</code> 错误, 并且这种错误的表现方式有几种:</p><ol><li><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code> : 当JVM 花太多时间执行垃圾回收且只能回收很少的堆空间时, 就会发生此错误</li><li><code>java.lang.OutOfMemoryError: Java Heap Space</code> : 假如创建新对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误</li></ol><h2 id="方法区">方法区</h2><p>方法区和堆一样, 是线程共享的内存区域, 它用于存储已被虚拟机加载的类型信息, 常量, 静态变量, 即时编译器编译后的代码缓存等数据</p><p><strong>方法区和永久代, 元空间是什么关系?</strong> 方法区和永久代, 元空间类似于Java中接口和类的关系, 这里类可以看作是永久代和元空间, 接口可以看作是方法区, 也就是说永久代和元空间其实是方法区的两种实现. 永久代是JDK1.8之前对方法区的实现, 元空间是JDK1.8之后对方法区的实现</p><p><strong>为什么要把永久代替换成元空间?</strong></p><ol><li>整个永久代有 JVM 本身设置的固定大小上限, 无法进行调整; 而元空间使用的是本地内存, 受本机可用内存的限制, 虽然元空间可能会溢出,但比原来出现溢出的概率要小</li><li>元空间中存放的是类的元数据, 这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间控制, 这样能加载的类就更多了</li><li>在 JDK8, 合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫做永久代的地方, 合并之后也没必要额外设置一个永久代</li><li>永久代会为GC带来不必要的复杂度, 且回收效率偏低</li></ol><p>根据 Java虚拟机规范 , 如果方法区无法满足新的内存分配需求, 将抛出 <code>OutOfMemoryError</code> 异常</p><h2 id="运行时常量池">运行时常量池</h2><p>运行时常量池是方法区的一部分, Class文件除了有类的版本, 字段, 方法, 接口等描述信息外, 还有一项信息就是常量池表, 用于存放编译期生成的各种字面量与符号引用, 这部分内容将在类加载后存放到方法区的运行时常量池中</p><p>运行时常量池相较于 Class 文件常量池的另外一个重要特征就是具备动态性, Java语言并不要求常量一定只有编译期才能产生, 也就是说, 并非预置入Class文件中常量池的内容才能进入方法去运行时常量池, 运行期间也可以将新的常量放入池中</p><p>当常量池无法再申请到内存时就会抛出 <code>OutOfMemoryError</code> 异常</p><h2 id="字符串常量池">字符串常量池</h2><p>字符串常量池是 JVM 为了提高性能和减少内存消耗针对字符串专门开辟的一块区域, 主要目的是为了避免字符串的重复创建</p><p>JDK1.7之前, 字符串常量池存放在永久代, JDK1.7后字符串常量池移动到堆</p><p><strong>为什么要把字符串常量池移动到堆?</strong></p><p>主要是因为永久代的GC效率太低, 只有整堆收集(Full GC)的时候才会执行GC. Java程序在通常有大量的被创建的字符串等待回收, 将字符串常量池放到堆中, 可以更高效地回收字符串内存</p><h2 id="直接内存">直接内存</h2><p>直接内存是特殊的内存缓冲区, 它并不在 Java 堆或方法区分配, 而是通过 JNI 的方式在本地内存上分配</p><p>直接内存并不是虚拟机运行时数据区的一部分, 也不是虚拟机规范中定义的内存区域, 但是这部分内存也被频繁地使用, 而且也可能导致 <code>OutOfMemoryError</code> 错误出现</p><p>直接内存分配不会受到 Java 堆的限制, 但是会受到本机内存大小和处理器寻址空间的限制</p><h1>HotSpot虚拟机对象探秘</h1><h2 id="对象创建">对象创建</h2><h3 id="Step1-类加载检查">Step1: 类加载检查</h3><p>当虚拟机碰到一条 new 指令时, 首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用, 并且检查这个符号引用代表的类是否已被加载过, 解析过和初始化过. 如果没有, 那必须先执行相应的类加载过程</p><h3 id="Step2-分配内存">Step2: 分配内存</h3><p>在类加载检查通过后, 接下来虚拟机将为新生对象分配内存. 对象所需的内存大小在类加载完成后便可确定, 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来. 分配方式有 “<strong>指针碰撞</strong>” 和 “<strong>空闲列表</strong>”, 取决哪一种主要由 Java 堆是否规整决定</p><ul><li>指针碰撞<ul><li>适用场合: 堆内存规整的情况</li><li>原理: 用过的内存全部整合到一边, 没有用过的内存放在另一边, 中间有一个分界指针, 只需要向着没用过的内存方向将该指针移动对象内存大小位置即可</li><li>使用该分配方式的GC收集器: Serial, ParNew</li></ul></li><li>空闲列表<ul><li>适用场合: 堆内存不规整的情况</li><li>原理: 虚拟机会维护一个列表, 该列表中会记录哪些内存块是可用的, 在分配的时候, 找一块足够大的内存划分给对象实例, 最后更新列表记录</li><li>使用该分配方式的GC收集器: CMS</li></ul></li></ul><p><strong>内存分配涉及到的并发问题</strong></p><p>通常来讲, 虚拟机通过以下两种方式保证线程安全</p><ul><li><strong>CAS+失败重试</strong> : 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</li><li><strong>TLAB</strong> : 为每一个线程预先在Eden区分配一块内存, JVM在给线程中的对象分配内存时, 首先在TLAB分配, 当对象大于TLAB中的剩余内存或TLAB的内存已用尽时, 再采用上述的CAS进行内存分配</li></ul><h3 id="Step3-初始化零值">Step3: 初始化零值</h3><p>内存分配完成时, 虚拟机需要将分配到的内存空间都初始化为零值, 这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用, 程序能访问到这些字段的数据类型所对应的零值</p><h3 id="Step4-设置对象头">Step4: 设置对象头</h3><p>设置完零值之后, 虚拟机还要对对象进行必要的设置, 例如这个对象是哪个类的实例, 如何才能找到类的元数据信息, 对象的哈希码, 对象的 GC分代年龄等信息, 这些信息存储在对象的对象头之中</p><h3 id="Step5-执行init方法">Step5: 执行init方法</h3><p>执行new指令后还要接着执行 <code>&lt;init&gt;</code> 方法, 这样一个真正可用的对象才算完全产生出来</p><h2 id="对象的内存布局">对象的内存布局</h2><p>在HotSpot虚拟机中, 对象在内存中的布局可以分为3块区域: <strong>对象头</strong> , <strong>实例数据</strong> , <strong>对齐填充</strong></p><p><strong>HotSpot虚拟机的对象头包含两部分信息, 第一部分用于存储对象自身的运行时数据, 另一部分是类型指针</strong></p><p><strong>实例数据部分是对象真正存储的有效信息</strong>, 也是程序中所定义的各种类型的字段内容</p><p><strong>对齐填充部分不是必然存在的, 也没有什么特殊的含义, 仅仅起占位左右</strong>, 由于HotSpot的内存管理系统要求对象起始地址必须是8字节的整数倍, 换句话说就是任何对象的大小都必须是8字节的整数倍. 对象头部分已经被设计成8字节的倍数, 所以如果对象实例数据部分没有对齐的话, 就需要对齐填充部分来补全</p><h2 id="对象的访问定位">对象的访问定位</h2><p>对象访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种</p><ul><li>如果使用句柄访问的话, Java堆中可能会划分出一块内存作为句柄池, reference中存储的就是对象的句柄地址, 而句柄中包含对象实例数据与类型数据各自具体的地址信息</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/access-location-of-object-handle.png" alt=""></p><ul><li>如果使用直接指针访问的话, Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息, reference中存储的直接就是对象地址, 如果只是访问对象本身的话, 就不需要多一次间接访问的开销</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/access-location-of-object-handle-direct-pointer.png" alt=""></p><p>使用指针访问的最大好处就是速度更快, 节省了一次指针定位的时间开销. 对于HotSpot而言, 主要使用第二种方式进行对象访问</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: &lt;a href=&quot;https://javaguide.cn/java/jvm/memory-area.html&quot;&gt;https://javaguide.cn/ja</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.4</title>
    <link href="https://yonagi04.github.io/posts/2024/abe5e040fe2a/"/>
    <id>https://yonagi04.github.io/posts/2024/abe5e040fe2a/</id>
    <published>2024-04-04T14:54:16.000Z</published>
    <updated>2025-05-18T09:07:25.411Z</updated>
    
    <content type="html"><![CDATA[<p>今天来几道简单的哈希表题，顺带回顾一下 Java 的HashMap，HashSet的一些API</p><h2 id="lc219-存在重复元素-II（EZ）">lc219. 存在重复元素 II（EZ）</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul><hr><p>最简单的方法当然是暴力——两重循环，这样很快就能写出最简单的题解代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; Math.abs(i - j) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的解法，大一刚学会C语言的新生都知道可以这么写，但是时间复杂度非常糟糕，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，考虑到这道题的数据范围，非常容易就tle</p><p>那么就要考虑优化。我们知道哈希表的查找非常快，所以我们可以利用哈希表来帮助我们查找。把已经遍历过的键值对存进哈希表就可以了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; Math.abs(map.get(nums[i]) - i) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们成功把复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><hr><h2 id="lc242-有效的字母异位词（EZ）">lc242. 有效的字母异位词（EZ）</h2><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p>**注意：**若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><hr><p>我们先不考虑进阶情况。其实，把不带进阶要求的题目解出来了，进阶的也就能跟着一起接出来了</p><p>我们知道字符串 s 和 t 都由小写字母组成，说明最多就只能出现26种不同的字符。所以我们可以用数组来代替哈希表，先遍历字符串，再遍历哈希表，查询是否存在某一个下标使得两个数组对应的值不同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] sHash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] tHash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sHash[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            tHash[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHash[i] != tHash[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于进阶要求，我的思路是这样的：unicode字符同样也是有限的（Unicode4.0规范前，utf-8编码下，unicode字符共65536个，即使是Unicode4.0规范之后，unicode编码的字符数量仍然是有限的），并且，unicode字符的编码同样也是int类型，所以我们可以也用数组来代替哈希表</p><p>但是这样有一个很大的缺点——我们不一定有很多数据要存储，但是我们却开辟了过大的数组空间，例如，我们至少要开辟65536 * 2byte * 2 字节的数组空间，这样的话内存占用会非常大。虽然我们都说要 ”空间换时间“，但是对于这种无用的空间浪费，很显然我们是可以避免的</p><p>所以实际上，如果真的要完成进阶要求，我们不能用数组，得考虑使用哈希表。哈希表的使用，在这里不再赘述</p><hr><h2 id="lc49-字母异位词分组（MD）">lc49. 字母异位词分组（MD）</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 10^4</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><hr><p>因为Java中的String不能排序，所以相对于C++来讲，增加了一点不方便（这里的不方便是指做题，实际上Java的String远比C++的String好用，C++的String真的是要啥没啥），但我们也能做出来</p><p>这里的字母异位词，是指重新排列源单词的所有字母得到的一个新单词，那么说明字母异位词它们字母的出现次数应该是一样的。例如aba和aab，它们是字母异位词，a同样出现了2次，b出现了1次。所以对于异位词判定，我们可以用类似于前面提到的数组来存储字母的出现次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                    sb.append(count[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            List&lt;String&gt; list = hash.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            hash.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(hash.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc1-两数之和（EZ）">lc1. 两数之和（EZ）</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><hr><p>力扣的第一道题</p><p>我第一次做这道题还是我刚刚大一入学的时候，那时候别说 Java 和 C++了，C语言都没学明白，最后还是看的题解才把这道题写出来，但还是搞不明白这道题到底要怎么做；后来我系统学了数据结构与算法，第一次用暴力法把这道题a出来，我能感受到一种成就感；再到后来，我学了C++，知道了哈希表是什么东西，第一次用哈希表把这道题a出来，也深刻感受到了什么叫做算法，什么是算法的魅力——从一般甚至最劣算法、最多的时间占用，优化到最优算法、最少的时间占用、最优秀的时间复杂度；到我后来进acm队，各种训练各种比赛，哈希表也是我经常会用到的数据结构，可以说是这道题开始了我的算法生涯吧</p><p>我印象很深刻，这道题下面有一个评论，是这样的</p><blockquote><p>有人相爱，有人夜里开车看海，有人leetcode第一题都做不出来。</p></blockquote><p>2万多人点赞，我也是其中的一员。被卡在第一题，简单题，甚至放到现在来说都不能叫做算法题的题，确实很可耻</p><p>不说了，讲题解。这道题大家都应该很熟悉了，不多废话，其实就是用哈希表来对已经遍历过的数据进行存储，毕竟哈希表查找速度快，数组查找速度慢</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc202-快乐数（EZ）">lc202. 快乐数（EZ）</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2^31 - 1</code></li></ul><hr><p>我最开始的解法是双指针——很明显是抄的力扣官方题解，以至于我到现在都不知道这道题用双指针要怎么做——看到这里的读者可以尝试着用双指针做这道题</p><p>还是哈希表，还是缓存已经查询过的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getSum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来几道简单的哈希表题，顺带回顾一下 Java 的HashMap，HashSet的一些API&lt;/p&gt;
&lt;h2 id=&quot;lc219-存在重复元素-II（EZ）&quot;&gt;lc219. 存在重复元素 II（EZ）&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; </summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>本周生活近况</title>
    <link href="https://yonagi04.github.io/posts/2024/b7535545ceea/"/>
    <id>https://yonagi04.github.io/posts/2024/b7535545ceea/</id>
    <published>2024-04-04T12:57:47.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>随便写点</p><hr><p>最近一直都在忙着练琴，差不多每天都能练1.5个小时吧。最近在练音阶了（更通俗的说法，就是爬格子），感觉自己还是有点进步的</p><p>但是练到左手手指真的痛得不行。尤其是按1弦，1弦最细，按下去真的疼啊</p><p>我最开始说我自己的左手打不开，按品格总是按不到，最近感觉略有好转，频繁地爬格子让我逐渐适应了按品格的过程</p><p>想赶紧练，练完了就能cover各种曲子</p><hr><p>看我最近的技术博客就知道，最近还在学 JVM，我感觉进度真的很慢，虽然我上周刚刚把项目写完。我现在还差计网+os+mysql+redis+spring八股，差了一大堆东西，都不知道怎么在5月或者5月中旬把它们全部补完，想想就头疼。我自己搞了俩项目，过段时间还得把那个单体项目重新跑起来，准备一下面试可能会被问到的问题</p><p>然后这个傻逼电信的专业课是真他妈的又多又难，最近明显能感觉自己跟不上了</p><hr><p>昨天看了《京吹3》和重制版《狼与香辛料》的第一话，个人感觉非常不错，年轻时候看番的感觉又回来了。等过段时间其他片子都开播之后我会继续更新动画区的博客</p><hr><p>就这样吧，继续刷题</p>    <div id="aplayer-Usszlkyj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1415430214" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86" data-listfolded="true"    ></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随便写点&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近一直都在忙着练琴，差不多每天都能练1.5个小时吧。最近在练音阶了（更通俗的说法，就是爬格子），感觉自己还是有点进步的&lt;/p&gt;
&lt;p&gt;但是练到左手手指真的痛得不行。尤其是按1弦，1弦最细，按下去真的疼啊&lt;/p&gt;
&lt;p&gt;我最开始说我自己的左</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.3</title>
    <link href="https://yonagi04.github.io/posts/2024/fcb0916f8943/"/>
    <id>https://yonagi04.github.io/posts/2024/fcb0916f8943/</id>
    <published>2024-04-04T09:26:10.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>昨天没时间写刷题日记了，今天来补</p><h2 id="lc383-赎金信（EZ）">lc383. 赎金信（EZ）</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><hr><p>哈希表经典题</p><p>这道题是出现的都是小写字母，所以可以用数组来代替哈希表，就是下面的 <code>int[] hash = new int[26]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (magazine.length() &lt; ransomNote.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            hash[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc205-同构字符串（EZ）">lc205. 同构字符串（EZ）</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p><p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>t.length == s.length</code></li><li><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</li></ul><hr><p>写的第一个题解代码，个人感觉不太好，用了两个哈希表来存，时间表现也不太好，遂写了现在的代码，优化成了只需要一个哈希表，并且耗时也更短</p><p>没什么难度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> s.charAt(i), y = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash.get(x) != y) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash.containsValue(y)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash.put(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc290-单词规律（EZ）">lc290. 单词规律（EZ）</h2><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= pattern.length &lt;= 300</code></li><li><code>pattern</code> 只包含小写英文字母</li><li><code>1 &lt;= s.length &lt;= 3000</code></li><li><code>s</code> 只包含小写英文字母和 <code>' '</code></li><li><code>s</code> <strong>不包含</strong> 任何前导或尾随对空格</li><li><code>s</code> 中每个单词都被 <strong>单个空格</strong> 分隔</li></ul><hr><p>换汤不换药</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String s)</span> &#123;</span><br><span class="line">        Map&lt;String, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; pattern.length(); p++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(p);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= slen) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; slen &amp;&amp; s.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> s.substring(i, j);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(word)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash.get(word) != ch) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash.containsValue(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash.put(word, ch);</span><br><span class="line">            &#125;</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= slen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天没时间写刷题日记了，今天来补&lt;/p&gt;
&lt;h2 id=&quot;lc383-赎金信（EZ）&quot;&gt;lc383. 赎金信（EZ）&lt;/h2&gt;
&lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;rans</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM专题——类文件加载</title>
    <link href="https://yonagi04.github.io/posts/2024/a27f69d2c877/"/>
    <id>https://yonagi04.github.io/posts/2024/a27f69d2c877/</id>
    <published>2024-04-02T16:16:46.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: <a href="https://javaguide.cn/java/jvm/class-loading-process.html">https://javaguide.cn/java/jvm/class-loading-process.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a></p></blockquote><h1>类加载过程</h1><p>一个类从被加载到 JVM 内存开始, 到卸载出内存位置, 它的整个生命周期会经历 <strong>加载</strong> , <strong>验证</strong> , <strong>准备</strong> , <strong>解析</strong> , <strong>初始化</strong> , <strong>使用</strong> 和 <strong>卸载</strong> 七个阶段, 其中, <strong>验证</strong> , <strong>准备</strong> , <strong>解析</strong> 这三个阶段统称为 <strong>连接</strong></p><p>加载, 验证, 准备, 初始化, 卸载这五个阶段的顺序是确定的, 类型的加载过程必须按照这种顺序按部就班地开始, 而解析顺序不一定</p><h2 id="加载">加载</h2><p>类加载过程的第一步, 主要完成下面三件事情:</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问入口</li></ul><p>加载这一步主要是通过 <strong>类加载器</strong> 完成的, 具体是由哪个类加载器加载由 <strong>双亲委派模型</strong> 决定</p><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code> , 不过, 数组类不是由 <code>ClassLoader</code> 加载的, 而是 JVM 在需要的时候自动创建的, 数组类通过 <code>getClassLoader()</code> 方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的</p><p>一个非数组类的加载阶段 (加载阶段获取类的二进制字节流的动作) 是可控性最强的阶段, 这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式 (重写一个类加载器的 <code>loadClass()</code> 方法)</p><p>加载阶段与连接阶段的部分动作 (如一部分字节码文件格式验证动作) 是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始, 但这些夹在加载阶段之中进行的动作, 仍然属于连接阶段的一部分, 这两个阶段的开始时间仍然保持着固定的先后顺序</p><h2 id="验证">验证</h2><p>验证是连接阶段的第一步, 这一阶段的目的是为了确保 Class 文件的字节流中的信息符合 Java 虚拟机规范的全部约束要求, 保证这些信息被当作代码运行后不会危害虚拟机的安全</p><p>Java 虚拟机如果不检查输入的字节流, 对其完全信任的话, 很可能会因为载入了有错误或者有恶意企图的字节码流导致整个系统受攻击甚至崩溃, 所以验证字节码是 Java 虚拟机保护自身的必要措施</p><p>验证阶段大致上会完成下面四个阶段的检验动作: <strong>文件格式验证, 元数据验证, 字节码验证和符号引用验证</strong></p><h3 id="文件格式验证">文件格式验证</h3><p>验证点如下:</p><ol><li>是否以魔数 0xCAFEBABE 开头</li><li>主, 次版本号是否在当前 Java 虚拟机的可接受范围之内</li><li>常量池中是否有不被支持的常量类型</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info型的常量中是否有不符合 UTF-8 编码的数据</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息</li></ol><p>主要目的是保证输入的字节流能够正确地解析并存储于方法区内, 格式上符合描述一个 Java 类型信息的要求.</p><p>这阶段的验证是基于二进制字节流进行的, 只有通过了这个阶段的验证之后, 这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构上进行的, 不会再读取, 操作字节流了</p><h3 id="元数据验证">元数据验证</h3><p>验证点如下:</p><ol><li>这个类是否有父类 (除了 java.lang.Object 之外, 所有的类都应当有父类)</li><li>这个类的父类是否继承了不允许被继承的类</li><li>如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段, 方法是否与父类产生矛盾</li></ol><p>主要是对字节码描述的信息进行语义分析, 保证不存在与 Java语言规范 定义相悖的元数据信息</p><h3 id="字节码验证">字节码验证</h3><p>验证点如下:</p><ol><li>保证任意时刻操作数栈的数据类型和指令代码序列都能配合工作, 例如不能出现类似于 “在操作栈中放置了一个int类型的数据, 使用时却按照long类型加载入本地变量表中” 这种情况</li><li>保证任何跳转指令都不会跳转到方法体之外的字节码指令上</li><li>保证方法体中的类型转换总是有效的, 例如可以把一个子类对象赋给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型甚至一个毫无继承关系的数据类型, 则是不合法的</li></ol><h3 id="符号引用验证">符号引用验证</h3><p>验证点如下:</p><ol><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>符号引用中类, 字段, 方法的可访问性是否可被当前类访问</li></ol><p>符号引用验证的目的是确保解析行为可以正常执行, 如果无法通过符号引用验证, Java 虚拟机会抛出一个 <code>java.lang.IncompatibleClassChangeError</code> 的子类异常, 典型的有: <code>java.lang.IllegalAccessError</code> , <code>java.lang.NoSuchFieldError</code> , <code>java.lang.NoSuchMethodError</code> 等</p><h2 id="准备">准备</h2><p>准备阶段是正式为类中定义的变量 (即静态变量, 被static修饰的变量) 分配内存并设置类变量初始值的阶段.</p><p>需要注意的几点</p><ol><li>这时候进行内存分配的仅包括类变量, 而不包括实例变量, 实例变量会在对象实例化时随着对象一起分配在 Java 堆中</li><li>这里所说的初始值 “通常情况下” 是数据类型的零值(如 0, 0L, null, false 等)</li><li>类变量使用的内存都应当在方法区中分配, 不过需要注意的是, 在 JDK7 以前, HotSpot 使用永久代实现方法区时, 是符合这种逻辑概念的, 但是在 JDK7 之后, HotSpot已经把原本放在永久代的字符串常量池, 静态变量等移动到堆中, 这时候类变量则会随着 Class 对象一起存放在 Java 堆中</li></ol><h2 id="解析">解析</h2><p>解析阶段是 JVM 将常量池中的符号引用直接替换为直接引用的过程</p><p>解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄和调用点限定符这7种符号引用进行</p><h2 id="初始化">初始化</h2><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code> 方法的过程, 是类加载的最后一步, 这一步 JVM 才开始真正执行类中定义的 Java 程序代码</p><p>对于 <code>&lt;clinit&gt;()</code> 方法的调用, 虚拟机会自己确保其在多线程环境中的安全性, 因为 <code>&lt;clinit&gt;()</code> 方法是带锁线程安全, 所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞, 并且这种阻塞很难被发现</p><p>对于初始化阶段, 虚拟机严格规范了有且只有6种情况, 必须对类进行初始化</p><ol><li>当遇到 <code>new</code> , <code>getstatic</code> , <code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时, 比如 <code>new</code> 一个类, 读取一个静态字段, 或调用一个类的静态方法<ul><li>当 JVM 执行 <code>new</code> 指令时会初始化类, 即当程序创建一个类的实例对象</li><li>当 JVM 执行 <code>getstatic</code> 指令时会初始化类, 即程序访问类的静态变量</li><li>当 JVM 执行 <code>putstatic</code> 指令时会初始化类, 即程序给类的静态变量赋值</li><li>当 JVM 执行 <code>invokestatic</code> 指令时会初始化类, 即程序调用类的静态方法</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forName(&quot;...&quot;)</code> , <code>newInstance()</code> 等. 如果类没有初始化, 需要触发其初始化</li><li>初始化一个类, 如果其父类没有初始化, 则先触发父类的初始化</li><li>当虚拟机启动时, 用户需要定义一个要执行的主类, 虚拟机会先初始化这个类</li><li><code>MethodHandle</code> 和 <code>Varhandle</code> 可以看作是轻量级的反射调用机制, 而要想使用这两个调用, 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li><li>当一个接口中定义了 JDK8 新加入的默认方法时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化</li></ol><h2 id="类卸载">类卸载</h2><p><strong>卸载类即该类的 Class 对象被GC</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有实例对象都已被 GC, 也就是说堆不存在该类的实例对象</li><li>该类没有在其他地方被引用</li><li>该类的类加载器实例已被GC</li></ol><h1>类加载器</h1><h2 id="类与类加载器">类与类加载器</h2><p><strong>类加载器的主要作用就是加载 Java 类的字节码 (<code>.class</code> 文件) 到 JVM 中 (在内存中生成一个代表该类的 <code>Class</code> 对象)</strong></p><p><strong>对于任意一个类, 都必须由加载它的类加载器和这个类本身一起共同确定其在 JVM 中的唯一性, 每个类加载器都有一个独立的类名称空间</strong></p><p>也就是说, 比较两个类是否 “相等”, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个 Class 文件, 被同一个 JVM 加载, 只要加载它们的类加载器不同, 那么这两个类必定不相等</p><p>此处的相等, 包括 Class 对象的 <code>equals()</code> 方法, <code>isAssignableFrom()</code> 方法, <code>isInstance</code> 方法的返回结果, 也包括了使用 <code>instanceof</code> 关键字做对象所属关系判断等各种情况</p><h2 id="加载规则">加载规则</h2><p>JVM 启动时, 并非会一次性加载所有的类, 而是根据需要动态加载类. 也就是说大部分类都是在具体用到的时候才会去加载, 这样对内存更友好</p><p>对于已经加载的类会放在 <code>ClassLoader</code> 中, 在类加载时, 系统会先判断这个类是否被加载过, 已经被加载过的类会直接返回, 否则会尝试加载. 也就是说, 对于一个类加载器来说, 相同二进制名称的类只会被加载一次</p><h2 id="类加载器总结">类加载器总结</h2><p>JVM 中内置了3个重要的 <code>ClassLoader</code></p><ol><li><code>BootstrapClassLoader</code> (启动类加载器): 最顶层加载类, 由C++实现, 通常表示为null, 且没有父级, 主要用来加载 JDK 内部的核心类库以及被 <code>-Xbootclasspath</code> 参数指定的路径下的所有类</li><li><code>ExtensionClassLoader</code> (扩展类加载器): 主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下所有的类</li><li><code>AppClassLoader</code> (应用程序类): 负责加载当前应用 classpath 下所有的jar包和类</li></ol><p>除了上面三个类加载器, 用户还可以自定义类加载器</p><p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外, 其他所有的类加载器都是在 JVM 外部实现的, 并且全部继承自 <code>ClassLoader</code> 抽象类. 这样的好处是用户可以自定义类加载器, 以便让应用程序自己决定如何去获取所需的类</p><p>每个 <code>ClassLoader</code> 都可以通过 <code>getParent()</code> 获取其父加载器, 如果获取到的加载器为 null 的话, 说明该类是通过 <code>BootstrapClassLoader</code> 加载到</p><h2 id="自定义类加载器">自定义类加载器</h2><p>如果需要自定义类加载器, 需要继承 <code>ClassLoader</code> 抽象类</p><p><code>ClassLoader</code> 中有两个关键的方法</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code> : 加载指定二进制名称的类, 实现双亲委派机制</li><li><code>protected Class findClass(String name)</code> : 根据类的二进制名称查找类, 默认实现是空方法</li></ul><p>如果不想打破双亲委派机制, 就重写 <code>ClassLoader</code> 中的 <code>findClass()</code> 方法. 但是, 如果想打破双亲委派机制就需要重写 <code>loadClass()</code> 方法</p><h2 id="双亲委派模型">双亲委派模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="" alt="https://unpkg.com/yonagi-blog-repo-img/img/content/jvmclassload.png"></p><p>如图所示的各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型”. 双亲委派模型要求除了顶层的启动类加载器之外, 其他类加载器都必须有自己的父类加载器. 这里类加载器之间的父子关系不是以继承的关系来实现的, 而是通常使用组合关系复用父加载器的代码</p><p>双亲委派模型的执行流程:</p><ul><li>在类加载时候, 系统会判断这个类是否被加载过, 已经被加载过的类会直接返回, 否则会尝试加载</li><li>类加载器在进行类加载的时候, 他首先不会自己尝试加载这个类, 而是把这个请求委派给父类加载器去完成. 这样的话, 所有的请求都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中</li><li>只有当父加载器反馈自己无法完成这个加载请求, 子加载器才会尝试自己去加载</li><li>如果子加载器也无法加载, 抛出 <code>ClassNotFoundException</code> 异常</li></ul><p>双亲委派模型保证了 Java 程序的稳定运行, 也避免类的重复加载, 也保证了 Java 的核心 API 不被篡改</p><h2 id="打破双亲委派模型">打破双亲委派模型</h2><p>双亲委派模型并非是一个具有强制性约束的模型, 而是 Java 设计者推荐给开发者的类加载器实现方式</p><p>为了打破双亲委派模型, 需要继承 <code>ClassLoader</code> , 如果不想打破双亲委派模型, 就重写 <code>ClassLoader</code> 中的 <code>findClass()</code> 方法, 如果要打破双亲加载机制就需要重写 <code>loadClass()</code> 方法</p><p>重写 <code>loadClass()</code>方法之后, 我们就可以改变传统双亲委派模型的执行流程.例如, 子类加载器可以在委派给父类加载器之前, 先自己尝试加载这个类, 或者在父类加载器返回之后, 再尝试从其他地方加载这个类. 具体的规则由我们自己实现，根据项目需求定制化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: &lt;a href=&quot;https://javaguide.cn/java/jvm/class-loading-process.html&quot;&gt;https://javag</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.2</title>
    <link href="https://yonagi04.github.io/posts/2024/36228778b54f/"/>
    <id>https://yonagi04.github.io/posts/2024/36228778b54f/</id>
    <published>2024-04-02T14:58:14.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口专题，今天三道滑动窗口的题目</p><h2 id="lc209-长度最小的子数组（MD）">lc209. 长度最小的子数组（MD）</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><hr><p>我们先不看进阶要求，进阶的稍后我会讲讲我的思路……</p><p>这道题是一道非常经典的滑动窗口题目。滑动窗口是什么东西？这个东西应该来源于计算机网络，TCP用于控制流量的一个措施之一，现在我们把滑动窗口这个模型拿出来用在算法题上面，也是一个非常好用的算法解题技巧</p><p>其实滑动窗口的本质，还是昨天讲过的双指针。滑动窗口的左右两端由两个指针 l 和 r 进行控制移动，这不就是双指针模型了吗，处理滑动窗口的思路和双指针的思路基本上是接近的，只要双指针学明白了，滑动窗口也不难理解</p><p>这道题不难，直接给题解代码，用双指针的思路来看这道题还是很容易理解的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                res = Math.min(res, r - l + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后简单讲讲进阶要求。进阶要求我们使用 <code>O(nlog(n))</code> 的时间复杂度来完成本题……我能想到的方法就是先去排序，然后处理思路和昨天做过的三数之和差不多，这样就能达到 <code>O(nlog(n))</code> 的时间复杂度。不过我没有自己动手写过，有时间可以写一下</p><hr><h2 id="lc3-无重复字符的最长子串（MD）">lc3. 无重复字符的最长子串（MD）</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><hr><p>这道题还是滑动窗口，前面说到了，滑动窗口的本质其实就是同向移动的双指针</p><p>关于 <strong>不包含重复字符</strong> ， 当然要用 HashSet 来去重，不用多说了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                hash.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; s.length() &amp;&amp; !hash.contains(s.charAt(r + <span class="number">1</span>))) &#123;</span><br><span class="line">                hash.add(s.charAt(r + <span class="number">1</span>));</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, r - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc76-最小覆盖子串（HD）">lc76. 最小覆盖子串（HD）</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><hr><p>本栏目开设以来接触的第……三道hard题吧？</p><p>这道题倒是有点hard的样子了，当然这道题其实还是和刚刚的 lc3 一样，双指针+哈希表去重。与 lc3 不一样的是，这道题要先预处理，然后需要做特判</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            cnt.put(t.charAt(i), cnt.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ansL</span> <span class="operator">=</span> -<span class="number">1</span>, ansR = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; s.length() &amp;&amp; cnt.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                hash.put(s.charAt(r), hash.getOrDefault(s.charAt(r), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (check() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = l + len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt.containsKey(s.charAt(l))) &#123;</span><br><span class="line">                    hash.put(s.charAt(l), hash.getOrDefault(s.charAt(l), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansL == -<span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(ansL, ansR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> cnt.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) it.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (hash.getOrDefault(key, <span class="number">0</span>) &lt; value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码量就能看出，这不是一个轻松的hard题，尤其是初见，如果不通过debug直接一次性a出来其实是有点小难的。个人认为这道题应该属于中位hard，之前提到的两道hard题都属于下位hard</p><hr><h2 id="lc141-环形链表（EZ）">lc141. 环形链表（EZ）</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 10^4]</code></li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p>**进阶：**你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><hr><p>hard题结束了，我们来道简单题，环形链表判断</p><p>又是快慢双指针，不知道大家有没有腻味，反正我已经做这种题已经做腻了</p><p>简单题，不讲解。直接给代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现我们这个题解在不经意间也完成了进阶要求。没错这道题就是这么简单，3岁小孩都能a</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;滑动窗口专题，今天三道滑动窗口的题目&lt;/p&gt;
&lt;h2 id=&quot;lc209-长度最小的子数组（MD）&quot;&gt;lc209. 长度最小的子数组（MD）&lt;/h2&gt;
&lt;p&gt;给定一个含有 &lt;code&gt;n&lt;/code&gt; 个正整数的数组和一个正整数 &lt;code&gt;target&lt;/code&gt; &lt;s</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JVM专题——类文件结构</title>
    <link href="https://yonagi04.github.io/posts/2024/c5f1dcfff5a1/"/>
    <id>https://yonagi04.github.io/posts/2024/c5f1dcfff5a1/</id>
    <published>2024-04-01T17:19:16.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: <a href="https://javaguide.cn/java/jvm/class-file-structure.html">https://javaguide.cn/java/jvm/class-file-structure.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a></p></blockquote><h1>Class 类文件结构</h1><p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符， 这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据， 没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。</p><p><code>ClassFile</code> 结构如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //Class 文件的标志</span><br><span class="line">    u2             minor_version;//Class 的小版本号</span><br><span class="line">    u2             major_version;//Class 的大版本号</span><br><span class="line">    u2             constant_pool_count;//常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">    u2             access_flags;//Class 的访问标记</span><br><span class="line">    u2             this_class;//当前类</span><br><span class="line">    u2             super_class;//父类</span><br><span class="line">    u2             interfaces_count;//接口数量</span><br><span class="line">    u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;//字段数量</span><br><span class="line">    field_info     fields[fields_count];//一个类可以有多个字段</span><br><span class="line">    u2             methods_count;//方法数量</span><br><span class="line">    method_info    methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="魔数与Class文件版本号">魔数与Class文件版本号</h2><p>每个Class文件的头四个字节被称为 <strong>魔数</strong> , 它用来判断这个文件是否是一个能够被Java虚拟机接收的Class文件. Java虚拟机规定魔数必须是 <strong>0xCAFEBABE</strong> , 否则虚拟机会拒绝加载这个Class文件</p><p>紧接着魔数的四个字节是 <strong>Class文件的版本号</strong> , 第5和第6字节是 <strong>次版本号</strong> , 第7和第8字节是 <strong>主版本号</strong> . 高版本的JDK能够向下兼容低版本的Class文件, 但是低版本的JDK不能向上兼容高版本的Class文件</p><h2 id="常量池">常量池</h2><p>紧接着魔数和Class文件版本号之后的是 <strong>常量池入口</strong> . 常量池可以比喻为Class文件中的资源仓库, 它是Class文件结构中与其他项目关联最多的数据, 同时也是占用Class文件空间最大的数据项目之一, 另外它还是Class文件中第一个出现的表类型数据项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u2             constant_pool_count;//常量池的数量</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];//常量池</span><br></pre></td></tr></table></figure><p>常量池的数量是 <code>constant_pool_count - 1</code> (常量池计数器是从1开始计数的, 常量池索引为0表示 “不引用任何一个常量池项”)</p><p>常量池中主要存放两大类常量: <strong>字面量</strong> 和 <strong>符号引用</strong> . 字面量比较接近于 Java 语言中的常量概念, 而符号引用属于编译原理的概念, 主要包括以下几类变量</p><ul><li>被模块导入或者开放的包</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li><li>方法句柄和方法类型</li><li>动态调用点和动态常量</li></ul><p>常量池中每一个常量都是一个表, 到JDK13版本目前有17个不同类型的常量</p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>表示一个动态计算常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>表示一个模块</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>表示一个模块中开放或者导出的包</td></tr></tbody></table><h2 id="访问标志">访问标志</h2><p>在常量池结束之后, 紧接着的2个字节代表 <strong>访问标志</strong> , 用于识别一些类或者接口层次的访问信息, 包括: 这个Class是类还是接口; 是否为 public 或者abstract; 如果是类的话, 是否被声明为 final</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否为final</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否使用invokespecial字节码指令的新语义</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>是否是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标识这是一个模块</td></tr></tbody></table><h2 id="类索引-父类索引和接口索引集合">类索引, 父类索引和接口索引集合</h2><p>类索引, 父类索引和接口索引都按顺序排列在访问标志之后, 类索引和父类索引用两个u2类型的索引值表示, 它们各自指向一个类型为CONSTANT_Class_info的类描述符常量, 通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info类型的常量中的全限定名字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u2             this_class;//当前类</span><br><span class="line">u2             super_class;//父类</span><br><span class="line">u2             interfaces_count;//接口数量</span><br><span class="line">u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><h2 id="字段表集合">字段表集合</h2><p>字段表用于描述接口或类中声明的变量. 字段包括类级变量以及实例变量, 但不包括在方法内部声明的局部变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u2             fields_count;//字段数量</span><br><span class="line">field_info     fields[fields_count];//一个类会可以有个字段</span><br></pre></td></tr></table></figure><p>字段表结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">u2access_flags;</span><br><span class="line">u2name_index;</span><br><span class="line">u2descriptor_index;</span><br><span class="line">u2atributes_count;</span><br><span class="line">attribute_infoattributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>access_flags</strong> : 字段的作用域 (<code>public</code> , <code>private</code> , <code>protected</code> 修饰符), 是实例变量还是类变量, 可否被序列化, 可变性( <code>final</code> 修饰 ) , 可见性(<code>volatile</code>)</li><li><strong>name_index</strong> : 对常量池的引用, 表示的字段的名称</li><li><strong>descriptor_index</strong> : 对常量池的引用, 标识字段和方法的描述符</li><li><strong>attributes_count</strong> : 一个字段还会拥有一些额外的属性, attributes_count 存放属性的个数</li><li><strong>attributes[attributes_count]</strong> : 存放具体属性具体内容</li></ul><p>上述这些信息中, 各个修饰符都是布尔值, 要么有某个修饰符, 要么没有, 很适合使用标志位来表示. 而字段叫什么名字, 字段被定义为什么数据类型这些都是无法固定的, 只能引用常量池中常量来描述</p><h2 id="方法表集合">方法表集合</h2><p>Class文件存储格式中对于方法的描述和对字段的描述几乎是一模一样的, 方法表的结构如同字段表一样, 依次包括了访问标志, 名称索引, 描述符索引, 属性表集合等</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u2             methods_count;//方法数量</span><br><span class="line">method_info    methods[methods_count];//一个类可以有个多个方法</span><br></pre></td></tr></table></figure><p>方法表结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">u2access_flags;</span><br><span class="line">u2name_index;</span><br><span class="line">u2descriptor_index;</span><br><span class="line">u2attributes_count;</span><br><span class="line">attribute_infoattributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>volatile</code> 和 <code>transient</code> 修饰符不能修饰方法, 所以方法表的访问标志中没有这两个对应的标志, 但是增加了 <code>synchronized</code> , <code>native</code> , <code>abstract</code> 等关键字修饰方法, 所以也就多了这些关键字对应的标志</p><h2 id="属性表集合">属性表集合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];//属性表集合</span><br></pre></td></tr></table></figure><p>与 Class 文件中其他的数据项目要求严格的顺序, 长度, 内容不同, 属性表集合的限制稍微宽松一点, 不再要求各个属性表具有严格的顺序, 并且Java虚拟机规范允许只要不与已有属性名重复, 任何人实现的编译器都可以向属性表中写入自己定义的属性信息, Java虚拟机运行时会忽略掉它不认识的属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide和《深入理解Java虚拟机》, Java Guide地址: &lt;a href=&quot;https://javaguide.cn/java/jvm/class-file-structure.html&quot;&gt;https://javagu</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.4.1</title>
    <link href="https://yonagi04.github.io/posts/2024/4e8c8c2c5470/"/>
    <id>https://yonagi04.github.io/posts/2024/4e8c8c2c5470/</id>
    <published>2024-04-01T15:37:39.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>今天是双指针专题，双指针题目居多</p><h2 id="lc167-两数之和II-输入有序数组（MD）">lc167. 两数之和II - 输入有序数组（MD）</h2><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [2,7,11,15], target = 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [-1,0], target = -1</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 10^4</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li><strong>仅存在一个有效答案</strong></li></ul><hr><p>利用好这道题数组 <strong>非递减顺序排列</strong> 的特性，可以使用双指针法，左右互推。如果求出来的两数之和偏大，右指针左移，偏小则左指针右移</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[l] + numbers[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = l + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = r + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc11-盛最多水的容器（MD）">lc11. 盛最多水的容器（MD）</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= height[i] &lt;= 10^4</code></li></ul><hr><p>双指针经典题了</p><p>还是老样子，左右双指针。每次都要用max函数判定一下最大水量。至于移动，则优先移动高度最低的一边，毕竟我们都知道，木桶能装多少水取决于最短的边，而不是最长的边</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">water</span> <span class="operator">=</span> (r - l) * Math.min(height[l], height[r]);</span><br><span class="line">            res = Math.max(res, water);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc15-三数之和（MD）">lc15. 三数之和（MD）</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><hr><p>还是双指针</p><p>思路不复杂。最开始这个数组是乱序的，如果我们要用到双指针这个技巧，那么必须先做一个排序，让他变成升序的</p><p>根据题目nums[i] + nums[j] + nums[k] == 0 的要求，显然，如果此时我们遍历到的nums[i] 已经大于 0 了， 那么肯定没法让这个等式成立，所以可以直接break掉</p><p>介于本题中要求答案不能包含重复三元组，所以需要去重</p><p>然后就是双指针了，基本和其他题目的代码是一样的</p><p>接下来就是找到一个三元组之后的去重。因为前面提及不能包含重复三元组，所以在找到一个三元组之后我们必须通过判断l与l + 1、r与r - 1的值是否相等，完成去重操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[l] + nums[r] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    r--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lc146-LRU缓存（MD）">lc146. LRU缓存（MD）</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 10^5</code></li><li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li></ul><hr><p>伪装成Mid的Hard题，如果以前没有做过这道题，初见这道题还是非常有难度的，因为这道题要一次用到两个数据结构——哈希表和链表，并且要对这两个数据结构的增删改查操作非常非常熟悉</p><p>没什么好说的了，面试超高频算法题，背也要背下来</p><p>本质上就是看链表操作是否熟练，头插尾插头删尾删。这道题是不能使用语言本身自带的类似于 <code>LinkedHashMap</code> 这种集合的，要求自己手写链表，面试中同样要求全程手写链表，这就要求了我们对链表的结构和链表节点的添加/删除要足够的熟悉，所以不要试图蒙混过关</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是双指针专题，双指针题目居多&lt;/p&gt;
&lt;h2 id=&quot;lc167-两数之和II-输入有序数组（MD）&quot;&gt;lc167. 两数之和II - 输入有序数组（MD）&lt;/h2&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;1&lt;/strong&gt; 开始的整数数组 &lt;code&gt;numbers</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo将Github Page部署到Github时可能发生的一点问题</title>
    <link href="https://yonagi04.github.io/posts/2024/ec7bf31322bc/"/>
    <id>https://yonagi04.github.io/posts/2024/ec7bf31322bc/</id>
    <published>2024-04-01T09:02:49.000Z</published>
    <updated>2025-05-18T09:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<p>很奇怪的事情。昨天下午我从自习室回宿舍之前把昨天的刷题日记写完了，推送到Github，然后Hexo给我抛了一个错误</p><blockquote><p>Could not read from remote repository</p></blockquote><p>多次部署都抛了这个错误</p><p>我寻思着前一天部署也没出问题啊，我也没有改过config文件</p><p>只能去Google找解决方案了</p><p>Google给了两个解决方案：一个是修改远程仓库的域名：把域名修改成Git clone的域名，另一个是在本机上重新搞一个ssh密钥，然后上传到Github。我寻思着我这个ssh密钥还是几周前刚做的，不可能那么快就失效了，于是选择了第一个方法</p><p>然后，很成功地推送上去了</p><p>然后，我今天登本站，居然没显示新内容！</p><p>又有新问题了！我多次尝试修改文件，重新构建静态文件，然后推送到Github，都没法显示新内容，但是Hexo服务端在本机运行的时候我是能看到新内容的。也就是说Hexo没问题，是我远程仓库的域名设置有问题？</p><p>我又把域名修改回了原来的域名。很奇怪，今天就没有出现 “Could not read from remote repository” 这样的报错了，成功把新页面推送到了Github上</p><p>很奇怪的事故。到现在我都不清楚到底是哪里出现了问题，是昨天网络环境有问题，导致没法读取Github上的远程仓库吗？我不清楚</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很奇怪的事情。昨天下午我从自习室回宿舍之前把昨天的刷题日记写完了，推送到Github，然后Hexo给我抛了一个错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Could not read from remote repository&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Hexo相关" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/Hexo%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Github" scheme="https://yonagi04.github.io/tags/Github/"/>
    
    <category term="Hexo" scheme="https://yonagi04.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>奇怪的梦</title>
    <link href="https://yonagi04.github.io/posts/2024/303bd69720a9/"/>
    <id>https://yonagi04.github.io/posts/2024/303bd69720a9/</id>
    <published>2024-04-01T08:56:27.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚做了一个奇怪的梦</p><p>莫名其妙梦到自己居然拿了快手校招的offer，而我正好还是大二，甚至我还不是在学校，是在家里面。收到手子发的offer邮件，我很惊讶，我还是大二，怎么投了简历一面二面三面hr面都过了就拿到offer了？家里人也很吃惊，拿的怕不是实习offer吧？我说不是，是校招</p><p>然后好像就断片了，后面发生了什么，我记不清了</p><p>看来梦有时候就是这么荒诞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚做了一个奇怪的梦&lt;/p&gt;
&lt;p&gt;莫名其妙梦到自己居然拿了快手校招的offer，而我正好还是大二，甚至我还不是在学校，是在家里面。收到手子发的offer邮件，我很惊讶，我还是大二，怎么投了简历一面二面三面hr面都过了就拿到offer了？家里人也很吃惊，拿的怕不是实习off</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.3.31</title>
    <link href="https://yonagi04.github.io/posts/2024/83d463db599c/"/>
    <id>https://yonagi04.github.io/posts/2024/83d463db599c/</id>
    <published>2024-03-31T17:49:06.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>今天事情有点多，没什么时间刷题，象征性刷几道简单题</p><h2 id="lc28-找出字符串中第一个匹配项的下标（EZ）">lc28. 找出字符串中第一个匹配项的下标（EZ）</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 10^4</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><hr><p>简单的字符串匹配题，甚至不用kmp</p><p>轻松ac</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; m &amp;&amp; haystack.charAt(j) == needle.charAt(k)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc125-验证回文串（EZ）">lc125. 验证回文串（EZ）</h2><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;amanaplanacanalpanama&quot; 是回文串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;race a car&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;raceacar&quot; 不是回文串。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; &quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。</span><br><span class="line">由于空字符串正着反着读都一样，所以是回文串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 10^5</code></li><li><code>s</code> 仅由可打印的 ASCII 字符组成</li></ul><hr><p>最开始a了一发，结果耗时200ms，非常不满意，遂再写一个时间空间复杂度低一点的</p><p>先给我第一个版本的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">para</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(s.charAt(i))) &#123;</span><br><span class="line">                para += Character.toLowerCase(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = para.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para.charAt(l) != para.charAt(r)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的题解我用了一个String来预处理，也就是说我需要先对给出来的s字符串进行处理之后才能用双指针，这样速度慢了很多</p><p>思路不变，但是把这个预处理String的操作优化掉了，直接在原来给定的s上进行指针操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; s.length() &amp;&amp; !isENCharacter(s.charAt(l))) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; !isENCharacter(s.charAt(r))) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= s.length() || r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isENCharacter</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) || (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后耗时2ms，内存占用41.78mb，非常有成就感</p><hr><h2 id="lc392-判断子序列（EZ）">lc392. 判断子序列（EZ）</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= t.length &lt;= 10^4</code></li><li>两个字符串都只由小写字符组成。</li></ul><hr><p>时间问题，我们不考虑进阶的情况了</p><p>难度不大，但我一开始居然没a出来，居然是因为最后判定的时候写错了，操</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="number">0</span>, tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sp &lt; s.length() &amp;&amp; tp &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(sp) == t.charAt(tp)) &#123;</span><br><span class="line">                sp++;</span><br><span class="line">            &#125;</span><br><span class="line">            tp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sp == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我wa的第一发就是在 sp == s.length() 这里错的，最开始脑抽写成了s.length() - 1（也许是因为我当时正好在听tymm的歌，沉醉于tymm的歌声不可自拔，遂写错代码犯下低级错误）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天事情有点多，没什么时间刷题，象征性刷几道简单题&lt;/p&gt;
&lt;h2 id=&quot;lc28-找出字符串中第一个匹配项的下标（EZ）&quot;&gt;lc28. 找出字符串中第一个匹配项的下标（EZ）&lt;/h2&gt;
&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;n</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.3.30</title>
    <link href="https://yonagi04.github.io/posts/2024/d7e12de7ade0/"/>
    <id>https://yonagi04.github.io/posts/2024/d7e12de7ade0/</id>
    <published>2024-03-30T14:32:59.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc12-整数转罗马数字（MD）">lc12. 整数转罗马数字（MD）</h2><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 3999</code></li></ul><hr><p>贪心法+打表，非常简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] val = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] s = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= val[i]) &#123;</span><br><span class="line">                    num -= val[i];</span><br><span class="line">                    res += s[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc135-分发糖果（HD）">lc135.分发糖果（HD）</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 10^4</code></li></ul><hr><p>又是一道不配被称为hard的hard题</p><p>双指针，左右两边分别遍历即可。对于糖果的具体分配，因为我们要求是最少糖果，所以对于符合条件的（相邻两个孩子评分更高的孩子会获得更多的糖果）就多给一个，不符合条件的只给一个糖（也就是贪心法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candies = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = Math.max(candies[i + <span class="number">1</span>] + <span class="number">1</span>, candies[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            res += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc58-最后一个单词的长度（EZ）">lc58. 最后一个单词的长度（EZ）</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最后一个单词是“World”，长度为5。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最后一个单词是“moon”，长度为4。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;luffy is still joyboy&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：最后一个单词是长度为6的“joyboy”。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅有英文字母和空格 <code>' '</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><hr><p>翻转计数，从最后一个下标开始往前倒推，推到出现第一个空格就终止倒推</p><p>最开始没注意到结尾也可能有空格，wa了一发</p><p>然后发现样例2结尾是有空格的，对结尾处空格做特判即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; res != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc14-最长公共前缀（EZ）">lc14. 最长公共前缀（EZ）</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><hr><p>最开始写的代码太丑陋了，时间复杂度偏高，今天重新写了个复杂度低一点的</p><p>其实，查找前缀这个问题，完全能用二分法。我们都知道，二分法首先计算区间的中间位置坐标，然后判断中间位置能否满足特定要求，然后根据返回的结果对区间进行缩小，最后得到精确的结果。</p><p>我们首先先定义一个新名词，前缀坐标，就是公共前缀的最后一个字符的下标值。前缀坐标必然大于0且小于字符串数组里面最短的字符串的字符串长度。我们要查找最长公共前缀，也就是最大的前缀坐标，那么我们就可以进行二分，左端点 l = 0，右端点 r = 字符串数组里面最短的字符串的字符串长度，此时我们计算出来的中间节点坐标值应该是 （r - l + 1 ) / 2 + l。</p><p>我们只需要进行特判——中间节点坐标对应的字符是否和其他字符串中该坐标对应的字符相等——如果相等，说明我们需要的最大前缀坐标应该在中间节点的右边或者就是在中间节点；如果不等，说明我们需要的最大前缀坐标应该在中间节点的左边。根据这个情况去调整区间长度，最后就能得到最大前缀坐标，也能得到最长公共前缀</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            minLength = Math.min(minLength, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = minLength;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l + <span class="number">1</span>) / <span class="number">2</span> + l;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(mid, strs)) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCommonPrefix</span><span class="params">(<span class="type">int</span> length, String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str0</span> <span class="operator">=</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc151-反转字符串中的单词（MD）">lc151. 反转字符串中的单词（MD）</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><hr><p>首先要说明的是，原题中还追加了一个进阶要求：使用空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的原地算法完成这道题。实际上，Java语言因为 String 的不可变性，所以不可能实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的空间复杂度，以下给出的代码的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>对于这道题，我们很明显能想到一类数据结构 栈/队列，栈先进先出，队列后进后出，能满足我们反转单词的要求。我们只需要提取出单词，然后存进这类数据结构，然后再把这些单词弹出来，就能实现反转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; s.charAt(l) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; s.charAt(r) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(l);</span><br><span class="line">            <span class="keyword">if</span> (word.length() != <span class="number">0</span> &amp;&amp; c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                deq.offerFirst(word.toString());</span><br><span class="line">                word.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deq.offerFirst(word.toString());</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, deq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc12-整数转罗马数字（MD）&quot;&gt;lc12. 整数转罗马数字（MD）&lt;/h2&gt;
&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/co</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>买了吉他</title>
    <link href="https://yonagi04.github.io/posts/2024/9c2c791cdc8b/"/>
    <id>https://yonagi04.github.io/posts/2024/9c2c791cdc8b/</id>
    <published>2024-03-30T08:54:39.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>前天，花了高价，买下了grx40 + cr mini，花了1600+</p><p>然后昨天，吉他到货了</p><p>第一感觉——好重</p><p>第二感觉——我的手指是废物</p><p>然后就是中午到下午练了两个小时的右手空弦，晚上练左手制音+右手拨弦</p><p>闹麻了，想象中的永远比实际的简单得多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前天，花了高价，买下了grx40 + cr mini，花了1600+&lt;/p&gt;
&lt;p&gt;然后昨天，吉他到货了&lt;/p&gt;
&lt;p&gt;第一感觉——好重&lt;/p&gt;
&lt;p&gt;第二感觉——我的手指是废物&lt;/p&gt;
&lt;p&gt;然后就是中午到下午练了两个小时的右手空弦，晚上练左手制音+右手拨弦&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日常" scheme="https://yonagi04.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.3.29</title>
    <link href="https://yonagi04.github.io/posts/2024/7365259c77bd/"/>
    <id>https://yonagi04.github.io/posts/2024/7365259c77bd/</id>
    <published>2024-03-29T17:25:41.000Z</published>
    <updated>2025-05-18T09:07:25.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc380-O-1-时间插入、删除和获取随机元素（MD）">lc380. O(1) 时间插入、删除和获取随机元素（MD）</h2><p>实现<code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回。</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>最多调用 <code>insert</code>、<code>remove</code> 和 <code>getRandom</code> 函数 <code>2 * 10^5</code> 次</li><li>在调用 <code>getRandom</code> 方法时，数据结构中 <strong>至少存在一个</strong> 元素。</li></ul><hr><p>其实这道题，唯一的难点就是在于，怎么获取一个随机数</p><p>元素的存储和查重很容易想到用什么集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer, Integer&gt; indices;</span><br><span class="line">    Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        indices = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (indices.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        nums.add(val);</span><br><span class="line">        indices.put(val, idx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!indices.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> indices.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        nums.set(idx, last);</span><br><span class="line">        indices.put(last, idx);</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        indices.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIdx</span> <span class="operator">=</span> random.nextInt(nums.size());</span><br><span class="line">        <span class="keyword">return</span> nums.get(randomIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><h2 id="lc238-除自身以外数组的乘积（MD）">lc238. 除自身以外数组的乘积（MD）</h2><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 **不要使用除法，**且在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li></ul><hr><p>第一感觉, 类似于前缀和的前缀积. 但是如果真的那么想, 那么只会和正解相去甚远, 最后根本没法ac</p><p>所以这道题肯定不是简简单单的用一个数组算前缀乘积</p><p>正解如下: 类似于双指针的思想+前缀乘积</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] l = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        l[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        r[nums.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            l[i] = l[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i] = r[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res[i] = l[i] * r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc134-加油站-MD">lc134. 加油站(MD)</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 10^4</code></li></ul><hr><p>贪心 + 简单的模拟, 没有特别难的地方</p><p>可能最大的难处在于如何判断除了第一个之外其他索引是否为起始索引, 我们可以从最后索引开始倒推, 推出来最少油量 &gt; 0 就是起始索引</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            curSum += rest;</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; min) &#123;</span><br><span class="line">                min = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gas.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            min += rest;</span><br><span class="line">            <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(我今天做这道题的时候把min的初值设置成了 Integer.MIN_VALUE, 结果半天a不出来, 调了半天也没发现是这里出了问题, 最后还是看了以前做出来的题解代码才发现这里有问题)</p><hr><h2 id="lc13-罗马数字转整数-EZ">lc13. 罗马数字转整数(EZ)</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>('I', 'V', 'X', 'L', 'C', 'D', 'M')</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。</li></ul><hr><p>我相当早的时候就a出来这道题了, 大一上学期的时候, 还没学数据结构与算法. 贴一下那时候的题解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preNum</span> <span class="operator">=</span> getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span><span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我感觉这个题解, 就算给现在的我, 一时间也搞不明白在写什么</p><p>这道题没那么复杂, 就是个简单模拟, 从最后一位开始倒推模拟即可</p><p>适合新手入门的模拟题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">4</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">9</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">40</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">50</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">90</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">400</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">500</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                    res += <span class="number">900</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">1000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单易懂, 3岁小孩看了都会写</p><hr><h2 id="lc42-接雨水-HD">lc42. 接雨水(HD)</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>0 &lt;= height[i] &lt;= 10^5</code></li></ul><hr><p>本栏目开设以来碰到的第一个hard题, 也是最简单的hard题, 也是面试中最常见的hard题. 简单到什么程度? 思维上完全没有深度, 就是纯纯双指针; 码量也很少, 熟悉的人完全可以直接默写出来.个人感觉这道题不应该评为hard, 最多就mid, 甚至部分mid题的思维深度都比这道题要深</p><p>上面说了解法了, 双指针, 直接给代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[l]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[r]);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                ans += leftMax - height[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单, 十五分钟不到就能a出来, 最菜hard题非本题莫属</p><p>当然, 对双指针不熟悉的人, 这道题应该就是名副其实的hard题了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lc380-O-1-时间插入、删除和获取随机元素（MD）&quot;&gt;lc380. O(1) 时间插入、删除和获取随机元素（MD）&lt;/h2&gt;
&lt;p&gt;实现&lt;code&gt;RandomizedSet&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RandomizedSe</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 24.3.28</title>
    <link href="https://yonagi04.github.io/posts/2024/7753445c1ab0/"/>
    <id>https://yonagi04.github.io/posts/2024/7753445c1ab0/</id>
    <published>2024-03-28T10:35:20.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lc80-删除有序数组中的重复项-II（MD）">lc80. 删除有序数组中的重复项 II（MD）</h2><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 已按升序排列</li></ul><hr><p>双指针法，同元素只能重复出现两次，那么就把两个指针最开始之间的距离设置成2</p><p>之后按照双指针法推</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>, r = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l - <span class="number">2</span>] != nums[r]) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc121-买卖股票的最佳时机（EZ）">lc121. 买卖股票的最佳时机（EZ）</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><hr><p>类似于贪心，但不太像</p><p>leetcode给的tag是dp，但这道题根本没必要上dp，但是之后这道题的一个变种就需要用dp了</p><p>类似于贪心的思路</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, minNum = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minNum) &#123;</span><br><span class="line">                minNum = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; (prices[i] - minNum)) &#123;</span><br><span class="line">                res = prices[i] - minNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc122-买卖股票的最佳时机-II（MD）">lc122. 买卖股票的最佳时机 II（MD）</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><hr><p>还是老样子，贪心</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res += Math.max(prices[i + <span class="number">1</span>] - prices[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc55-跳跃游戏（MD）">lc55. 跳跃游戏（MD）</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><hr><p>还是贪心，三回了</p><p>主要是看跳跃的可达范围能不能覆盖到最后一个下标</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">            cover = Math.max(cover, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="lc274-H指数（MD）">lc274. H指数（MD）</h2><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p><p>根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且 <strong>至少</strong> 有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code> 有多种可能的值，<strong><code>h</code> 指数</strong> 是其中最大的那个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [1,3,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == citations.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= citations[i] &lt;= 1000</code></li></ul><p>这道题很久没做过了，第一时间碰到这题还懵了一下</p><p>思路：先排序，然后从后往前遍历。具体内容看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> citations.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt; res) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第一篇刷题日记，现在刷题日记已经成为本站固定栏目</summary>
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="刷题日记" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://yonagi04.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java集合知识总结（下）</title>
    <link href="https://yonagi04.github.io/posts/2024/792ccee97572/"/>
    <id>https://yonagi04.github.io/posts/2024/792ccee97572/</id>
    <published>2024-03-26T19:14:31.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide, 地址: <a href="https://javaguide.cn/java/collection/java-collection-questions-02.html">https://javaguide.cn/java/collection/java-collection-questions-02.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>Map</h1><h2 id="HashMap"><code>HashMap</code></h2><p><code>HashMap</code> 主要用于存储键值对, 它基于哈希表的 Map 接口实现, 是常用的 Java 集合之一, 是非线程安全的</p><p><code>HashMap</code> 可以存储 null 的 key 和 value, 但 null 作为键只能有一个, 作为值可以有多个</p><p>JDK1.8之前 <code>HashMap</code> 是由数组+链表组成的(拉链法, 数组是本体, 链表解决哈希冲突)</p><p>JDK1.8之后, 当链表长度大于等于阈值 (默认为 8) 时, 会将链表转化为红黑树, 以减少搜索时间 (将链表转化为红黑树之前会判断, 如果当前数组的长度小于64, 那么会先进行数组扩容, 而不是转换为红黑树)</p><p><code>HashMap</code> 的默认初始化大小为16. 之后每次扩容, 容量变为原来的 2 倍. 并且 <code>HashMap</code>  总是使用 2 的幂作为哈希表的大小</p><h3 id="底层数据结构">底层数据结构</h3><h4 id="JDK1-8之前">JDK1.8之前</h4><p>JDK1.8之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用, 也就是链表散列 (拉链法)</p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理之后得到 hash值, 通过 <code>hash(KEY) % n</code> 判断当前元素存放的位置, 如果当前位置存在元素的话, 判断该元素和要存入元素的 hash 值以及 key 值是否相等, 相等的话直接覆盖, 不等的话就用链表解决哈希冲突</p><p>所谓扰动函数也就是 HashMap 的 Hash 方法, 使用扰动函数是为了防止一些实现比较差的 hashCode() 方法得到的哈希值发生碰撞</p><p>JDK1.8的 hash 方法源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK1-8之后">JDK1.8之后</h4><p>当链表长度大于等于阈值 (默认为 8) 时, 默认会先执行 <code>treeifyBin()</code> 方法, 这个方法会根据 HashMap 数组的长度决定是否转换为红黑树, 只有当数组长度大于等于 64 的情况下, 才会执行转换红黑树操作, 以减少搜索时间, 否则就只会执行 <code>resize()</code> 方法对数组扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>loadFactor 负载因子</li></ul><p>loadFactor 负载因子也就是控制数组存放数据的疏密程度, loadFactor越趋近于 1 , 那么数组中存放的数据就越多, 也就越密, 链表的长度也就越长; loadFactor越趋近于0, 数组中存放的数据越少, 也就是越稀疏</p><p><strong>loadFactor太大会导致查找效率变低, 太小会导致利用率低, 存放的元素会很分散. loadFactor的默认值为0.75f.</strong></p><p>假设给定的默认的容量为16, 负载因子为 0.75, 当容器中元素数量超过 16 * 0.75 = 12 时就需要进行扩容, 而这个过程涉及到rehash, 复制数据等操作, 非常消耗性能</p><ul><li>threshold</li></ul><p>threshold = capacity * loadFactor, 也就是当threshold &lt; Size 时, 就需要对数组进行扩容. 我刚刚提到的这个例子就是 size 大于 threshold 时需要扩容的一个情况</p><h3 id="源码分析">源码分析</h3><h4 id="构造方法">构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 默认构造函数。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">       <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面四个构造方法中均初始化了负载因子, 但是由于HashMap中没有类似于Capacity的字段, 即使制定了初始化容量 initialCapacity, 也只能通过 tableSizeFor() 方法扩容到与 initialCapacity 最接近的 2 的整数幂次方大小, 然后暂时赋给 threshold, 后续通过 resize() 方法将 threshold 复制给 newCap.</p></blockquote><h4 id="put-方法">put 方法</h4><p>HashMap 只提供了一个 put 方法用于添加元素, putVal 为 put 实际调用的方法, 不提供给用户使用</p><p>对 putVal 的分析</p><ol><li>如果定位到的数组位置没有元素就直接插入</li><li>如果定位到的数组位置有元素就和要插入的 key 比较, 如果 key 是相同的那就直接覆盖, 如果不等那就判断 p 是否是一个 树节点, 如果是 那就调用 <code>e = ((TreeNode&lt;K, V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加进去, 如果不是就遍历链表插入元素</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法">get 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resize-方法">resize 方法</h4><p>进行扩容, 会伴随着一次 rehash, 并且会遍历 HashMap 中的所有元素, 是非常耗时的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span></span><br><span class="line">    <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 只有一个节点，直接计算元素新的位置即可</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span></span><br><span class="line">                    <span class="comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-和-Hashtable-的区别">HashMap 和 Hashtable 的区别</h3><ul><li><strong>线程安全</strong> : <code>HashMap</code> 是非线程安全的, <code>Hashtable</code> 是线程安全的, 因为 <code>Hashtable</code> 内部的方法都经过 <code>synchronized</code> 修饰.</li><li><strong>效率</strong> : <code>HashMap</code> 的效率比 <code>Hashtable</code> 效率更高</li><li><strong>对 Null key 和 Null value 的支持</strong> : <code>HashMap</code> 可以存储 null 的 key 或 value, 但 null 作为 key 只能存一个, 作为 value 可以存多个. Hashtable 不允许有 null值 或 null 键</li><li><strong>初始容量大小和每次扩容大小</strong> : 1. 创建时如果不指定初始容量, <code>Hashtable</code> 的初始容量为 11, 之后每次扩容容量都会变成原来的 2n + 1, 而 <code>HashMap</code> 的初始容量为 16, 之后每次扩容都会变成原来的两倍 2. 创建时如果给定了容量初始值, 那么 <code>Hashtable</code> 会直接使用给定的大小, 而 <code>HashMap</code> 会将其扩容为 2 的 幂次方大小 (<code>HashMap</code> 的 <code>tableSizeFor</code> 方法保证)</li><li><strong>底层数据结构</strong> : JDK1.8之后的 <code>HashMap</code> 解决哈希冲突时有较大的变化, 前面已经有提及</li></ul><h3 id="HashMap-和-HashSet-的区别">HashMap 和 HashSet 的区别</h3><table><thead><tr><th><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td>实现了 <code>Map</code> 接口</td><td>实现了 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>存储对象</td></tr><tr><td>调用 <code>put()</code> 方法向 map 中添加元素</td><td>调用 <code>add()</code> 方法向 set 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键计算 <code>Hashcode</code></td><td><code>HashSet</code> 使用成员对象计算 <code>hashCode</code> 值, 对于两个对象来说 <code>hashCode</code> 值可能相等, 所以 <code>equal()</code> 方法用来判断对象的相等性</td></tr></tbody></table><h3 id="HashMap-和-TreeMap-的区别">HashMap 和 TreeMap 的区别</h3><p><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> , 但是 <code>TreeMap</code> 还实现了 <code>NavigableMap</code> 和 <code>SortedMap</code> 接口</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力. 默认是按 key 的升序排序, 不过我们也可以指定排序的比较器</p><h3 id="HashSet-如何检查重复">HashSet 如何检查重复</h3><p>在JDK1.8中, <code>HashSet</code> 的 <code>add()</code> 方法只是简单的调用了 <code>HashMap</code> 的 <code>put()</code> 方法, 并且判断了一下返回值以确保是否有重复元素</p><p>也就是说, 在 JDK1.8 中, 实际上无论<code>HashSet</code>中是否已经存在了某元素, <code>HashSet</code>都会直接插入, 只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素</p><h3 id="为什么HashMap的长度是-2-的整数次幂">为什么HashMap的长度是 2 的整数次幂?</h3><p>这里我觉得 Java Guide解释得不好, 有点让人摸不着头脑了. 我重新写一下</p><p>为什么HashMap的长度是 2 的整数次幂? 理由有两个: <strong>加快哈希运算</strong> , <strong>减少哈希冲突</strong></p><ol><li><strong>加快哈希运算</strong></li></ol><p>前面已经提及, 计算Key存储的位置需要用 <code>hash(KEY) % n</code> , 但是 % 运算的速度太慢了, 所以我们可以用 &amp; 运算代替 % 运算, 为了保证 &amp; 的计算结果等于 % 的结果需要把 长度 length 减一</p><p>也就是, <code>hash(KEY) % n == hash(KEY) &amp; (length - 1)</code></p><p>因为hash值需要用到低位信息, 那么根据 &amp; 运算, &amp;运算的另一个数最好低位全部为1, 所以取长度为 2 的整数次幂</p><p>还有一个有趣的事实: 因为扩容为 2 的倍数, 根据 hash 桶的计算方法, 元素哈希值不变而通过 % 计算的方式会因为 length 的变化导致计算出来的 hash 桶的位置不断变化. 数据一致在漂移, 影响性能</p><ol start="2"><li><strong>减少哈希冲突</strong></li></ol><p>当长度为偶数时, length - 1 为奇数, 奇数的二进制最后一位为 1, 这就保证了 hash &amp; (length - 1) 的最后一位可能是 0, 也可能是 1(这取决于hash值), 这样就保证了散列的均匀性</p><h3 id="HashMap-多线程操作导致死锁问题">HashMap 多线程操作导致死锁问题</h3><p>JDK1.8之前的版本的 <code>HashMap</code> 在多线程环境下可能出现死锁. 这是因为当一个桶位需要由多个元素进行扩容时, 多个线程同时对链表进行操作, 头插法可能导致链表中的节点指向错误的位置, 从而形成环形链表, 进而导致查询元素的操作变成死循环无法结束</p><p>在JDK1.8及其之后的版本中, <code>HashMap</code> 采用了尾插法而不是头插法以避免链表倒置, 使得插入的节点永远放在链表的末尾, 避免了链表出现环形结构. 但是在并发环境下仍然不推荐使用 <code>HashMap</code> , 推荐使用 <code>ConcurrentHashMap</code></p><h3 id="HashMap为什么是线程不安全的">HashMap为什么是线程不安全的</h3><p>前面已经提及了JDK1.7及其之前的版本下 <code>HashMap</code> 的多线程操作可能导致死锁. 实际上, 在 JDK1.8及其之后的版本下, 在多线程环境中, <code>HashMap</code> 在扩容时可能会导致数据丢失的问题</p><p>JDK1.8之后, 在 <code>HashMap</code> 中, 多个键值对可能会被分配到一个桶中, 并以链表或红黑树的形式存储. 多个线程对 <code>HashMap</code> 的 <code>put</code> 操作 会导致数据不安全, 具体来说会导致数据覆盖</p><p>例如:</p><ol><li>两个线程1, 2同时进行 put 操作, 并且发生了哈希冲突</li><li>不同的线程在不同的时间片下获得了CPU执行的机会, 线程1执行完哈希冲突判断之后, 由于时间片被耗尽所以线程被挂起, 线程2开始执行, 先完成了插入操作</li><li>随后, 线程1获得了时间片, 根据上一个时间片中哈希冲突的判断, 线程1会直接覆盖掉线程2插入的数据</li></ol><h3 id="HashMap的遍历方式有什么">HashMap的遍历方式有什么</h3><p>HashMap <strong>遍历从大的方向来说, 可分为以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）;</li><li>Streams API 遍历（JDK 1.8+）</li></ol><p>但每种类型下又有不同的实现方式, 因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历</li></ol><p>接下来我们来看每种遍历方式的具体实现代码</p><ol><li>迭代器 EntrySet</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>迭代器 KeySet</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>ForEach EntrySet</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>ForEach KeySet</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Lambda</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Streams API单线程</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>Streams API多线程</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在性能表现上, entrySet的性能表现最好, 接下来是 单线程stream, 然后是keySet, 最差的是lambda</p><p>其中, 对于 多线程stream, 当不存在阻塞时, 多线程stream的性能是最差的</p><p>但是当存在阻塞时, 多线程stream的性能是最好的</p><h2 id="ConcurrentHashMap"><code>ConcurrentHashMap</code></h2><h3 id="ConcurrentHashMap-1-7">ConcurrentHashMap 1.7</h3><p>Java7 中的 ConcurrentHashMap 有很多个 Segment 组合, 每个 Segment 又类似于一个 HashMap 的结构, 但是 Segment 的个数一旦初始化之后就不能改变, 默认 Segment 的个数为 16 个</p><h4 id="初始化">初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造中调用了有参构造, 传入了三个参数的默认值, 他们的值是:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认并发级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>有参构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java7 中 ConcurrentHashMap的初始化:</p><ol><li>参数校验</li><li>校验并发参数 <code>concurrencyLevel</code> 大小, 如果大于最大值, 重置为最大值. 无参构造默认值为 16</li><li>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 2 的幂次方值, 作为初始化容量大小, 默认为 16</li><li>记录 <code>segmentShift</code> 偏移量, 这个值为 “容量 = 2 ^ N” 中的 N. 默认为 32 - sshift = 28</li><li>记录 <code>segmentMask</code> , 默认为 ssize - 1 = 15</li><li>初始化 <code>segment[0]</code> , 默认大小为2, 负载因子0.75, 扩容阈值为 2 * 0.75 = 1.5.</li></ol><h4 id="put">put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put的流程:</p><ol><li><p>计算要 put 的 key 的位置, 获取指定位置的 <code>Segment</code> .</p></li><li><p>如果指定位置的 <code>Segment</code> 为空, 则初始化这个 <code>Segment</code></p><p><strong>初始化 Segment 流程</strong> :</p><ol><li>检查计算得到的位置的 <code>Segment</code> 是否为 null.</li><li>为 null 继续初始化, 使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组</li><li>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null</li><li>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code>.</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Segment</code> 继承了 <code>ReentrantLock</code> , 所以 <code>Segment</code> 内部可以很方便的获取锁, put 流程就用到了这个功能</p><ol><li><p><code>tryLock()</code> 获取锁, 获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取</p></li><li><p>计算 put 的数据要放入的 index 位置, 然后获取这个位置上的 <code>HashEntry</code></p></li><li><p>遍历 put 新元素, 为什么要遍历？因为这里获取的 <code>HashEntry</code> 可能是一个空元素, 也可能是链表已存在, 所以要区别对待</p><p>如果这个位置上的 <strong><code>HashEntry</code> 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值, 小于最大容量, <strong>进行扩容</strong></li><li>直接头插法插入</li></ol><p>如果这个位置上的 <strong><code>HashEntry</code> 存在</strong>：</p><ol><li>判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致. 一致则替换值</li><li>不一致, 获取链表下一个节点, 直到发现相同进行值替换, 或者链表表里完毕没有相同的<ol><li>如果当前容量大于扩容阀值, 小于最大容量, <strong>进行扩容</strong></li><li>直接链表头插法插入</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在, 替换后返回旧值, 否则返回 null</p></li></ol><p>这里面的第一步中的 <code>scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 <code>HashEntry</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容rehash">扩容rehash</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="literal">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get">get</h4><ol><li>计算 key 的存放位置</li><li>遍历指定位置查找相同 key 的 value值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentHashMap-1-8">ConcurrentHashMap 1.8</h3><p>Java8之后, ConcurrentHashMap 不再是原来的 Segment 数组 + HashEntry 数组 + 链表, 而是 Node 数组 + 链表/红黑树</p><h4 id="初始化-2">初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap的初始化是通过 <strong>自旋</strong> 和 <strong>CAS</strong> 操作完成的</p><h4 id="put-2">put</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程:</p><ol><li>根据 key 计算出 hashcode</li><li>判断是否需要初始化</li><li>根据当前 key 定位到的 Node, 如果为空表示当前位置可以写入数据, 利用 CAS 尝试写入, 失败则自旋保证成功</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code> , 则需要扩容</li><li>如果都不满足, 则利用 synchronized 写入数据</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法</li></ol><h4 id="get-2">get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程:</p><ol><li>根据hash值计算位置</li><li>查找到指定位置, 如果头节点就是要找的节点, 直接返回它的 value</li><li>如果头节点hash值小于0, 说明正在扩容或者是红黑树, 直接查找</li><li>如果是链表, 遍历查找</li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别">ConcurrentHashMap 和 Hashtable 的区别</h3><ul><li><strong>底层数据结构</strong> : JDK1.7的 ConcurrentHashMap底层采用 Segment数组 + 链表实现, JDK1.8之后采用的数据结构和 HashMap一样, 数组 + 链表 / 红黑树. <code>Hashtable</code> 采用的数据结构是数组 + 链表</li><li><strong>实现线程安全的方式</strong> :<ul><li>JDK1.7时, ConcurrentHashMap对整个桶数组进行了分割分段, 每一把锁只锁容器其中一部分数据, 多线程访问容器中不同数据段的数据, 就不会存在锁竞争, 提高并发访问率</li><li>在JDK1.8之后, ConcurrentHashMap摒弃了 Segment 的概念, 直接用 Node 数组 + 链表 + 红黑树的数据结构来实现, 并发控制用 synchronized 和 CAS 来操作</li><li>Hashtable 使用 synchronized 来保证线程安全, 效率非常底下. 当一个线程访问同步方法时, 其他线程也访问同步方法, 可能会进入阻塞或轮询状态, 如果使用 put 添加元素, 另一个线程不能使用put 添加元素, 也不能使用 get, 竞争会越来越激烈效率越低</li></ul></li></ul><h3 id="ConcurrentHashMap-为什么-key-和-value-不能为-null">ConcurrentHashMap 为什么 key 和 value 不能为 null</h3><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性. null 是一个特殊的值, 表示没有对象或没有引用. 如果你用 null 作为键, 那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中, 还是根本没有这个键. 同样, 如果你用 null 作为值, 那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的, 还是因为找不到对应的键而返回的</p><h3 id="ConcurrentHashMap-能保证复合操作的原子性吗">ConcurrentHashMap 能保证复合操作的原子性吗</h3><p>答案是不能</p><p>复合操作是指多个基本操作(如 put, get, remove, containsKey 等) 组合的操作</p><p>如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性?</p><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作, 如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等. 这些方法都可以接受一个函数作为参数, 根据给定的 key 和 value 来计算一个新的 value, 并且将其更新到 map 中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide, 地址: &lt;a href=&quot;https://javaguide.cn/java/collection/java-collection-questions-02.html&quot;&gt;https://javaguide.cn/ja</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于买吉他</title>
    <link href="https://yonagi04.github.io/posts/2024/a47b76726784/"/>
    <id>https://yonagi04.github.io/posts/2024/a47b76726784/</id>
    <published>2024-03-24T19:00:54.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>我昨天前天都说了，我想买吉他，电吉他</p><p>昨天看到一套不错的视频教程——如果我能把这套视频教程完全看完的话——不间断——那我就买一把</p><p>差不多就这样吧，虽然手里有点现钱，勉强够买一把，但我真的很担心自己不能学好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我昨天前天都说了，我想买吉他，电吉他&lt;/p&gt;
&lt;p&gt;昨天看到一套不错的视频教程——如果我能把这套视频教程完全看完的话——不间断——那我就买一把&lt;/p&gt;
&lt;p&gt;差不多就这样吧，虽然手里有点现钱，勉强够买一把，但我真的很担心自己不能学好&lt;/p&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于ACM的一点往事</title>
    <link href="https://yonagi04.github.io/posts/2024/248a3c61f59e/"/>
    <id>https://yonagi04.github.io/posts/2024/248a3c61f59e/</id>
    <published>2024-03-23T12:50:35.000Z</published>
    <updated>2025-05-18T09:07:25.409Z</updated>
    
    <content type="html"><![CDATA[<p>今天是我校ACM校赛暨ACM队选拔赛的日子。比赛刚刚开始，我大概看了下题，感觉题目还不错（），难的题也有，简单的题也有。（不过简单题不是特别多就是了，听他们说今年出题要出得难一点，所以难题真的不是难得一星半点）</p><p>这次校赛罕见地请了不少外校的佬过来这边打，什么华工，华师，广工……都有人过来。我去年打这个比赛的时候倒是只面向校内，今年好像是peipei（后面会讲到他是谁）去广东acm群里面发了邀请，然后就有不少佬过来打了</p><p>借着这个机会，讲讲我以前还在acm队的时候，不完美的经历。</p><hr><p>我刚说到我去年也参加了acm选拔赛，不过我的实力并没有那么强大，进去多半是靠祖上积德，或者是我那天运气特好，靠我自己的运气进去的。我预选赛a了4道题，但排位比较一般，但也到了能进正赛的程度，但是到了正赛只a了两道题出来（看看，这都能进了，这开题数放acm区域赛连铜末都摸不到，这就是acm弱校）。打完之后，我的第一感想：”完蛋了，肯定进不了了“，第二感想：”不进acm咋办？我现在做的一切工作都是为了进acm，咋办啊咋办“，第三感想：”算了，不进就不进，不进的话继续卷C++，卷技术栈……“</p><p>可能是运气比较好，然后就进了acm。进了acm之后呢，就是训练。我印象里第一次去计算机楼510实验室（也就是acm队集训基地）训练，我还忘记带电脑（是的，我没有在队群里面问基地有没有电脑，结果就是我人到了基地，但是发现基地没有好用的电脑，全部都是清华同方的老爷机，最后就是我自己又跑回宿舍，紧急拿了电脑又跑回基地训练）我最开始是去的512，打开512的房间门，小声地问了一个师兄，”额请问这里是acm集训队吗“</p><p>”acm集训队啊，在隔壁“</p><p>（后来我才知道，512其实是老acm集训队的基地，和现在的510是连在一起的；后来512变成acm队教练的研究生的实验室了，所以我们acm队就只能挤在510这个小房间训练+住宿）</p><p>然后我就去了隔壁510，当时房间里面有和我同年级的同样被入选进来的新人（比如uzi），还有一些老人（比如明哥，鑫哥，屈姐，翀哥，peipei）。出于害怕别人看我电脑（对，我一直有这样的习惯，害怕别人看我电脑。因为不选靠墙的座位，我就会一直感觉别人盯着我的电脑屏幕看，然后我就压力山大！所以我在图书馆或者自习室都喜欢选靠墙的座位，就是不想让别人看到我的电脑屏幕。），我选了最后一排的座位。清掉了已经退役的师兄or师姐的“遗产”之后，我就开始训练了。当时给的训练题我还记得不少都是从poj上面拉下来的，但是有很多题我都不会做（现在看来那些题真的超级超级基础，哪怕不打acm的计算机学生都应该要会的，题目基本上就是dfs or bfs or 模拟（甚至还不是那种插橡树树针那种大模拟，就是那种最简单的小模拟），结果我居然一道都没a出来。挫败感十足啊！</p><p>然后就是日常训练了，差不多就是鑫哥明哥每周会拉一个专项题单下来，然后我们就自己训练。前面说到了，我们学校是弱校，所以我们学校也没有那种很系统的训练体系，也就是有一个acm队可以让大家一起抱团训练然后去打比赛而已。我们学校的训练大概就是，每周拉一份题单下来，然后自己做，最后会有一份题解，你可以参照题解自己补题。（听说这个训练方法最开始还是没有的，还是鸿爷（我校近年来唯一一个金牌爷）在当acm队长的时候搞的一个训练制度，目的是不想让新人走歪路）但是我却动了歪心思。有些题不会做？直接Bing找题解答案；题解看不懂？cv大法（事实证明cv大法对acmer真的很不好，或者是不仅仅是acmer，对于所有要吃计算机这碗饭的学生，刷算法题的时候cv都不是一个好选择）。这就导致了我虽然水得一批，但我的ac数和补题数特别高。高到什么程度？全级第一</p><p>对，你没看错，全级第一的ac数+补题数，所以之后组队肯定有什么大佬来找我了。果不其然，之后uzi就来找我了，拉我进他的队伍（当时他已经拉了另一个大佬翰爷），我想着这不是能抱大腿嘛，外加我这个人不擅长拒绝他人，外加我总不能说我这些题都是cv的，我其实特别水吧？索性就加了</p><p>加了之后呢，就是训练了。不过翰爷从来没来过acm基地，他都是在自己宿舍打代码。然后就是平静的训练日常，刷题、补题、打比赛，日复一日</p><p>再过段时间，acm广东省赛就要来了，我们学校自然会参赛。然后就是校内选拔赛（校内选拔赛还没透露出我是个水货的事实，只不过透露了我电脑是台老爷机的事实），但最后有惊无险，我们的队伍在选拔赛中排位第5，成功拿到了出线名额，参加广东省省赛。</p><p>之后就是省赛报名，我们苦于起一个合适的队名。当时uzi参考鸿爷的金牌队伍名，”负负得正“，起了个类似的名字，“虚虚得实”，大概就是从实平面扩展到复平面的意思。我当时还是傻逼管人痴，硬是想着把队名和国内某管人团体的某成员扯上关系（好他妈傻逼啊），不过”虚虚得实“这个队名我们都很满意，最后也就定下来了，一直到后来打区域赛都是用的这个队名</p><p>之后就是一直训练……你说训练那么久，我的水平有提高吗？当然有，至少我开题速度明显提升了，基本的一些题我也能开出来了。当时打cf，1200~1300分左右的题我不到10分钟就能开出来（你别笑，我进队的时候是23年3月，训练一个月就有这样的水平，这对于一个最开始连dfsbfs都不会的新手来讲，进步已经很快了）但是因为我训练方法有问题，外加我的底子差，而且走的野路子（我最开始甚至没有买过任何一本好用的算法竞赛入门书，也没买过线上课程，买课都是后来的事情了），所以我提升速度明显不及两个队友，这也为我后面选择退队而不是选择转队伍埋下了祸根。</p><p>然后运气很不好，比赛前两个星期我得了甲流。得了甲流自然很糟糕，因为发烧，所以我没法训练。当时两个队友在基地vp前年的广东省省赛，我只能在健康驿站和他们远程vp，不过我还是a了两题出来，然后昏昏沉沉又睡下去了。</p><p>之后就是去深圳打比赛了，我没想到我第一次去深圳居然是以这种形式去，但是我们不是去深圳大学，是去的深圳技术大学，在深圳坪山，离南山远得很。坪山和我想象中的深圳完全不一样，不过深圳技术大学真的很大很漂亮，饭也特好吃。我们是比赛当天才去的深圳，早上六点钟就要起床去坐车了，有一说一，这是我第一次和这么多认识的人聚众出游。同年级的就我和uzi、翰爷、ke爷，其他的都是师兄，比如鸿爷，靖爷，鑫哥，明哥，peipei，原神，还有其他我不是很熟的师兄，一起坐车去深圳。坐到了深圳，我感觉有点头晕，但是马上就要开始打比赛了。签到，领物资，换衣服（对，比赛是有给一套衣服的，比赛的时候作为选手身份要传上去，不过我打完比赛之后就没穿过），然后就是等体育馆开门进场准备比赛。比赛过程我就不讲了，只记得我们好像开了5题出来，我自己开了一道签到题，然后和uzi开了一道贪心。当时差一点点就能开出6题了，但是时间不够，翰爷没时间开，最后我们就只a了5道题出来。最后我们拿了省赛铜，这作为acm开端真是再好不过了，毕竟我们都还是新人，还没训练多久，省赛铜已经不错了</p><p>然后就是蓝桥杯，可惜我去年没报成，所以就没参加。不过我这个时候就有点懈怠了，一面在训练写cf题，一面在搞qq机器人（我对于Linux系统的认识也是从这个时候开始建立起来的，Linux的各种指令都是借着搭机器人的机会学的，所以有时候实践大于理论）。所以这个阶段提升就很慢，刷题量也不算多。这时候我买了AcWing的算法基础课，开始系统地学习各种算法（对，此前我基本上就是纯板刷cf和刷洛谷题，题目刷多了就就知道怎么写题了）</p><p>然后就是放暑假了。暑假的话，按照惯例，牛客每年都有暑假训练，用于acmer的区域赛模拟。这个时候我和两个队友的实力差距就体现出来了。我多次开题却无法成功开出来，uzi也多次找到我，私信和我说如果没法把题开出来的话，就尽快去补题。但是我发现就算我再拼命地补题，短时间内也很难达到区域赛所需要的技术水平（暑假训练难度基本和区域赛趋同），我当时就产生了一个想法，”打完了这个赛季，就退役吧，我真的打不下去了“，虽然按照网络上流传的acm技能树，我的算法水平已经达到了在区域赛可以勉强打铜的水平，但是和队友的实力差距仍然很大（队友的算法水平，按照acm技能树的话是可以冲银的），且当时我已经极度内耗，外加没有和队友交流我的情况，导致了后面没有打完区域赛我就选择了退出acm</p><p>之后就是ccpc的网络赛了，这直接决定了我们学校能不能在ccpc比赛中出线，能拿到多少名额。这次我的电脑又又又开始卡了，我和队友的实力差距也暴露无遗</p><p>打完ccpc网络赛，之后就是icpc网络赛了。打比赛之前肯定要先vp，但是我知道我的水平不行，频繁开题失败，写测试样例也写不动。之后呢，就是uzi找到了我，提出更换队友的要求，他觉得我现在的水平没法去打区域赛，认为我可以先沉淀一年，大三了再去打。我理解他的想法，因为我们学校的出线名额一直很少，尤其是今年要打线下赛，名额只会只减不增，而且21级（也就是鑫哥明哥peipei那届）打acm，是直接打铁的，如果这次他们还拿不到牌子，打acm拿不到牌子就直接退役是一件很惨的事情。所以今年区域赛名额很明显是直接倾向于给21级，22级的名额几乎少到没有。但是我直接提出了退出acm队，我知道我自己已经打不动了，再这样下去不仅不会再有进步，反而是继续拉别人后腿。uzi尽力劝阻我退队，毕竟我们这一届打acm的人真的不多，算上我，还在训练的就三个人（对，就是我+uzi+翰爷），其他的都已经变成挂名摆子了。但是我很清楚如果我明年打区域赛，拿不到牌子，会有什么样的后果。我最后还是毅然决然的退队，写了退队申请，离开了acm，也结束了我短暂的acm生涯</p><p>之后呢？之后区域赛，我还是关注着学校的acm队的发挥。今年没有队伍拿到金牌，不过21级的师兄队都拿了银，”虚虚得实“也收获了铜牌；我呢，我收获了后端技术栈，自学了计算机专业课，我们都有光明的未来</p><p>不过之后还有蓝桥杯省赛，硬要说的话，可能今年蓝桥杯省赛就是我竞赛生涯最后的一场比赛了吧，就算能拿省一我也不会继续打了</p><hr><p>你是不是觉得我这个人很傻逼？进了队，那么快又退掉，而且还是在区域赛之前退掉的。我也知道，我这么做确实很傻逼。我很对不起鑫哥明哥，毕竟他们是很看重”虚虚得实“这支队伍的，也很看重我本人（一方面是他们对我也是很照顾，另一方面是，前面提到了，我训练的ac数很高，按照惯例来讲，ac数高的人要么天赋异禀，要么就是足够勤奋，以后的成绩不算差，算个好苗子，不过我是个特例）；我也对不起鸿爷，我最开始决定来打acm，还是在知乎上面偶然刷到了鸿爷的退役小作文，看了鸿爷的小作文，我才毅然决定来打acm。我印象里鸿爷的退役小作文里面有这样几句话</p><blockquote><p>吾辈生如蝼蚁,却亦有鸿鹄之志。<br>就算是一个无名小卒，也想为自己的梦想拼尽全力。</p></blockquote><blockquote><p>最后希望我的学弟学妹们，能延续下去这一份光辉，不说你需要疯狂的去追赶（除非你真的有这时间和这份疯狂的热情），至少能做到你们能够做到最好的，取的自己满意的成果。</p></blockquote><p>鸿爷的退役小作文，我看了很多次。最有感触的就是这两句话</p><p>后来再见到鸿爷，就是在acm校赛了，当时鸿爷就坐在我旁边，隔着一个座位（对，可惜我当时不认识他，我只知道他是acm队的师兄，但不知道他就是鸿爷），他坐在一边写题解，我在另一边坐牢。</p><p>然后再见到，就是在去深圳了。我们acm队合了影，现在还放在计算机院的acm队宣传公文里面（挺丢人的）</p><p>再次见到就是在51节了，51节我留在acm队训练，鸿爷在acm基地打雀魂。鸿爷要走之前，找鑫哥聊了几句，因为我就坐在鑫哥附近，所以鸿爷也注意到了我</p><p>”你是大一的？“ ”啊是的“ ”我看看你是群里的谁“</p><p>然后我就打开qq，打开acm队群，把我的id指给了他看</p><p>“哦原来是你。51节还留在这边训练啊，你加油”</p><p>后来我在我校的新生群（当时也不算新生群了，都是22级的老东西）里面水群，鸿爷偶尔看到我在水群，就会说“快去加训”（当然我知道这是开玩笑，加训这个词在acm圈子里面是经常说的，没有什么训斥的含义），之前有一次我在群里和群友聊gal，我说大学了没地方打，鸿爷这时候正好上线了，回复我 ”可以在基地打啊，想怎么打就怎么打😋“，当然我没那个胆量就是了</p><p>后来暑期实习，听说他被腾讯wxg挂了，有点吃惊，毕竟以他的技术和算法能力，腾讯没有理由能挂他，不知道他现在去哪家公司了，希望有个好去处吧</p><p>（24.7.6 updates: 鸿爷后来去了广州一家相当有名的自动驾驶公司，做自动驾驶去了，也算是有了个好去处吧，当然他自己对这个结果并不是很满意）</p><p>然后就是对不起uzi和翰爷。毕竟是我自己突然退队，外加我的水平拉跨，直接拉了他们后腿，还有就是我的电脑真的太垃圾了，之前打比赛频繁卡机，从某种程度上也影响了队伍的心态</p><p>唉，本来只想随便写一点的，没想到一写就是一个小时，4000+个字，就这样吧</p><p>一段不算完美的经历</p><hr><p>这一段是24号补的，昨天打完了校赛，我也拿到了榜单</p><p>今年新生的情况不容乐观</p><p>今年虽然有oi爷，但不多（其实去年也就ke爷一个oi爷），但是今年的情况特殊，今年真正意义上的老队伍只能凑个一支，剩下的全部都是新生队了，不过就算我留在acm，这种情况也无法逆转，毕竟以我的实力，我也带不了新生。这样看来估计下半年区域赛不好打</p><p>祝我校acm年年向好吧</p>]]></content>
    
    
    <summary type="html">过去的一点往事</summary>
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>吉他随想</title>
    <link href="https://yonagi04.github.io/posts/2024/01bde3fa69d2/"/>
    <id>https://yonagi04.github.io/posts/2024/01bde3fa69d2/</id>
    <published>2024-03-23T12:35:15.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>我昨天不是说了嘛，我想买把电吉他</p><p>不过肯定不会向家里要钱，一方面是我这人好面子，不好意思因为这点原因就要钱；另一方面我觉得自己是成年人，也不能再随便伸手要钱了</p><p>我想买Ibanez的grx40，听说这把琴便宜又很不错，适合新手入门。昨天我稍微看了一点点点点点点的电吉他教学，但是感觉这玩意好难啊，難しい！</p><p>乐理什么的，根本学不明白啦！</p><p>今天直接从zlibrary下载了小林克己的电吉他教材……根本看不懂（因为五线谱的原因），搞不明白五线谱是什么玩意，难！（后来我在b站看了一些评论，证明我的想法是没错的，小林克己的教材对于新手来讲就是纯地狱模式，不适合初学者）</p><p>乔伊重金属节奏1和主奏1我也下载了，目前看着还行</p><p>但是我没有钱，我买不起吉他，所以只能——虚空按弦，虚空拿拨片，虚空拨弦</p><p>得拼命找实习了，有了钱就能买</p><p>但是买了就能学好吗，我一直有这个疑问。如果买了但是学不好，只能当个摆设，那岂不是一千多块钱直接浪费掉，最后只能去闲鱼卖二手？</p><p>不知道，反正等我有钱了再说吧。我本来想打算工作了再买吉他——或者其他的什么什么乐器，但是听说工作了没时间——那就只能大学时候搞这些了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我昨天不是说了嘛，我想买把电吉他&lt;/p&gt;
&lt;p&gt;不过肯定不会向家里要钱，一方面是我这人好面子，不好意思因为这点原因就要钱；另一方面我觉得自己是成年人，也不能再随便伸手要钱了&lt;/p&gt;
&lt;p&gt;我想买Ibanez的grx40，听说这把琴便宜又很不错，适合新手入门。昨天我稍微看了一</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="日常" scheme="https://yonagi04.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：扫雷</title>
    <link href="https://yonagi04.github.io/posts/2024/a87ad503de16/"/>
    <id>https://yonagi04.github.io/posts/2024/a87ad503de16/</id>
    <published>2024-03-23T11:13:33.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：第十三届蓝桥杯软件赛省赛 B组</p><blockquote><p>在一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 列 的方格图中有些位置有地雷, 另外一些位置为空</p><p>请为每个空位置标一个整数, 表示周围八个相邻的方格中有多少个地雷</p><p><strong>输入</strong> : 输入的第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></p><p>第 2 行 到 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数, 相邻整数之间用一个空格分隔. 如果对应的整数为 0 , 表示这一格没有地雷, 如果对应的整数为 1 , 表示这一格有地雷</p><p>其中, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \le n, m \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></p><p><strong>输出</strong> : 输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行, 每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数, 相邻整数之间用空格分隔</p><p>对于没有地雷的方格, 输出这格周围的地雷数量. 对于有地雷的方格, 输出 9</p><p><strong>Input Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">0 1 0 0</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 9 2 1</span><br><span class="line">9 4 9 2</span><br><span class="line">1 3 9 2</span><br></pre></td></tr></table></figure></blockquote><p>简单的爆搜题, 非常简单, 而且其实这道题就是爆搜的模板题. 有系统练习过的话直接秒ac</p><p>蓝桥杯居然还把它的难度评为 “困难” , 有点搞笑了</p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn], res[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> xx = x + dx[i];</span><br><span class="line"><span class="type">int</span> yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (xx &gt;= <span class="number">1</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= m &amp;&amp; a[xx][yy] == <span class="number">1</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">res[i][j] = <span class="built_in">dfs</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源：第十三届蓝桥杯软件赛省赛 B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/Math</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：统计子矩阵</title>
    <link href="https://yonagi04.github.io/posts/2024/231a1bcbb3c4/"/>
    <id>https://yonagi04.github.io/posts/2024/231a1bcbb3c4/</id>
    <published>2024-03-22T09:37:42.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：第十三届蓝桥杯软件赛省赛 B组</p><blockquote><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> , 请统计有多少个子矩阵 (最小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, 最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>) 满足子矩阵中所有数的和不超过给定的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> ?</p><p><strong>输入</strong> : 第一行包括三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N, M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></p><p>之后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个整数, 代表矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></p><p><strong>输出</strong> : 一个整数代表答案</p><p><strong>Input Sample</strong> :</p><blockquote><p>3 4 10</p><p>1 2 3 4</p><p>5 6 7 8</p><p>9 10 11 12</p></blockquote><p><strong>Output Sample</strong> :</p><blockquote><p>19</p></blockquote></blockquote><p>思路: 前缀和 + 滑动窗口</p><p>我最开始考虑的方法是 二维前缀和, 因为这是一个二维矩阵, 但后续发现用二维前缀和会tle. 看了题解思路才知道其实可以变成一位前缀和, 只统计纵向的前缀和, 然后用滑动窗口找到合适的区间</p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">a[i][j] += a[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">1</span>; r &lt;= m; r++) &#123;</span><br><span class="line">sum += a[j][r] - a[i - <span class="number">1</span>][r];</span><br><span class="line"><span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">sum -= a[j][l] - a[i - <span class="number">1</span>][l];</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">ans += r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源：第十三届蓝桥杯软件赛省赛 B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/Mat</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：修建灌木</title>
    <link href="https://yonagi04.github.io/posts/2024/2ac3d180cf13/"/>
    <id>https://yonagi04.github.io/posts/2024/2ac3d180cf13/</id>
    <published>2024-03-21T10:41:15.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源: 第十三届蓝桥杯大赛软件赛省赛B组</p><blockquote><p>爱丽丝要完成修建灌木的工作</p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 棵灌木整齐的从左向右排成一排, 爱丽丝在每天傍晚会修建一棵灌木, 让灌木的高度变为 0 厘米. 修建灌木的顺序是从最左侧的灌木开始, 每天向右修建一棵灌木. 当修建了最右侧的灌木之后, 她会调转方向, 下一天开始向左修剪灌木. 直到修剪了最左的灌木后再次调转方向. 然后如此循环往复</p><p>灌木每天从早到晚都会长高 1 厘米, 而其余时间不会长高. 在第一天的早晨, 所有灌木的高度都是 0 厘米. 爱丽丝想知道每棵灌木最高长到多高</p><p><strong>输入</strong> : 一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> , 含义如题面所述</p><p><strong>输出</strong> : 输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行, 每行一个整数, 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行表示从左到右第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 棵灌木最高能长到多高</p><p><strong>Input Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure></blockquote><p>简单的模拟题, 手动模拟一下即可</p><p>当一次被剪之后, 下次被剪之前的高度就是最大高度了. 所以我们只需要根据这棵灌木更靠近左边 (1) 还是更靠近右边 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>) 就能计算出最大高度</p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(n - i, i - <span class="number">1</span>) * <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源: 第十三届蓝桥杯大赛软件赛省赛B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;爱丽丝要完成修建灌木的工作&lt;/p&gt;
&lt;p&gt;有 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java集合知识总结（上）</title>
    <link href="https://yonagi04.github.io/posts/2024/a42cd1994a08/"/>
    <id>https://yonagi04.github.io/posts/2024/a42cd1994a08/</id>
    <published>2024-03-19T20:30:03.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide, 地址: <a href="https://javaguide.cn/java/collection/java-collection-questions-01.html">https://javaguide.cn/java/collection/java-collection-questions-01.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4 </a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>Java 集合概述</h1><p>Java 集合, 也叫做容器, 主要是由两大类接口派生而来, 一个是 <code>Collection</code> 接口, 主要用于存放单一元素; 另一个是 <code>Map</code> 接口, 主要用于存放键值对. 对于 <code>Collection</code> , 下面又有三个主要的子接口 <code>List</code> , <code>Set</code> 和 <code>Queue</code></p><p>Java 集合框架如下所示:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/javacollection.png" alt=""></p><h1>说说 List, Set, Queue, Map 四者的区别?</h1><ul><li><code>List</code> : 存储的元素是有序的可重复的</li><li><code>Set</code> : 存储的元素是不可重复的</li><li><code>Queue</code> : 队列. 存储元素是可重复的, 有序的</li><li><code>Map</code> : 使用键值对（key-value）存储, 类似于数学上的函数 y=f(x), “x” 代表 key, “y” 代表 value, key 是无序的, 不可重复的, value 是无序的, 可重复的, 每个键最多映射到一个值</li></ul><h1>List</h1><h2 id="ArrayList"><code>ArrayList</code></h2><p><code>ArrayList</code> 是  <code>Object[]</code> 数组, 底层是数组数列, 相当于动态数组. 与 Java 的数组相比, 它的容量可以动态增长. 在添加大量元素前, 应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量. 这可以减少递增式再分配的数量</p><p>如果你有学过C++的话, 你应该会意识到 <code>ArrayList</code> 和 C++ 中的 <code>Vector</code> 非常相似. <code>Vector</code> 也是动态数组, 也能动态增长.</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> , 实现了<code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口</p><ul><li><code>List</code> 表明它是一个列表, 支持添加, 删除, 查找等操作, 并且可以通过下标进行访问</li><li><code>RandomAccess</code> 表明实现这个接口的 <code>List</code> 是支持快速访问的. 在 <code>ArrayList</code> 中, 我们可以通过元素的下标来直接获取元素, 这就是快速访问</li><li><code>Cloneable</code> 表明它具有拷贝能力, 可以进行深拷贝和浅拷贝操作</li><li><code>Serializable</code> 表明它可以序列化, 也就是可以把对象转换为字节流进行存储或进行网络传输</li></ul><p><code>ArrayList</code> 可以存储任何类型的对象, 但是不建议存储 <code>null</code> 值, 因为一方面 <code>null</code> 值没有意义, 另一方面存储 <code>null</code> 值可能会导致空指针异常</p><h3 id="ArrayList-和-LinkedList-的区别"><code>ArrayList</code> 和 <code>LinkedList</code> 的区别?</h3><ul><li><strong>线程安全</strong> : <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的, 也就是不保证线程安全</li><li><strong>底层数据结构</strong> : <code>ArrayList</code> 底层使用的是 <code>Object</code> 数组, <code>LinkedList</code> 底层使用的是双向链表</li><li><strong>插入与删除</strong> :<ul><li><code>ArrayList</code> 采用数组存储, 所以插入和删除元素受元素个数影响. 例如, 执行 <code>add(E e)</code> 方法时, <code>ArrayList</code> 会默认将元素插入到末尾, 时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> . 但是如果在指定位置插入 <code>add(int index, E e)</code> , 时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><code>LinkedList</code> 采用链表存储, 所以在头尾插入删除元素不受元素个数影响, 时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> . (如 <code>add(E e)</code> , <code>addFirst(E e)</code> , <code>addLast(E e)</code> , <code>removeFirst()</code> , <code>removeLast()</code>). 但是如果在指定位置插入或删除元素 (如 <code>add(int index, E e)</code> , <code>remove(Object o)</code> , <code>remove(int index)</code>) , 时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li><strong>快速随机访问</strong> : <code>LinkedList</code> 不支持快速随机访问</li><li><strong>内存占用</strong> : <code>ArrayList</code> 的内存浪费体现在 <code>ArrayList</code> 的末尾会预留空间, 而 <code>LinkedList</code> 的内存浪费体现在 <code>LinkedList</code> 的每个元素都要有一个前驱指针和一个后缀指针</li></ul><h3 id="ArrayList-核心源码"><code>ArrayList</code> 核心源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">    <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认无参构造函数</span></span><br><span class="line"><span class="comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">                    ? EMPTY_ELEMENTDATA</span><br><span class="line">                    : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                <span class="comment">// any size if not default element table</span></span><br><span class="line">                ? <span class="number">0</span></span><br><span class="line">                <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">                <span class="comment">// supposed to be at default size.</span></span><br><span class="line">                : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保内部容量达到指定的最小容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     * 返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     * 将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     * 返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList-扩容机制"><code>ArrayList</code> 扩容机制</h3><p>根据上面的源码, 我们可以确定的一个事实是: <strong>当以无参数构造方法构造一个新的 <code>ArrayList</code> 时, 实际上初始化赋值的是一个空数组, 只有插入一个新元素的时候, <code>ArrayList</code> 的容量才会扩容到10</strong></p><p><strong>初始扩容后, 容量一次扩张到10, 之后每次扩容都会将容量扩张到原来的1.5倍</strong></p><p>举个例子, 给一个空 <code>ArrayList</code> 添加一个元素, <code>ArrayList</code> 发生第一次扩容, 此时 <code>ArrayList</code> 的容量变为 10. 之后添加第2, 3, … 9, 10个元素, 都不会再扩容了. 直到添加第11个元素, 容量不足, <code>ArrayList</code> 自动扩容, 扩容到原来的 1.5 倍, 容量变为15. <strong>这里注意, 如果原来的容量是奇数, 那么原容量乘以1.5会出现小数, 实际上扩容会把小数位丢掉.</strong></p><p>(如果你有学过C++的话, 可以拿 <code>ArrayList</code> 的扩容机制和 <code>Vector</code> 的扩容机制做个对比, 总体来讲还是比较相似的)</p><p>在扩容之后, 根据上面的源码, 我们可知: 如果新容量大于 <code>MAX_ARRAY_SIZE</code> , 就会执行 <code>hugeCapacity()</code> 方法比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>, 如果 <code>minCapacity</code> 大于 <code>MAX_ARRAY_SIZE</code> , 那么新容量为 <code>Integer.MAX_VALUE</code> , 否则, 新容量大小为 <code>Integer.MAX_VALUE - 8</code></p><p>扩容的本质是新建一个更大的 <code>ArrayList</code> , 然后将老的 <code>ArrayList</code> 的元素拷贝到新的 <code>ArrayList</code> . 拷贝有两个方法: <code>Arrays.copyOf()</code> 和 <code>System.arraycopy()</code> . 根据上面的源码可知, <code>Arrays.copyOf()</code> 实际上调用了 <code>System.arraycopy()</code> . 但两者存在区别, <code>arraycopy()</code> 需要目标数组, 将原数组拷贝到目标数组(重新定义的数组或者原数组), 可以选择拷贝的起点和长度以及放到目标数组的位置. <code>copyOf()</code> 是新建一个数组, 拷贝完成以后返回新数组</p><h2 id="Vector"><code>Vector</code></h2><p>底层实现为<code>Object[]</code> 数组</p><h2 id="LinkedList"><code>LinkedList</code></h2><p>底层实现为双向链表</p><h3 id="LinkedList-插入删除的时间复杂度"><code>LinkedList</code> 插入删除的时间复杂度?</h3><ul><li>头部插入/删除, 尾部插入/删除: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>除了头尾部的插入/删除: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="LinkedList-为什么不能实现-RandomAccess"><code>LinkedList</code> 为什么不能实现 <code>RandomAccess</code> ?</h3><p><code>LinkedList</code> 的底层数据结构是链表, 而链表中元素的内存位置不一定是连续的, 只能依赖于指针进行定位, 所以不能实现 <code>RandomAccesss</code></p><h3 id="LinkedList-源码分析"><code>LinkedList</code> 源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 <code>LinkedList</code> 的类定义</p><p>由代码可知, <code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> , 实现了 <code>List</code> , <code>Deque</code> , <code>Cloneable</code> , <code>Serializable</code> 接口</p><ul><li><code>List</code> : 表明它是一个列表</li><li><code>Deque</code> : 继承自 <code>Queue</code> , 表明它具有双端插入/删除的特性</li><li><code>Cloneable</code> : 表明它具有拷贝能力, 可以进行深拷贝和浅拷贝操作</li><li><code>Serializable</code> : 表明它可以序列化, 也就是可以把对象转换为字节流进行存储或进行网络传输</li></ul><p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;<span class="comment">// 节点值</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 指向的下一个节点（后继节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向的前一个节点（前驱结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 <code>LinkedList</code> 的构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素使用 <code>add()</code> 方法. <code>add()</code> 方法有两个版本</p><ul><li><code>add(E e)</code> , 将元素添加到 <code>LinkedList</code> 的末尾, 时间复杂度为 <code>O(1)</code></li><li><code>add(int index, E e)</code> , 将元素添加到指定位置. 这需要先查找到对应位置, 然后再插入. 时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表指定位置插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 index 是不是链表尾部位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素节点插入到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 将最后一个元素赋值（引用传递）给节点 l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将 last 引用指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空</span></span><br><span class="line">    <span class="comment">// 如果 l 是null 意味着这是第一次添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定元素之前插入元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;断言 succ不为 null</span></span><br><span class="line">    <span class="comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化节点，并指明前驱和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将 succ 节点前驱引用 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// succ 节点前驱的后继引用指向新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取元素有三个函数, <code>getFirst()</code> , <code>getLast()</code> , <code>get(int index)</code></p><ul><li><code>getFirst()</code> : 获取链表的头节点元素, 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><code>getLast()</code> : 获取链表的尾节点元素, 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><code>get(int index)</code> : 获取指定位置元素, 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="comment">// 返回链表中对应下标的元素</span></span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心在于下面这一段源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定下标的非空节点</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言下标未越界</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 遍历，循环向后查找，直至 i == index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get(int index)</code> 和 <code>remove(int index)</code> 都调用了这个方法来获取指定位置的节点</p><p>删除元素有5个方法, <code>removeFirst()</code> , <code>removeLast()</code> , <code>remove(E e)</code> , <code>remove(int index)</code> , <code>clear()</code></p><ul><li><code>removeFirst()</code> : 删除头节点. 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><code>removeLast()</code> : 删除尾节点. 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li><code>remove(E e)</code> : 删除链表中首次出现的指定元素, 如果不存在就返回 false. 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><code>remove(int index)</code> : 删除链表中指定位置的元素. 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li><code>clear()</code> : 删除链表中全部元素. 时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除并返回链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除并返回链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为 null ,遍历链表找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心在于 <code>unlink()</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言 x 不为 null</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 获取当前节点（也就是待删除节点）的元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点为空，则说明当前节点是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表头指向当前节点的下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个节点为空，则说明当前节点是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表尾指向当前节点的前一个节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果下一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点元素置为 null，方便 GC 回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unlink()</code> 的逻辑如下</p><ol><li>首先获取待删除节点 x 的前驱和后继节点.</li><li>判断待删除结点是否为头结点或尾节点<ul><li>如果 x 是头节点, 则将 first 指向 x 的后继节点</li><li>如果 x 是尾节点, 则将 last 指向 x 的前驱节点</li><li>如果 x 不是头节点也不是尾节点, 则进行下一步操作</li></ul></li><li>将待删除节点的前驱节点的后继指向待删除节点的后继节点, 断开 x 和 x.prev 的连接</li><li>将待删除结点的后继节点的前驱指向待删除节点的前驱节点, 断开 x 和 x.next 的连接</li><li>将待删除节点 x 的元素置空, 修改链表长度</li></ol><p>关于遍历 <code>LinkedList</code> , 推荐使用 <code>for-each</code> 进行遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list;</span><br><span class="line">list.add(<span class="string">&quot;Yonagi&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LinkedList</code> 遍历的核心其实是它的迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点；</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nextIndex;</span><br><span class="line">    <span class="comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头到尾方向的迭代</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span></span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取下一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查在迭代过程中链表是否被修改过</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 指向当前节点</span></span><br><span class="line">    lastReturned = next;</span><br><span class="line">    <span class="comment">// 将 next 指向下一个节点</span></span><br><span class="line">    next = next.next;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾到头方向的迭代</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有前一个节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前一个节点</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否在迭代过程中链表被修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 如果没有前一个节点，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 将 lastReturned 和 next 指针指向上一个节点</span></span><br><span class="line">    lastReturned = next = (next == <span class="literal">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Set</h1><h2 id="Comparable-和-Comparator-的区别">Comparable 和 Comparator 的区别</h2><p><code>Comparable</code> 和 <code>Comparator</code> 接口都是 Java 中常见的用于排序的接口</p><ul><li><code>Comparable</code> 接口实际上是出自 <code>java.lang</code> 包, 它有一个 <code>compareTo(Object obj)</code> 方法用于排序</li><li><code>Comparator</code> 接口实际上出自 <code>java.util</code> 包, 它有一个 <code>compare(Object object1, Object object2)</code> 方法用于排序</li></ul><h2 id="无序性和不可重复性的含义是什么">无序性和不可重复性的含义是什么</h2><ul><li>无序性是指存储的数据在底层数组中排列的顺序并非是按照数组索引增加进行排序, 而是根据哈希值进行排序</li><li>不可重复性是指添加元素通过 <code>equals()</code> 判断时, 返回 false.</li></ul><h2 id="比较-HashSet-LinkedHashSet-TreeSet">比较 HashSet, LinkedHashSet, TreeSet</h2><ul><li><code>HashSet</code> , <code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是接口 <code>Set</code> 的实现类, 都能保证元素的不可重复性, 且能保证线程安全</li><li><code>HashSet</code> , <code>LinkedHashSet</code> 和 <code>TreeSet</code> 的区别在于底层数据结构的不同. <code>HashSet</code> 是底层是哈希表 (基于 <code>HashMap</code> ); <code>LinkedList</code> 的底层是链表和哈希表, 且元素插入取出满足FIFO; <code>TreeSet</code> 的底层是红黑树, 元素是有序的, 排序的方式有自然排序和定制排序</li><li>底层数据结构的不同又导致它们的应用场景不同. <code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景, <code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景, <code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1>Queue</h1><h2 id="Queue-和-Deque-的区别">Queue 和 Deque 的区别</h2><p><code>Queue</code> 是单端队列, 只能在一端插入元素, 在另一端删除元素</p><p><code>Queue</code> 实现了 <code>Collection</code> 的接口, 根据容量问题而导致操作失败处理的不同, 分为两类: 一类是操作失败后抛出异常, 一类是操作失败后返回特殊值</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队头</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队头元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>(说说我个人的喜好, 我个人更喜欢用返回特殊值类型的方法, 抛出异常的方法就我个人而言, 无论是写题还是写项目代码都很少用到)</p><p><code>Deque</code> 是双端队列, 在队头队尾都能插入删除</p><p><code>Deque</code> 实现了 <code>Queue</code> 的接口, 增加了在队头插入/队尾删除的方法. 和 <code>Queue</code> 通用, <code>Deque</code> 根据容量问题而导致操作失败处理的不同, 也分为两类: 一类是操作失败后抛出异常, 一类是操作失败后返回特殊值</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队头</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队头</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队头元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>实际上, <code>Deque</code> 还有 <code>push()</code> 和 <code>pop()</code> 方法, 用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-的区别">ArrayDeque 与 LinkedList 的区别</h2><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现, 而 <code>LinkedList</code> 是基于链表实现</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据, 而 <code>LinkedList</code> 支持</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 均摊后时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, <code>LinkedList</code> 虽不需要扩容, 但是每次插入数据时都需要申请新的空间, 均摊后性能更差</li></ul><h2 id="PriorityQueue"><code>PriorityQueue</code></h2><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现, 底层使用可变长的数组来存储元素</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉, 实现了在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度下插入和删除堆顶元素</li><li><code>PriorityQueue</code> 是非线程安全的, 且不支持存储 <code>NULL</code> 值和 <code>non-comparable</code> 对象</li><li><code>PriorityQueue</code> 默认是小根堆, 但是可以接收一个 <code>Comparator</code> 作为构造参数, 自定义元素优先级</li></ul><h2 id="BlockingQueue"><code>BlockingQueue</code></h2><p><code>BlockingQueue</code> 是一个接口, 继承自 <code>Queue</code> . <code>BlockingQueue</code> 阻塞的原因是当队列内没有元素的时候会一直阻塞, 直到有元素; 如果队列已满, 会等到队列有空间了再放入</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型</p><h3 id="BlockingQueue-的实现类有哪些">BlockingQueue 的实现类有哪些?</h3><ol><li><code>ArrayBlockingQueue</code> : 使用数组实现的有界阻塞队列. 创建时需要指定容量大小, 并且支持公平和非公平两种方式的锁访问机制</li><li><code>LinkedBlockingQueue</code> : 使用单向链表实现的可选有界阻塞队列, 在创建时可以指定容量, 如果不指定容量则默认为 <code>Integer.MAX_VALUE</code> . 和 <code>ArrayBlockingQueue</code> 一样, 支持公平和非公平两种方式的锁访问机制</li><li><code>PriorityBlockingQueue</code> : 支持优先级排序的无界阻塞队列. 元素必须支持 <code>comparable</code> 或者在构造时指定 <code>Comparator</code> . 不支持插入 <code>NULL</code> 值</li><li><code>SynchronousQueue</code> : 同步队列, 是一种不能存储元素的阻塞队列, 每个插入操作必须等待一个删除操作, 同理删除操作必须等待插入操作</li><li><code>DelayQueue</code> : 延迟队列, 里面的元素只有经过了指定的延迟时间, 才能出队</li></ol><h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue-的区别">ArrayBlockingQueue 和 LinkedBlockingQueue 的区别?</h3><ul><li><p><code>ArrayBlockingQueue</code> 基于数组实现; <code>LinkedBlockingQueue</code> 基于单向链表实现</p></li><li><p><code>ArrayBlockingQueue </code> 是有界的, 且创建时必须指定大小; <code>LinkedBlockingQueue</code> 是可选有界的, 创建时可以选择指定大小, 如果不指定则默认为 <code>Integer.MAX_VALUE</code></p></li><li><p><code>ArrayBlockingQueue</code> 的锁是没有分离的, 也就是生产和消费都用的同一个锁; <code>LinkedBlockingQueue</code> 的锁是分离的, 生产和消费各有一个锁, 避免了消费者线程和生产者线程的锁争夺</p></li><li><p><code>ArrayBlockingQueue</code> 需要提前分配内存, 而 <code>LinkedBlockingQueue </code> 则是插入元素时申请新的内存空间</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide, 地址: &lt;a href=&quot;https://javaguide.cn/java/collection/java-collection-questions-01.html&quot;&gt;https://javaguide.cn/ja</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：接龙数列</title>
    <link href="https://yonagi04.github.io/posts/2024/b6b07539d181/"/>
    <id>https://yonagi04.github.io/posts/2024/b6b07539d181/</id>
    <published>2024-03-19T13:28:52.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：第十四届蓝桥杯软件赛省赛 B组</p><blockquote><p>对于一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的整数数列: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , … , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">A_K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 我们称之为接龙数列当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的首位数字恰好等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的末尾数字 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">2 \le i \le K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>) . 例如, 12, 23, 35, 56, 61, 11是接龙数列, 12, 23, 34, 56 不受接龙数列, 因为 56 的首位数字不等于 34 的末位数字. 所有长度为 1 的整数数列都是接龙数列</p><p>现在给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的数列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1, A_2,...,A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 请你计算最少从中删除多少个数, 可以使得剩下的数列是接龙数列</p><p><strong>输入</strong> : 第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1, A_2, ... , A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>输出</strong> : 一个整数代表答案</p><p><strong>Input Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;5</span><br><span class="line">&gt;11 121 22 12 2023</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1</span><br></pre></td></tr></table></figure></blockquote><p>题目问最少删除多少个数, 我们可以逆转一下思维, 就是算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个数最多可以组成多长的接龙数列, 得到的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">N - len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span> 就是我们要的最少删除个数. 我们发现这其实就是最长上升子序列, 完全可以用 DP 来解决. 根据 DP 的知识我们可以知道, 最长上升子序列的状态转移方程应该是:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_{i, j} = max(f_{i, j}, f_{i - 1, j} + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> . 但是考虑到本题的数据范围 1e5 , 很明显我们不能直接用, 否则会tle. 必须得考虑优化</p><p>我们发现, 在这个接龙数列中, 我们只需要考虑数字的首位和末位, 其他的不用考虑. 那么我们只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\sim9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 十个数字就可以表示所有状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 结尾的接龙数列. 对于一个数可以看成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">i...j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 为首位, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 为末位) , 从上一个结尾为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的状态转移, 转移方程为</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[j] = max(f[j], f[i] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> res = INT_MAX, n, f[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">f[s.<span class="built_in">back</span>() - <span class="string">&#x27;0&#x27;</span>] = <span class="built_in">max</span>(f[s.<span class="built_in">back</span>() - <span class="string">&#x27;0&#x27;</span>], f[s.<span class="built_in">front</span>() - <span class="string">&#x27;0&#x27;</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">res = <span class="built_in">min</span>(res, n - f[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源：第十四届蓝桥杯软件赛省赛 B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个长度为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识总结（下）</title>
    <link href="https://yonagi04.github.io/posts/2024/bcd8edb78d7d/"/>
    <id>https://yonagi04.github.io/posts/2024/bcd8edb78d7d/</id>
    <published>2024-03-18T20:21:51.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide, 地址: <a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>异常</h1><p><strong>Java 异常类层次图概览</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/javathrowable.png" alt=""></p><h2 id="Exception-和-Error-有什么区别？">Exception 和 Error 有什么区别？</h2><p>在 Java 中， 所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类. <code>Throwable</code> 类有两个重要的子类:</p><ul><li><code>Exception</code> : 程序本身可以处理的异常, 可以通过 <code>catch</code> 来捕获. <code>Exception</code> 又分为 受检查异常和不受检查异常. 受检查异常是必须处理的异常, 不受检查异常可以不处理</li><li><code>Error</code> : 程序本身无法处理的异常, 不建议用 <code>catch</code> 来捕获. 常见的 <code>Error</code> 包括 Java虚拟机运行错误 <code>Virtual Machine Error</code> , 内存不足的错误 <code>OutOfMemoryError</code>……当这些异常发生的时候, 线程会自动终止</li></ul><h2 id="Checked-Exception-受检查异常-和-Unchecked-Exception-不受检查异常-有什么区别">Checked Exception(受检查异常) 和 Unchecked Exception(不受检查异常) 有什么区别?</h2><p>前面已经简单提及, 这里再补充一下:  Java 代码在编译阶段, 如果没有 <code>catch</code> 或 <code>throws</code> 关键字来处理 Checked Exception 的话, 就无法通过编译</p><p>除了 <code>RuntimeException</code> 及其子类外, 其他的 <code>Exception</code> 都是 Checked Exception</p><p>Unchecked Exception 也就是不受检查异常,  Java代码在编译阶段, 即使没有 <code>catch</code> 或 <code>throws</code> 关键字来处理 Unchecked Exception, 也能通过编译</p><h2 id="try-catch-finally-如何使用">try-catch-finally 如何使用?</h2><ul><li><p><code>try</code>块：用于捕获异常. 其后可接零个或多个 <code>catch</code> 块, 如果没有 <code>catch</code> 块, 则必须跟一个 <code>finally</code> 块</p></li><li><p><code>catch</code>块：用于处理 try 捕获到的异常</p></li><li><p><code>finally</code> 块：无论是否捕获或处理异常, <code>finally</code> 块里的语句都会被执行. 当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时, <code>finally</code> 语句块将在方法返回之前被执行</p></li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I will throw an Exception&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RunException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I catch the Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I will throw an Exception</span><br><span class="line">I catch the Exception</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure><p>⚠️<strong>特别注意!!! 千万不能在finally块中使用return！</strong> 当try 和 finally中都有 <code>return</code> 时, try 中的 <code>return</code> 会被忽略. 这是因为 try语句中的 <code>return</code> 返回值会保存在一个本地变量中, 如果执行了 finally中的 <code>return</code> , 这个本地变量就会变成 finally 中 <code>return</code> 的返回值了</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="finally-中的代码一定会被执行吗">finally 中的代码一定会被执行吗?</h2><p>答案是不一定</p><p>以下三种情况会导致 finally 中的代码不会被执行</p><ol><li><strong>关闭 Java 虚拟机</strong></li><li><strong>程序所在的线程死亡</strong></li><li><strong>关闭CPU</strong></li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I will throw an Exception&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I catch the Exception&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">1</span>); <span class="comment">// 注意, 这里终止掉了Java虚拟机</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I will throw an Exception</span><br><span class="line">I catch the Exception</span><br></pre></td></tr></table></figure><h2 id="如何用-try-with-resource-代替-try-catch-finally">如何用 <code>try-with-resource</code> 代替 <code>try-catch-finally</code> ?</h2><ol><li><strong>适用范围</strong> : 任何实现<code>java.lang.AutoCloseable</code> 或 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和finally块的执行顺序</strong> : 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>类似于 <code>InputStream</code> , <code>OutputStream</code> , <code>Scanner</code> , <code>PrintWriter</code> 等资源都需要我们调用 <code>close()</code> 方法来手动关闭</p><p>可以在 <code>try-with-resource</code> 的 try语句块中用分号分隔定义多个资源</p><h2 id="异常使用有哪些要注意的地方">异常使用有哪些要注意的地方?</h2><ul><li>不要把异常定义为静态变量, 因为这样会导致异常栈信息错乱. 正确的做法是每次要抛出一个异常的时候就 new 一个出来</li><li>抛出的异常信息一定要有意义</li><li>建议抛出更加具体的异常. 同理, 在异常处理的时候, 具体的异常放前面, 通用的异常放后面</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I will throw an Exception&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException re) &#123; <span class="comment">// 具体异常放前面</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Runtime Exception Catched&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// 通用异常放后面</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Exception catched&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果使用了日志 (例如log4j) 打印异常, 那么就不要再抛出异常, 或者说两者不应该存在于同一段代码中</li></ul><p>错误代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I will throw an Exception&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Runtime</span> Exception(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">log.error(<span class="string">&quot;Exception. System Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>泛型</h1><h2 id="什么是泛型-有什么用">什么是泛型? 有什么用?</h2><p><strong>Java 泛型</strong> 是 JDK5 引入的新特性, 使用泛型参数, 可以提高代码的可读性以及稳定性</p><p>编译器可以对泛型参数进行检测, 并且通过泛型参数指定传入的参数类型</p><h2 id="泛型的使用方式有哪几种">泛型的使用方式有哪几种?</h2><ol><li><strong>泛型类</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">114514</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>泛型接口</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口, 不指定类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口, 指定类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Yonagi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>泛型方法</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : array) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;%s&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">String[] stringArray = &#123;<span class="string">&quot;heng&quot;</span>, <span class="string">&quot;heng&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>&#125;;</span><br><span class="line">pringArray(intArray);</span><br><span class="line">pringArray(stringArray);</span><br></pre></td></tr></table></figure><h1>反射</h1><h2 id="反射的应用场景">反射的应用场景?</h2><p>动态代理的实现(基于反射)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的实现(基于反射)</p><h2 id="反射的优缺点">反射的优缺点?</h2><p><strong>优点</strong> : 提高代码的灵活性, 为框架的开箱即用提供了便利(Spring框架不少地方用了动态代理, 而动态代理本身是基于反射实现的)</p><p><strong>缺点</strong> : 性能偏差(但是影响不大), 反射带来的运行时分析类的能力, 也带来了安全问题, 例如它可以无视泛型参数的安全检查</p><h1>注解</h1><h2 id="注解是什么">注解是什么</h2><p><code>Annotation</code> (注解) 是Java5 开始引入的新特性, 主要用于修饰类, 方法, 变量, 提供某些信息供程序在编译或运行时使用</p><p>注解本质上是继承了 <code>Annotation</code> 的特殊接口:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.Method)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的解析方式有哪几种">注解的解析方式有哪几种?</h2><p>注解只有在解析之后才会生效</p><ul><li><strong>编译期直接扫描</strong> : 编译器在编译Java代码的时候扫描出对应的注解并处理, 例如某个方法使用@Override注解, 编译器在编译的时候就会检测当前方法是否重写了父类对应的方法</li><li><strong>运行期通过反射处理</strong> : 框架自带的注解一般都是通过反射来处理的</li></ul><h1>序列化和反序列化</h1><h2 id="什么是序列化和反序列化">什么是序列化和反序列化?</h2><ul><li><strong>序列化</strong> : 把数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong> : 通过序列化形成的二进制字节流转换成数据结构或对象的过程</li></ul><p>常见场景:</p><ul><li>对象进行网络传输, 发送方要进行序列化, 接收到对象后接收方要进行反序列化</li><li>将对象存储到文件要进行序列化, 将对象从文件读出要进行反序列化</li><li>将对象存储到数据库之前要进行序列化, 从数据库读取出来要用到反序列化</li><li>对象存储到内存之前要进行序列化, 从内存读取要进行反序列化</li></ul><h2 id="如果有些字段不想序列化怎么办">如果有些字段不想序列化怎么办</h2><p>对于不想序列化的变量, 可以使用 <code>transient</code> 关键字修饰</p><p><code>transient</code> 关键字的作用是: 阻止实例中那些用此关键字修饰的变量序列化, 当对象被反序列化时, 被 <code>transient</code> 修饰的变量值不会被持久化和恢复</p><ul><li><code>transient</code> 只能修饰变量, 不能修饰类和方法</li><li><code>transient</code> 修饰的变量, 在反序列化之后变量值会被置成默认值</li><li><code>static</code> 变量因为不属于任何对象, 所以有没有 <code>transient</code> 关键字修饰都不会被序列化</li></ul><h1>I/O</h1><h1>I/O流了解吗?</h1><p>I/O, 即 Input/Output. 数据输入到内存为输入, 反之输出到外部存储的过程称为输出. I/O流在 Java 中分为 输入流和输出流, 根据数据处理方式又分为字符流和字节流</p><ul><li><code>InputStream</code> / <code>Reader</code> : 所有输入流的基类, 前者是字节流, 后者是字符流</li><li><code>OutputStream</code> / <code>Reader</code> : 所有输出流的基类, 前者是字节流, 后者是字符流</li></ul><h2 id="I-O流为什么要分为字节流和字符流">I/O流为什么要分为字节流和字符流</h2><ul><li>字节流是由 Java 虚拟机将字节转换得到的, 这个过程比较耗时</li><li>如果不知道编码类型的话, 使用字节流容易出现乱码</li></ul><h2 id="有哪些常用的I-O模型">有哪些常用的I/O模型?</h2><p><strong>同步阻塞I/O, 异步I/O, 同步非阻塞I/O, I/O多路复用, 信号驱动I/O</strong></p><h2 id="Java-中常见的3种I-O模型">Java 中常见的3种I/O模型</h2><h3 id="BIO-Blocking-I-O">BIO(Blocking I/O)</h3><p><strong>BIO属于同步阻塞IO模型</strong></p><p>同步阻塞 IO 模型中, 应用程序发起 read 调用后, 会一直阻塞, 直到内核把数据拷贝到用户空间</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/bio.png" alt=""></p><h3 id="NIO-Non-blocking-I-O">NIO (Non-blocking I/O)</h3><p><strong>NIO属于I/O多路复用模型</strong></p><p>对于高负载, 高并发的网络应用程序, 应当使用 NIO</p><h3 id="AIO-Asynchronous-I-O">AIO(Asynchronous I/O)</h3><p><strong>AIO属于异步IO模型</strong></p><p>最后简单给一张图, 总结一下 Java 的三种I/O模型</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/iomodel.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide, 地址: &lt;a href=&quot;https://javaguide.cn/java/basis/java-basic-questions-03.html&quot;&gt;https://javaguide.cn/java/basis/j</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：子串简写</title>
    <link href="https://yonagi04.github.io/posts/2024/de8f6fc78b42/"/>
    <id>https://yonagi04.github.io/posts/2024/de8f6fc78b42/</id>
    <published>2024-03-18T19:17:55.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：第十四届蓝桥杯大赛软件赛省赛B组</p><blockquote><p>程序猿圈子里正流行一种很新的简写方法：对于一个字符串，只保留首位字符，将首位字符之间的所有字符用这部分的长度代替。例如internationalization简写成i18n，Kubernetes简写成K8s，Lanqiao简写成L5o等。</p><p>在本题中，我们规定长度大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的字符串都可以采用这种简写方法（长度小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的字符串不配使用这种缩写)</p><p>给定一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 和两个字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 请你计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 有多少个以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开头 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 结尾的子串可以采用这种缩写?</p><p><strong>输入</strong>: 第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></p><p>第二行包含一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 和两个字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>输出</strong>: 一个整数代表答案</p><p><strong>Input Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;4</span><br><span class="line">&gt;abababdb a b</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br></pre></td></tr></table></figure></blockquote><p>先说这道题的解题方法: 二分法or双指针, 两种方案的题解我都会给出来</p><p>首先先把字符串中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的下标单独用两个vector进行维护, 我们假设维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 下标的vector为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> , 维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> , 那么我们要遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> , 假设此时指向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 的指针为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> , 指向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 的指针为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> , 我们要在这个循环内部用双指针或者二分法来查找到使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">j - i+ 1 = K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 值</p><p>下面给出题解代码, 共两个方案, 但核心思路都是一样的. 请注重思考, 不要无脑cv</p><p><strong>方案1: 双指针法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">char</span> c1, c2;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == c1) &#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == c2) &#123;</span><br><span class="line">b.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; b.<span class="built_in">size</span>() &amp;&amp; b[j] - a[i] + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">res += (b.<span class="built_in">size</span>() - j);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2: 二分法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">char</span> c1, c2;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == c1) &#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == c2) &#123;</span><br><span class="line">b.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (b[mid] - a[i] + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[mid] - a[i] + <span class="number">1</span> == k) &#123;</span><br><span class="line">res += (b.<span class="built_in">size</span>() - mid);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源：第十四届蓝桥杯大赛软件赛省赛B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程序猿圈子里正流行一种很新的简写方法：对于一个字符串，只保留首位字符，将首位字符之间的所有字符用这部分的长度代替。例如internationalization简写成i18n，Kubernet</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>吐槽垃圾专业的课程安排</title>
    <link href="https://yonagi04.github.io/posts/2024/e634be30403b/"/>
    <id>https://yonagi04.github.io/posts/2024/e634be30403b/</id>
    <published>2024-03-18T08:44:45.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>吐槽一下这个垃圾学校的课表安排，呸，应该是我们这个垃圾专业的课表安排</p><p>我真的不理解为什么要把概率论放到大二下学期才学。众所周知，概率论这玩意，贼几把吃高数，你高数学得好呢，概率论轻轻松松；要是高数学不好，哈哈那你概率论也纯寄。我真的不明白为什么要把概率论放大二下才学，为什么不大二上就直接学了。我知道我们这个垃圾专业大二上要学复变函数论，也算数学课，学院为了防止我们一学期上两大门数学，贴心地把概率论安排到了后面。</p><p>**我操死你的🐎！**过了他妈整整一年才开这课，我高数都快忘完了！</p><p>我高数好歹也是满绩点的！</p><p>别说什么“哎呀大学生，平时没认真学，都是考前临考冲刺，时间长了忘了很正常“，说这逼话的绝对没读过书。我他妈高中时候天天读书，我读到高二下学期，高一上学期学的三角函数我都能给忘了怎么算，高三一轮复习的时候写三角题写得一塌糊涂，跟你麻痹是不是大学生是不是考前临考冲刺有几把关系，就是这他妈傻逼学院安排课表安排得不合理。我知道学了复变是为了现在的信号与系统，现在学概率论是为了下学期大三上的通信原理，但你他妈不能这么来吧？昨天写概率论的题，一堆二重积分给我算破防了，以前这些题真的纯有手就行，乱杀；现在好了，都忘光了，是被乱杀了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;吐槽一下这个垃圾学校的课表安排，呸，应该是我们这个垃圾专业的课表安排&lt;/p&gt;
&lt;p&gt;我真的不理解为什么要把概率论放到大二下学期才学。众所周知，概率论这玩意，贼几把吃高数，你高数学得好呢，概率论轻轻松松；要是高数学不好，哈哈那你概率论也纯寄。我真的不明白为什么要把概率论放大二</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：岛屿个数</title>
    <link href="https://yonagi04.github.io/posts/2024/f4ba61ef9860/"/>
    <id>https://yonagi04.github.io/posts/2024/f4ba61ef9860/</id>
    <published>2024-03-17T20:51:49.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源: 第十四届蓝桥杯软件赛省赛 B组</p><blockquote><p>小蓝得到了一副大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> × <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的格子地图，可以将其视作一个只包含字符 ‘0’（代表海水）和 ‘1’（代表陆地）的二维数组，地图之外可以视作全部是海水， 每个岛屿由在上/下/左/右四个方向上相邻的 ‘1’ 相连接而形成。 在岛屿 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 所占据的格子中，如果可以从中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个不同的格子，使得 他们的坐标能够组成一个这样的排列：(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>),(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>), . . . ,(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{k−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">y_{k−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>)，其中 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>k</mi></mrow><annotation encoding="application/x-tex">x_{i+1}\mod k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>k</mi></mrow><annotation encoding="application/x-tex">y_{i+1} \mod k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>) 是由 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) 通过上/下/左/右移动一次得来的 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 ≤ i ≤ k − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)， 此时这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个格子就构成了一个 “环”。如果另一个岛屿 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 所占据的格子全部位于 这个 “环” 内部，此时我们将岛屿 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 视作是岛屿 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子岛屿。若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子 岛屿，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 又是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的子岛屿，那 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子岛屿。 请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。</p><p><strong>输入</strong>: 输入包含多组数据</p><p>第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> , 代表测试的组数</p><p>接下来输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据。对于每组数据，第一行包含两个用空格分隔的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 表示地图大小；接下来输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个字符，字符只可能是 ‘0’ 或 ‘1’。</p><p><strong>输出</strong>: 对于每组数据，输出一行，包含一个整数表示答案。</p><p><strong>Input Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 5</span><br><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">10101</span><br><span class="line">10001</span><br><span class="line">11111</span><br><span class="line">5 6</span><br><span class="line">111111</span><br><span class="line">100001</span><br><span class="line">010101</span><br><span class="line">100001</span><br><span class="line">111111</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure></blockquote><p>第一感觉是, 和力扣某道题非常相似, 力扣也有一道类似的题, 不过力扣题不用考虑环形岛的情况, 这里把链接贴一下: <a href="https://leetcode.cn/problems/number-of-islands/description/">https://leetcode.cn/problems/number-of-islands/description/</a>, 力扣题的难度是Mid, 这道题如果放力扣应该能算是Hard了吧 (笑)</p><p>其实和之前讲过的飞机降落一样, 都是用搜索, 只不过这次不是深搜了, 是用的广搜</p><p>一个岛屿是否被包围住, 主要看它能不能接触到最外围. 如果能, 那就不被包围, 如果不能, 那就被包围了, judge函数就是做这个判断的. 这个地方要注意, 这里能不能接触到外围, 除了上下左右四个方向之外, 还要考虑左上左下右上右下其他四个方向, 共计八个方向. 但是bfs函数(就是单看块是否连通的情况)只要考虑上下左右, 特别注意</p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> t[maxn][maxn], st[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123; i, j &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = que.<span class="built_in">front</span>().first, y = que.<span class="built_in">front</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> || x == n || y == <span class="number">1</span> || y == m) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (st[xx][yy] || g[xx][yy] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">que.<span class="built_in">push</span>(&#123; xx, yy &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> x = que.<span class="built_in">front</span>().first, y = que.<span class="built_in">front</span>().second;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (t[x][y]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">t[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (t[xx][yy] || xx &lt; <span class="number">1</span> || xx &gt; n || yy &lt; <span class="number">1</span> || yy &gt; m || g[xx][yy] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">que.<span class="built_in">push</span>(&#123;xx, yy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!t[i][j] &amp;&amp; g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">bfs</span>(i, j);</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">judge</span>(i, j)) &#123;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源: 第十四届蓝桥杯软件赛省赛 B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小蓝得到了一副大小为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/M</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>狠狠吐槽Edge浏览器！</title>
    <link href="https://yonagi04.github.io/posts/2024/8b0cfb360dee/"/>
    <id>https://yonagi04.github.io/posts/2024/8b0cfb360dee/</id>
    <published>2024-03-17T15:34:10.000Z</published>
    <updated>2025-05-18T09:07:25.413Z</updated>
    
    <content type="html"><![CDATA[<p>我不得不吐槽一下这垃圾的Edge浏览器了！</p><p>我自认为本站的动画优化得还是很不错的，直到我打开了我电脑尘封已久的Edge浏览器，打开了本站</p><p>你麻痹卡成什么逼样了，我操死你的🐎！</p><p>个人目测帧数不超过30，肉眼可见的卡</p><p>我不清楚是不是因为我同时开了Chrome和Edge导致的，但是我打开Chrome浏览器，打开本站，丝毫不卡，动画效果如同德芙一般丝滑</p><p>我就明白了——他妈的Edge这玩意就是个垃圾！亏我以前一直用Edge！</p><p>我最开始没法忍受Edge是因为Edge这玩意他妈的贼几把吃内存——当然我知道这是Chromium浏览器——不对，应该是Electron系应用的通病，但是我用B站看1080p视频，看了几十分钟就固定给我抛一次Memory Error错误，这真的忍无可忍。我一开始以为是B站视频播放可能存在内存泄漏问题，拿开发者工具检测了内存占用也查不出来什么问题，直到我后来装了Chrome……我才意识到你麻痹原来是Edge的问题，Edge播放时间一长内存占用跟他妈坐电梯似的，直线上升根本不降的，Chrome虽然也吃内存，但内存表现上比Edge好到不知道哪里去了</p><p>Edge、微软，我操死你的🐎！</p><p>（哦对了，其实Edge还是有可以夸的点的，比如Edge的多端设备同步做的就很不错……后面忘了）（虽然找不到什么可以夸的点，但还是叠个甲先）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我不得不吐槽一下这垃圾的Edge浏览器了！&lt;/p&gt;
&lt;p&gt;我自认为本站的动画优化得还是很不错的，直到我打开了我电脑尘封已久的Edge浏览器，打开了本站&lt;/p&gt;
&lt;p&gt;你麻痹卡成什么逼样了，我操死你的🐎！&lt;/p&gt;
&lt;p&gt;个人目测帧数不超过30，肉眼可见的卡&lt;/p&gt;
&lt;p&gt;我</summary>
      
    
    
    
    <category term="生活" scheme="https://yonagi04.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活琐事" scheme="https://yonagi04.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    <category term="吐槽" scheme="https://yonagi04.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识总结（中）</title>
    <link href="https://yonagi04.github.io/posts/2024/36da1dc3a2f2/"/>
    <id>https://yonagi04.github.io/posts/2024/36da1dc3a2f2/</id>
    <published>2024-03-17T11:50:28.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide, 地址: <a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><h1>面向对象基础</h1><h2 id="对象相等和引用相等的区别">对象相等和引用相等的区别</h2><ul><li><p>对象相等一般比较的是存储在内存中的内容是否相等</p></li><li><p>引用相等一般比较的是内存地址是否相等</p></li></ul><p>请看代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;==&#x27;比较的是引用</span></span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br><span class="line"><span class="comment">// &#x27;equals()&#x27;比较的是对象</span></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str1.equals(str3));</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>从上面的代码输出结果可以看出：</p><ul><li><code>str1</code> 和 <code>str2</code> 不相等, 而 <code>str1</code> 和 <code>str3</code> 相等. 这是因为 <code>==</code> 运算符比较的是字符串的引用是否相等</li><li><code>str1</code>、 <code>str2</code>、<code>str3</code> 三者的内容都相等. 这是因为<code>equals</code> 方法比较的是字符串的内容, 即使这些字符串的对象引用不同, 只要它们的内容相等, 就认为它们是相等的</li></ul><h2 id="如果一个类没有声明构造方法-该程序能正确运行吗">如果一个类没有声明构造方法, 该程序能正确运行吗?</h2><p>答案是可以的</p><p>假如一个类没有声明构造方法, 它也会有一个默认的不带参数的构造方法. 但是请注意, <strong>如果我们声明了一个含参数的构造方法, 那么就不会自动生成默认不带参数构造方法了</strong></p><h2 id="构造函数有哪些特点-是否能被override">构造函数有哪些特点? 是否能被override?</h2><p>特点如下:</p><ul><li>名字和类名相同</li><li>没有返回值, 但这不意味着可以用 <code>void</code> 声明构造函数, 构造函数不能用 <code>void</code> 声明</li><li>不需要手动调用构造函数, 在生成类的对象的时候会自动调用</li></ul><p><strong>构造函数不能被override (重写), 但是可以被overload (重载)</strong></p><h2 id="面向对象三大特征">面向对象三大特征?</h2><h3 id="封装">封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承">继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><ol><li>子类拥有父类对象所有的属性和方法(包括私有的), 但是父类的私有属性和私有方法子类不能访问, 只是拥有而已</li><li>子类可以拥有自己的属性和方法</li><li>子类可以用自己的方式实现父类的方法</li></ol><h3 id="多态">多态</h3><p>多态, 顾名思义就是一个对象具有多种状态, 具体表现为父类的引用指向子类的实例</p><p><strong>多态的特点</strong></p><ul><li>对象类型和引用类型之间具有继承/实现的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法, 必须在程序运行期间才能确定</li><li>多态不能调用&quot;只在子类存在但父类不存在&quot;的方法</li><li>如果子类重写了父类的方法, 真正执行的是子类覆盖的方法, 如果子类没有重写父类方法, 那么执行的是父类的方法</li></ul><h2 id="接口和抽象类有什么共同点和区别">接口和抽象类有什么共同点和区别?</h2><p><strong>共同点</strong></p><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以有默认实现的方法( Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法)</li></ul><p><strong>区别</strong></p><ul><li>接口主要是对类的行为进行约束, 实现了某个接口就有了对应的行为, 抽象类主要用于代码复用, 强调的是所属关系</li><li>一个类只能继承一个类, 但是可以实现多个接口</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的, 不能被修改且必须有初始值, 而抽象类的成员变量默认default, 可在子类中重新定义, 也可被重新赋值</li></ul><h2 id="深拷贝和浅拷贝了解吗-什么是引用拷贝">深拷贝和浅拷贝了解吗? 什么是引用拷贝?</h2><ul><li><p><strong>浅拷贝</strong> : 浅拷贝会在堆上创建一个新对象(区别于引用拷贝的一点), 不过如果原对象内部的属性是引用类型的话, 浅拷贝会直接复制内部对象的引用地址, 也就是说拷贝对象和原对象共用同一个内部对象</p></li><li><p><strong>深拷贝</strong> : 深拷贝会完全复制整个对象, 包括这个对象所包含的内部对象</p></li><li><p><strong>引用拷贝</strong> : 两个不同的引用指向同一个对象</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&amp;deep-copy.png" alt=""></p><h1>Object</h1><h2 id="Object类的常见方法有哪些">Object类的常见方法有哪些?</h2><p>Object类是一种特殊的类, 是所有类的父类, 主要提供以下方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="和-equals-的区别">== 和 equals() 的区别</h2><p><code>==</code> 对于引用类型和基本类型的作用是不同的</p><ul><li>对于引用类型, <code>==</code> 比较的是内存地址</li><li>对于基本类型, <code>==</code> 比较的是值</li></ul><blockquote><p>因为 Java 只有值传递, 所以对于 == 来说, 不管是比较基本数据类型还是引用数据类型的变量, 其本质比较的都是值, 只不过引用类型变量存的值是对象的地址</p></blockquote><p><code>equals()</code> 不能用于判断基本数据类型的变量, 只能用于判断两个对象是否相等. <code>equals()</code> 方法存在于 <code>Object</code> 类中, 而 <code>Object</code> 类是所有类的直接或间接父类, 因此所有的类都有 <code>equals()</code> 方法</p><p><code>equals()</code> 方法存在两种使用情况:</p><ul><li><strong>类没有重写 <code>equals()</code> 方法</strong> : 通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code> 方法</strong> : 一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h2 id="hashCode-有什么用">hashCode() 有什么用?</h2><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code> 定义在 <code>Object</code> 类中, 这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数</p><p>散列表存储的是键值对(key-value), 它的特点是：<strong>能根据“键”快速的检索出对应的“值”. 这其中就利用到了散列码!（可以快速找到所需要的对象)</strong></p><h2 id="为什么要有hashCode">为什么要有hashCode()?</h2><p>在一些容器中(例如 <code>HashMap</code> , <code>HashSet</code> ), 有了 <code>hashCode()</code> 之后, 判断元素是否在容器中的效率会更高</p><p>先用 <code>hashCode()</code> 判断, 如果一个 <code>hashCode</code> 对应有多个对象, 它会继续使用 <code>equals()</code> 来判断是否真的相同</p><p><strong>为什么不只提供<code>hashCode()</code> 方法?</strong></p><p>因为可能存在哈希碰撞 (<em>什么是哈希碰撞? 这是数据结构与算法的内容, 自己回去补数据结构与算法吧</em> ) 的情况, 即多个不同的对象对应到同一个哈希值, 为了避免不同对象有相同哈希值导致误判为同一对象, 必须再提供一个 <code>equals()</code> 方法</p><p>简单来说就是</p><ul><li>如果两个对象的哈希值相等, 那么这两个对象不一定相等, 需要用 <code>equals()</code> 方法再做一次判断</li><li>如果两个对象哈希值不等, 那么这两个对象一定不相等</li><li>如果两个对象的哈希值相等且<code>equals()</code> 返回 <code>true</code> , 这两个对象是相等的</li></ul><h2 id="为什么重写-equals-方法时必须重写-hashCode-方法">为什么重写 equals() 方法时必须重写 hashCode() 方法?</h2><p>因为两个相等的对象的哈希值必须是相等的, 也就是说如果<code>equals()</code> 返回true, 说明这两个对象的哈希值也必须是相等的, 所以必须重写 <code>hashCode()</code></p><p>如果重写了 <code>equals()</code> 方法却没重写 <code>hashCode()</code> 方法, 那么就会出现一种情况: <code>equals()</code> 返回true(两个对象应该是相等的) , 但是 <code>hashCode()</code> 的返回值也就是哈希值不一定相等</p><p>如果重写了 <code>equals()  </code> 但是没有重写 <code>hashCode()</code> , 却使用了 <code>HashMap</code> 呢? 假设重写了 <code>equals()</code> 方法, 没有重写 <code>hashCode()</code> 方法, 那么会出现这样的情况: 两个对象在 <code>equals()</code> 方法返回了true, 但是它们的哈希值不同, 这就有可能两个相同的对象重复存储在了一个 <code>HashMap</code> 里面 (因为它们的哈希值不同, 存储的位置是不一样的)</p><h1>String</h1><h2 id="String-StringBuffer-StringBuilder的区别">String, StringBuffer, StringBuilder的区别?</h2><p><strong>可变性</strong></p><p><code>String</code> 是不可变的</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类, 在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串, 不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰, 最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的, 也就可以理解为常量, 线程安全. <code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类, 定义了一些字符串的基本操作, 如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法. <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁, 所以是线程安全的. <code>StringBuilder</code> 并没有对方法进行加同步锁, 所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结</strong></p><ol><li>操作少量数据: 使用 <code>String</code></li><li>单线程操作大量数据: 使用 <code>StringBuilder</code></li><li>多线程操作大量数据: 使用 <code>StringBuffer</code></li></ol><h2 id="String为什么是不可变的">String为什么是不可变的</h2><ol><li>保存字符串的数组被 <code>final</code> 修饰且私有的, 并且 <code>String</code> 类没有提供修改字符串的方法</li><li><code>String</code> 类被 <code>final</code> 修饰所以它不能被继承, 进而避免子类破坏 <code>String</code> 不可变的情况</li></ol><h2 id="字符串拼接用-“-”-还是用-StringBuilder">字符串拼接用 “+” 还是用 StringBuilder?</h2><p>其实都可以</p><p>在 String 中, “+” 和 “+=” 两个运算符其实是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的, 拼接完成之后再调用一个 <code>toString()</code> 方法返回一个 <code>String</code>. 学过C++的应该会意识到这里出现了重载运算符, 没错这两个运算符也是 Java 唯二的重载运算符</p><p>在 JDK9 之前, 如果在循环内使用 “+” 进行字符串拼接, 会导致产生大量的 <code>StringBuilder</code> . 所以在 JDK9 之前, 建议用 <code>StringBuilder</code> 进行拼接</p><p>当然, 现在这个问题已经解决了. JDK9 中, 字符串相加改为用动态方法 <code>makeConcatWithConstants()</code> 来实现, 这样就不会导致产生大量的 <code>StringBuilder</code> 了</p><h2 id="String中的-equals-和-Object中的-equals-有什么区别">String中的 equals() 和 Object中的 equals() 有什么区别?</h2><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的, 比较的是 String 字符串的值是否相等.  <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址</p><h2 id="String-s1-new-String-“abc”-这句话创建了几个字符串">String s1 = new String(“abc”); 这句话创建了几个字符串?</h2><p>1个或者2个</p><ol><li>假如字符串常量池中没有 “abc” 的引用, 那么就会产生两个字符串对象, 其中一个存在字符串常量池</li><li>假如字符串常量池中有 “abc” 的引用, 那么只会在堆中创建一个字符串对象</li></ol><h2 id="String的intern方法有什么作用">String的intern方法有什么作用?</h2><p><code>String.intern()</code> 是一个 native（本地）方法, 其作用是将指定的字符串对象的引用保存在字符串常量池中, 可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用, 就直接返回该引用</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用, 那就在常量池中创建一个指向该字符串对象的引用并返回</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="String-类型的变量和常量做-“-”-运算时发生了什么">String 类型的变量和常量做 “+” 运算时发生了什么?</h2><p><strong>对于编译期可以确定值的字符串, 也就是常量字符串 , jvm 会将其存入字符串常量池. 并且, 字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池, 这个得益于编译器的优化</strong></p><p>在编译过程中, Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中, 这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)</p><p>也就是说, 对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;</code> , 编译器会优化为 <code>String str3 = &quot;string&quot;</code></p><p>只有编译器在程序编译器可以确定值的常量才可以进行常量折叠</p><ul><li>基本数据类型以及字符串常量</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+” 拼接得到的字符串, 基本数据类型之间算术运算, 基本数据类型的位运算</li></ul><p><strong>引用的值在程序编译期是无法确定的, 编译器无法对其进行优化</strong></p><p>对象引用和“+”的字符串拼接方式, 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的, 拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象</p><p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理, 编译器在程序编译期就可以确定它的值, 其效果就相当于访问常量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文部分内容节选自Java Guide, 地址: &lt;a href=&quot;https://javaguide.cn/java/basis/java-basic-questions-02.html&quot;&gt;https://javaguide.cn/java/basis/j</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识总结（上）</title>
    <link href="https://yonagi04.github.io/posts/2024/d13d7d3eee3e/"/>
    <id>https://yonagi04.github.io/posts/2024/d13d7d3eee3e/</id>
    <published>2024-03-16T15:18:53.000Z</published>
    <updated>2025-05-18T09:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文部分内容节选自Java Guide， 地址: <a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></strong></p><blockquote><p>🚀 <a href="https://yonagi04.github.io/posts/2024/bc3a3d7c4c51/">基础（上）</a> → 🚀 <a href="https://yonagi04.github.io/posts/2024/da1a14d471aa/">基础（中）</a> → 🚀<a href="https://yonagi04.github.io/posts/2024/3c15992991b1/">基础（下）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/2dcdc762ee3e/">集合（上）</a> → 🤩<a href="https://yonagi04.github.io/posts/2024/5972154ca625/">集合（下）</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/4e86d54ab314/">JVM专题1</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/82639aae6f65/">JVM专题2</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/7a285a73570d/">JVM专题3</a> → 🤗<a href="https://yonagi04.github.io/posts/2024/fddd546e0d7f/">JVM专题4</a> →😋<a href="https://yonagi04.github.io/posts/2024/6eeebc171f9e/">JUC专题1</a> → 😋<a href="https://yonagi04.github.io/posts/2024/8b5f9ea51b60/">JUC专题2</a></p></blockquote><p>过段时间打算投简历开始找实习了, 得开始复习一点基础知识. 这几天在看Java Guide, 感觉写得不错, 看的时候做点笔记, 把输入转为输出, 帮助消化知识</p><h1>基本数据类型</h1><h2 id="Java中的几种基本数据类型了解吗">Java中的几种基本数据类型了解吗?</h2><p>Java有 8 种基本数据类型, 分别为:</p><ul><li>6 种数字类型:<ul><li>4 种整数型: <code>byte</code> , <code>short</code> , <code>int</code> , <code>long</code></li><li>2 种浮点型: <code>float</code> , <code>double</code></li></ul></li><li>1 种字符类型: <code>char</code></li><li>1 种布尔类型: <code>boolean</code></li></ul><table><thead><tr><th><strong>基本类型</strong></th><th><strong>位数</strong></th><th><strong>字节</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><p>Java基本类型的存储空间不会随着机器硬件架构的改变而改变</p><p><strong>注意</strong>:</p><ol><li><p>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析</p></li><li><p>(这一条是我自己加的) 根据阿里巴巴Java开发准则, 在使用 <code>long</code> 类型数据时, 数值后面不能用 <strong>l</strong> , 而必须得用 <strong>L</strong></p><p>为什么? 请看如下的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">121l</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1211</span>;</span><br><span class="line"><span class="comment">// a的最后一位其实是l, b的最后一位才是数字1, 你发现了吗?是不是傻傻分不清</span></span><br><span class="line"><span class="comment">// 如果写成l, 那么很容易会和数字1混淆</span></span><br></pre></td></tr></table></figure></li></ol><p>这些基本类型也有它们的包装类: <code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> .</p><h2 id="讲讲包装类型和基本类型的区别">讲讲包装类型和基本类型的区别</h2><ul><li>除了常量或者局部变量, 在其他地方诸如函数参数、对象属性上都用包装类型, 而且包装类型可以用于泛型, 基本类型不行</li><li>基本类型的局部变量存储在虚拟机栈的局部变量表中, 基本类型的成员变量存储在虚拟机的堆中. 包装类型属于对象类型, 自然是存在堆里面</li><li>基本类型的占用空间比包装类型占用空间更小</li><li>包装类型不赋值就是null, 基本类型有初始值且不是null</li><li>对于基本类型而言, <code>==</code> 比较的是值; 对于包装类型而言, <code>==</code> 比较的是内存地址, <code>equal()</code> 才是比较的值</li></ul><p>⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区! ** 基本数据类型的存储位置取决于它们的作用域和声明方式. 如果它们是局部变量, 那么它们会存放在栈中; 如果它们是成员变量, 那么它们会存放在堆中.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量，存放在堆中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span></span><br><span class="line">    <span class="comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量，存放在栈中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类型的缓存机制了解吗">包装类型的缓存机制了解吗</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据, <code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据, <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>.</p><p>浮点数的包装类 <code>Float</code> 和 <code>Double</code> 没有实现缓存机制</p><p>根据阿里巴巴Java开发准则, 所有整型包装类在比较大小时, 必须全部使用 <strong>equal()</strong> 进行比较</p><p>为什么? 请看下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// 结果是什么?</span></span><br></pre></td></tr></table></figure><p>正确答案是 false.</p><p><code>Integer a = 10</code> 这一行代码会发生装箱, 也就是说这行代码等价于 <code>Integer a = Integer.valueOf(10)</code> . 因此, <code>a</code> 直接使用的是缓存中的对象. 而<code>Integer b = new Integer(10)</code> 会直接创建新的对象.</p><p>对于 <code>Integer var = ?</code> 在 -128 ~ 127 之间的赋值, Integer对象在 IntegerCache.cache产生, 会复用已有对象, 因此可以用 <code>==</code> 判断, 但是这个区间以外的赋值都会在堆上产生, 不会复用已有对象</p><h2 id="自动拆装箱了解吗">自动拆装箱了解吗</h2><p>什么是自动装箱/拆箱机制?</p><p>装箱: 基本类型用对应的包装类型包装起来</p><p>拆箱: 包装类型转换成对应的基本类型</p><p>实际上, 装箱是调用了包装类的 <code>valueOf()</code> 方法, 而拆箱是调用了 <code>xxxValue()</code> 方法</p><p><strong>频繁地拆装箱会严重影响系统的性能</strong></p><h2 id="为什么浮点数运算会有精度丢失的风险">为什么浮点数运算会有精度丢失的风险</h2><p>这个是计组的内容, Java Guide里面讲的不是很详细, 我从CSAPP里面再详细讲一下</p><p>目前我们使用的浮点数标准是 <strong>IEEE浮点标准</strong> , IEEE浮点标准用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">V = (-1)^s \times M \times 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span> 的形式表示一个数</p><ul><li><p><strong>符号</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 决定这个数是正数(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)还是负数(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>) , 对于数值 0 的符号位作为特殊情况处理</p></li><li><p><strong>尾数</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 是一个二进制小数, 它的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>2</mn><mo>−</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">1 \sim 2-\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span> , 或者是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>1</mn><mo>−</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">0\sim 1-\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span></span></span></span></p></li><li><p><strong>阶码</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 的作用是对浮点数加权, 这个权重是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 次幂</p></li></ul><p>将浮点数的位表示划分为三个字段, 分别对这些值进行编码</p><ul><li>一个单独的符号位的符号位直接编码符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位的阶码字段 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>exp</mi><mo>⁡</mo><mo>=</mo><msub><mi>e</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\exp = e_{k-1}\cdots e_1e_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 编码阶码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位小数字段 frac = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo><msub><mi>f</mi><mn>1</mn></msub><msub><mi>f</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f_{n-1}\cdots f_1f_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 编码尾数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> , 但是编码出来的值也依赖于阶码字段的值是否等于 0</li></ul><p>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>exp</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\exp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mop">exp</span></span></span></span> 的值, 被编码的值可以分成三种不同的情况</p><ul><li><strong>情况1: 规格化的值</strong></li></ul><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>exp</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\exp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mop">exp</span></span></span></span> 的位模式不全为 0, 也不全为 1(单精度数值为255, 双精度数值为2047)</p><p>在这种情况下, 阶码字段被解释为以 <strong>偏置</strong> 表示的有符号整数, 也就是说, 阶码的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>e</mi><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">E = e - Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ia</span><span class="mord mathnormal">s</span></span></span></span> , 其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 是无符号数, 其位表示是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">e_{k-1}\cdots e_1e_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">ia</span><span class="mord mathnormal">s</span></span></span></span> 是一个等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{k-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (单精度是127, 双精度是1023) 的偏置值.</p><p>小数字段 frac 被解释为描述小数值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> , 其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>f</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\le f &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, 其二进制表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.</mn><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo><msub><mi>f</mi><mn>1</mn></msub><msub><mi>f</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">0.f_{n-1}\cdots f_1f_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord">0.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 也就是二进制小数点在最高有效位的左边.</p><p>尾数定义为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">M = 1 + f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> .</p><ul><li><strong>情况2: 非规格化的值</strong></li></ul><p>当阶码域全为 0 时, 所表示的数是非规格化形式</p><p>非规格化有两个用途:</p><ol><li>它提供了一种表示数值0的方法. +0.0的浮点表示的位模式全为0 : 符号位为0, 阶码字段全为0, 而小数域也全为0. 当符号位为1, 阶码和小数域全为0时, 就得到了值 -0.0. 值 +0.0 和 -0.0发在某些方面认为是不同了, 而在其他一些方面认为是相同的.</li><li>非规格化数另一个功能是表示那些非常接近0的数, 它们提供了一种属性, 称为 <strong>逐渐下溢</strong></li></ol><ul><li><strong>情况3: 特殊值</strong></li></ul><p>最后一类数值是当阶码全为1的时候出现的, 当小数域全为0时, 得到的值表示无穷, 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span> , 或者当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span> . 当小数域非 0 时, 结果值被称为 “NAN”, 即 “不是一个数(Not a Number)”</p><p>关于浮点数运算, IEEE 标准指定了一个简单的规则, 来确定诸如加法和乘法这样的算术运算的结果</p><p>把浮点值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 看成实数, 而某个运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊙</span></span></span></span> 定义在实数上, 计算将产生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⊙</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Round(x\odot y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> , 这是对实际运算的精确结果进行舍入之后的结果</p><p><strong>浮点加法不具有结合性</strong></p><p>假设编译器给定了如下代码片段</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = a + b + c;</span><br><span class="line">y = b + c + d;</span><br></pre></td></tr></table></figure><p>编译器可能会通过产生下列代码来省去一个浮点加法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t = b + c;</span><br><span class="line">x = a + t;</span><br><span class="line">y = t + d;</span><br></pre></td></tr></table></figure><p>然而, 对于 x 来说, 这个运算可能会产生与原始值不同的值, 因为它使用了和加法运算不同的结合方式.</p><p>编译器无法知道在效率和忠于原始程序的确切行为之间, 使用者愿意做出什么选择, 结果是, 编译器倾向于保守, 避免任何对功能产生影响的优化, 即使是很轻微的影响</p><p><strong>浮点加法满足了单调性属性</strong></p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \ge b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> , 那么对于任何 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的值, 除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NaN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> , 都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>a</mi><mo>≥</mo><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">x + a \ge x + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> . 无符号或补码加法不具有这个实数加法的属性</p><p><strong>浮点乘法</strong> 也遵循乘法所具有的许多属性. 定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msup><mo>∗</mo><mi>f</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">x *^f y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∗</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>×</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Round(x \times y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> . 这个运算在乘法中是封闭的, <strong>它是可交换的</strong>, 另一方面, 由于可能发生溢出, 或者由于舍入失去精度, <strong>它不具有可结合性</strong></p><h2 id="既然浮点数运算有精度丢失问题-如何规避">既然浮点数运算有精度丢失问题, 如何规避?</h2><p>简单回答: 用大数类( <code>BigDecimal</code> ) 来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><p>接下来简单讲讲<code>BigDecimal</code> 的使用</p><ol><li>创建</li></ol><p>我们在使用 <code>BigDecimal</code> 时, 为了防止精度丢失, 推荐使用它的<code>BigDecimal(String val)</code>构造方法或者<code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象.</p><p>根据阿里巴巴Java开发准则, 禁止使用构造方法 <code>BigDecimal(double)</code> 的方式将double变量转为BigDecimal对象</p><p>究其原因还是上面已经提及的精度丢失问题, 这里不再赘述</p><ol start="2"><li>加减乘除</li></ol><p><code>add</code> 方法用于将两个 <code>BigDecimal</code> 对象相加, <code>subtract</code> 方法用于将两个 <code>BigDecimal</code> 对象相减. <code>multiply</code> 方法用于将两个 <code>BigDecimal</code> 对象相乘, <code>divide</code> 方法用于将两个 <code>BigDecimal</code> 对象相除.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure><ol start="3"><li>大小比较</li></ol><p><code>a.compareTo(b)</code> 返回 -1表示 <code>a</code> 小于 <code>b</code> , 0 表示相等, 1 表示 <code>a</code> 大于 <code>b</code></p><p>根据阿里巴巴Java开发准则, BigDecimal的等值比较应当使用<code>compareTo()</code> 方法, 而不应该是 <code>equal()</code> 方法. 因为 <code>equal()</code> 会比较值和精度, 而 <code>compareTo()</code> 会忽略精度进行比较</p><h1>变量</h1><h2 id="成员变量和局部变量的区别">成员变量和局部变量的区别?</h2><ul><li>成员变量是属于类的, 而局部变量是在方法或者代码块中定义的变量或者是方法的参数. 成员变量可以被 <code>public</code> , <code>private</code> , <code>static</code> 等修饰符修饰, 但是局部变量不行. 局部变量和成员变量都能被 <code>final</code> 修饰</li><li>从变量在内存中的存储方式来看, 如果成员变量是使用 <code>static</code> 修饰的, 那么这个成员变量是属于类的, 如果没有使用 <code>static</code> 修饰, 这个成员变量是属于实例的. 而对象存在于堆内存, 局部变量则存在于栈内存</li><li>成员变量的生存时间是跟着类生成的对象的, 对象生成, 它就产生, 对象被销毁, 它也就消失. 局部变量的生存时间主要是看代码运行的位置有没有跳出它的作用域(也就是它所处的代码块)</li><li>成员变量如果没有被赋初始值, 则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值）, 而局部变量则不会自动赋值</li></ul><h2 id="为什么成员变量要有默认值">为什么成员变量要有默认值</h2><ol><li><p>先不考虑变量类型, 如果没有默认值会怎样? 变量存储的是内存地址对应的任意随机值, 程序读取该值运行会出现意外</p></li><li><p>默认值有两种设置方式: 手动和自动, 根据第一点, 没有手动赋值一定要自动赋值. 成员变量在运行时可借助反射等方法手动赋值, 而局部变量不行</p></li><li><p>对于编译器（javac）来说, 局部变量没赋值很好判断, 可以直接报错. 而成员变量可能是运行时赋值, 无法判断, 误报“没默认值”又会影响用户体验, 所以采用自动赋默认值</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num2 + <span class="number">10</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VariableExample</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 对成员变量进行赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态变量有什么用">静态变量有什么用?</h2><p>静态变量, 也就是被 <code>static</code> 修饰的变量, 它可以被类的所有实例共享, 也就是说无论一个类创建了多少对象, 它们都共享一个静态变量. 因为静态变量只会被分配一次内存, 即使创建多个对象, 所以静态变量可以节省内存</p><p>静态变量一般通过类名访问, 如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticVariableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">example</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticVariableExample.example);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实, 对象也可以访问静态变量, 但是很容易和成员变量混淆, 所以建议用类名访问 (我之前有一次刷牛客的Java客观题, 就搞错了这一点)</p><p>静态变量如果再被 <code>final</code> 修饰, 就会变成常量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticVariableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">example</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticVariableExample.example);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符型常量和字符串常量有什么区别">字符型常量和字符串常量有什么区别?</h2><ul><li><p><strong>形式</strong> : 字符常量是单引号引起的一个字符, 字符串常量是双引号引起的 0 个或若干个字符</p></li><li><p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p></li><li><p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节</p></li></ul><h1>方法</h1><h2 id="静态方法为什么不能调用非静态成员">静态方法为什么不能调用非静态成员?</h2><ol><li>静态方法是属于类的, 在类加载的时候就会分配内存, 可以通过类名直接访问, 而非静态成员需要对象实例化之后才存在, 需要通过类的实例对象去访问</li><li>在非静态成员不存在的时候静态方法就已经存在了, 如果此时去调用不存在的非静态成员, 是非法操作(试图读取未知的内存)</li></ol><h2 id="静态方法和实例方法有什么不同">静态方法和实例方法有什么不同?</h2><ol><li>调用方式</li></ol><p>在外部调用静态方法时, 可以使用 <code>类名.方法名</code> 的方式, 也可以使用 <code>对象.方法名</code> 的方式, 而实例方法只有后面这种方式. 也就是说, <strong>调用静态方法可以无需创建对象</strong></p><p>但是和前面提到的静态变量调用同理, 不建议用 <code>对象.方法名</code> 的方式进行调用</p><ol start="2"><li>访问类成员是否存在限制</li></ol><p>静态方法在访问本类的成员时, 只允许访问静态成员 (即静态成员变量和静态方法) , 不允许访问实例成员 (即实例成员变量和实例方法) , 而实例方法不存在这个限制</p><h2 id="重载和重写有什么区别">重载和重写有什么区别?</h2><p>重载: 发生在同一个类中 (或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同, 方法返回值和访问修饰符可以不同</p><p>重写: 重写发生在运行期, 是子类对父类的允许访问的方法的实现过程进行重新编写</p><ol><li>方法名、参数列表必须相同, 子类方法返回值类型应比父类方法返回值类型更小或相等, 抛出的异常范围小于等于父类, 访问修饰符范围大于等于父类</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法, 但是被 <code>static</code> 修饰的方法能够被再次声明</li><li>构造方法无法被重写</li></ol><table><thead><tr><th>区别</th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能改</td></tr><tr><td>返回类型</td><td>可以改</td><td>子类返回类型应当比父类的更小或者相等</td></tr><tr><td>异常</td><td>可以改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</td></tr><tr><td>访问修饰符</td><td>可以改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译</td><td>运行</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Java技术栈系列</summary>
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="https://yonagi04.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://yonagi04.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：飞机降落</title>
    <link href="https://yonagi04.github.io/posts/2024/596a6913f475/"/>
    <id>https://yonagi04.github.io/posts/2024/596a6913f475/</id>
    <published>2024-03-16T14:31:58.000Z</published>
    <updated>2025-05-18T09:07:25.415Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：第十四届蓝桥杯大赛软件赛省赛B组</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 架飞机准备降落到某个只有一条跑道的机场. 其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 架飞机在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻到达机场上空, 到达时它的剩余油料还可以盘旋 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个单位时间, 即它最早可以于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻降落, 最晚可以于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>+</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i + D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时刻降落. 降落过程需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个单位时间</p><p>一架飞机降落完毕时, 另一架飞机可以立即在同一时刻开始降落, 但是不能在前一架飞机完成降落之前开始降落</p><p>请判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 架飞机是否可以全部安全降落</p><p><strong>输入</strong>: 输入包含多组数据</p><p>第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> , 代表测试的组数</p><p>对于每组数据, 第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>以下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行, 每行包括三个整数: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>D</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i, D_i, L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>输出</strong>: 对于每组数据, 输出 YES 或者 NO, 代表是否可以全部安全降落</p><p><strong>Input Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">0 100 10</span><br><span class="line">10 10 10</span><br><span class="line">0 2 20</span><br><span class="line">3</span><br><span class="line">0 10 20</span><br><span class="line">10 10 20</span><br><span class="line">20 10 20</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></blockquote><p>这道题数据范围特别小, 最多只有10架飞机, 因此可以直接DFS搜索.如果合法的话就输出&quot;YES&quot;, 找不到合法方案就输出&quot;NO&quot;</p><p>下面给出题解. 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plane</span> &#123;</span><br><span class="line"><span class="comment">/* data */</span></span><br><span class="line"><span class="type">int</span> s, e, l;</span><br><span class="line">    <span class="comment">// s 到达机场时间</span></span><br><span class="line">    <span class="comment">// e 最晚降落时间</span></span><br><span class="line">    <span class="comment">// l 降落时长</span></span><br><span class="line">&#125;a[<span class="number">11</span>];</span><br><span class="line"><span class="type">bool</span> t[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs搜索, 因为数据量特别小, 所以完全不会tle</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> time, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">        <span class="comment">// 正解, n架飞机均能降落</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">t[i] = <span class="literal">true</span>;</span><br><span class="line">time += a[i].l;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!t[i]) &#123;</span><br><span class="line"><span class="type">int</span> start = a[i].s, end = a[i].e;</span><br><span class="line"><span class="keyword">if</span> (end &lt; time) &#123;</span><br><span class="line">                <span class="comment">// 如果当前时间已经比这架飞机的最晚降落时间还要晚, 那么这种情况是不合法的, 返回false</span></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag |= <span class="built_in">dfs</span>(i, <span class="built_in">max</span>(start, time), cnt + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> t, d, l;</span><br><span class="line">cin &gt;&gt; t &gt;&gt; d &gt;&gt; l;</span><br><span class="line">a[i].s = t, a[i].e = t + d, a[i].l = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(i, a[i].s, <span class="number">1</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源：第十四届蓝桥杯大赛软件赛省赛B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯每日一题：冶炼金属</title>
    <link href="https://yonagi04.github.io/posts/2024/90b6cc03b4af/"/>
    <id>https://yonagi04.github.io/posts/2024/90b6cc03b4af/</id>
    <published>2024-03-16T12:44:07.000Z</published>
    <updated>2025-05-18T09:07:25.414Z</updated>
    
    <content type="html"><![CDATA[<p>蓝桥杯省赛要来了, 从acm退役之后平时都在刷力扣题, 没咋刷这种acm模式的题了, 蓝桥杯的代码是acm模式, 所以最近得开始加训. 写题的时候顺带分享一下自己写题的题解</p><p>题目来源：第十四届蓝桥杯大赛软件赛省赛B组</p><blockquote><p>小蓝有一个神奇的炉子用于将普通金属  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 冶炼成为一种特殊金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 。这个路子有一种称为转化率的属性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 是一个正整数，这意味着消耗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 个普通金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 恰好可以冶炼出一个特殊金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> , 当普通金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 的数目不足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 时, 无法进行冶炼</p><p>现在给出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 条冶炼记录, 每条记录中包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> , 这表示本次投入了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 个普通金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> , 最终冶炼出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 个特殊金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> . 每条记录都是独立的, 这意味着上一次没消耗完的普通金属 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 不会累加到下一次的冶炼中</p><p>根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 条冶炼记录, 请推测出转化率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的最小值和最大值可能是多少</p><p><strong>输入</strong>: 第一行输入一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> , 表示冶炼记录的数目</p><p>接下来输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行, 每行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> , 含义如题目所述</p><p><strong>输出</strong>: 输出两个整数, 分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 可能的最小值和最大值, 中间用空格隔开</p><p><strong>Input Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">75 3</span><br><span class="line">53 2</span><br><span class="line">59 2</span><br></pre></td></tr></table></figure><p><strong>Output Sample</strong>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 25</span><br></pre></td></tr></table></figure></blockquote><p>看到这道题, 你的思路是啥?</p><p>其实这道题的考点是二分. 因为如果一个一个找, 效率会很低而且有些样例大概率过不去, 如果我们要快速找到这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 值, 能想到的方法就是二分. 那怎么找呢, 这里要找最大值, 还要找最小值</p><p>那就用两次二分法, 一次找最大, 一次找最小</p><p>思路捋清楚之后就能开始写代码了</p><p>这里我讲一下两个check函数是干啥用的: 对于checkMin函数而言, 如果我们找到一个值, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 除以这个值比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 要大的话, 那么说明我们找到的这个值很明显是偏小的; 反之, 这个值是偏大的. 对于checkMax函数而言, 如果我们找到一个值, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 除以这个值比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 值要小的话, 说明我们找到的这个值明显偏大了; 反之这个值偏小. 根据check函数返回的结果调整区间的左右边界即可.</p><p>下面给出题解代码, 请注重思考, 不要无脑cv</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> x[maxn], o[maxn];</span><br><span class="line"><span class="type">int</span> n, maxx, minn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkMin</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (o[i] / num &gt; x[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkMax</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (o[i] / num &lt; x[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">io</span>();</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; o[i] &gt;&gt; x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkMin</span>(mid)) &#123;</span><br><span class="line">minn = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">checkMax</span>(mid)) &#123;</span><br><span class="line">maxx = mid;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; minn &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; maxx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;蓝桥杯省赛要来了, 从acm退役之后平时都在刷力扣题, 没咋刷这种acm模式的题了, 蓝桥杯的代码是acm模式, 所以最近得开始加训. 写题的时候顺带分享一下自己写题的题解&lt;/p&gt;
&lt;p&gt;题目来源：第十四届蓝桥杯大赛软件赛省赛B组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://yonagi04.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://yonagi04.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>基于VMware虚拟机安装MacOS BigSur系统</title>
    <link href="https://yonagi04.github.io/posts/2024/81ef32e52e7a/"/>
    <id>https://yonagi04.github.io/posts/2024/81ef32e52e7a/</id>
    <published>2024-03-16T09:41:16.000Z</published>
    <updated>2025-05-18T09:07:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>这周用VMWare搞了个MacOS虚拟机，也算是完成初中高中时候的梦想了吧~~（那时候我的电脑配置还很拉跨，带不动虚拟机）~~ 写一篇博客记录一下，当然这也是yonagi04.github.io建站的第一篇新博客</p><h2 id="准备工作（VMWare、镜像文件）">准备工作（VMWare、镜像文件）</h2><p>首先当然是要先准备好VMWare了，VMWare可以在官网下载，然后在Google上面找一下激活码就能直接激活了，VMWare的激活码还是很容易找的，<s>比起Jetbrain家的软件，VMWare的激活码可更容易找了，Idea的激活码我是怎么找都找不到</s></p><p>刚刚装好的VMWare，在安装虚拟机操作系统的时候是没有MacOS这个选项的，必须先破解了才能安装MacOS，不破解是装不了的（别问为什么）</p><p>Github上面有不少大神写了破解脚本，其中有一个是Auto-Unlocker，我把它的下载链接贴在这里：<a href="https://github.com/paolo-projects/auto-unlocker/releases">https://github.com/paolo-projects/auto-unlocker/releases</a></p><p>点进去就能直接下载了</p><p>解压之后，启动程序（<strong>注意，这一步要在任务管理器把和VMWare有关的所有进程先关掉！</strong>）</p><p>接下来就是等待了，程序会自动下载资源并破解VMWare，破解完之后我们就可以直接安装了</p><p>接下来就是MacOS镜像，这里同样给大家一个网站：<a href="https://www.mediafire.com/file/dbfod9u5q9ii9nd/macOS_Big_Sur_11.0.1_%252820B29%2529.iso/file">https://www.mediafire.com/file/dbfod9u5q9ii9nd/macOS_Big_Sur_11.0.1_%252820B29%2529.iso/file</a></p><p>网速快的话，半个多小时就能下完</p><p>下载完成之后，我们就可以开始安装MacOS虚拟机</p><h2 id="MacOS，启动！">MacOS，启动！</h2><p>启动VMWare</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/VMWare1.png" alt=""></p><p>点击左上角的 文件-新建虚拟机，在弹出来的新窗口中，选择“典型”，然后下一步</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://unpkg.com/yonagi-blog-repo-img/img/content/VMWare2.png" alt=""></p><p>（我这里已经把MacOS镜像删掉了）</p><p>选择“安装程序光盘映像文件”, 然后选择刚刚下载好的MacOS镜像，点击下一步</p><p>下一步就是选择系统了，我们当然要选择MacOS系统，系统版本选择macOS 11</p><p>下一步是存储位置，根据自己的偏好来就行，但还是那句老话：<strong>不要装在C盘！不要装在C盘！不要装在C盘！</strong> 重要的事情说三遍！</p><p>然后就是选择磁盘大小了，这里建议分配80GB以上。下面的单文件or多文件，我个人建议是选择单文件，因为多文件的话虚拟硬盘速度会明显比单文件的虚拟硬盘速度要慢得多</p><p>之后我们就创建完成了，接下来就是修改具体的硬件参数。选择“自定义硬件”，个人建议CPU至少给8核，RAM至少给8GB，这至少能保证不会非常卡</p><p>接下来就是启动虚拟机了，Intel用户可以直接启动安装了，AMD用户留下来(没错，接下来有一个大坑，就是针对AMD的)</p><p>AMD用户如果直接启动，VMWare会报错，提示CPU不可用，客户机系统已关闭</p><p>然后你就会一直卡在苹果的logo那里……一动不动……</p><p>怎么办呢，很简单。打开虚拟机安装目录，用记事本或者其他什么什么软件打开类似这样的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macOS xxxxx.vmx</span><br></pre></td></tr></table></figure><p>在文件的末尾，添加如下的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpuid.0.eax = &quot;0000:0000:0000:0000:0000:0000:0000:1011&quot;</span><br><span class="line">cpuid.0.ebx = &quot;0111:0101:0110:1110:0110:0101:0100:0111&quot;</span><br><span class="line">cpuid.0.ecx = &quot;0110:1100:0110:0101:0111:0100:0110:1110&quot;</span><br><span class="line">cpuid.0.edx = &quot;0100:1001:0110:0101:0110:1110:0110:1001&quot;</span><br><span class="line">cpuid.1.eax = &quot;0000:0000:0000:0001:0000:0110:0111:0001&quot;</span><br><span class="line">cpuid.1.ebx = &quot;0000:0010:0000:0001:0000:1000:0000:0000&quot;</span><br><span class="line">cpuid.1.ecx = &quot;1000:0010:1001:1000:0010:0010:0000:0011&quot;</span><br><span class="line">cpuid.1.edx = &quot;0000:0111:1000:1011:1111:1011:1111:1111&quot;</span><br><span class="line">smbios.reflectHost = &quot;TRUE&quot;</span><br><span class="line">hw.model = &quot;MacBookPro14,3&quot;</span><br><span class="line">board-id = &quot;Mac-551B86E5744E2388&quot;</span><br><span class="line">keyboard.vusb.enable = &quot;TRUE&quot;</span><br><span class="line">mouse.vusb.enable = &quot;TRUE&quot; </span><br></pre></td></tr></table></figure><p>这样就大功告成啦，再次启动虚拟机，VMWare就不会再报错，MacOS也能继续正常安装了</p><p>然后就是MacOS的具体安装，这就不教了，毕竟难度不大，按着系统提示来就行</p><p>安装过程会经历多次重启，最后我们就能看到亲切的MacOS桌面啦！</p><p>当然还没有完全完成，这时候还需要安装VMWare tools、安装优化工具等，但是受制于篇幅我不打算继续写了（其实是我懒）（优化策略以后也许会讲的吧？）</p><p>这样MacOS BigSur系统就算安装完成了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周用VMWare搞了个MacOS虚拟机，也算是完成初中高中时候的梦想了吧~~（那时候我的电脑配置还很拉跨，带不动虚拟机）~~ 写一篇博客记录一下，当然这也是yonagi04.github.io建站的第一篇新博客&lt;/p&gt;
&lt;h2 id=&quot;准备工作（VMWare、镜像文件）&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VMWare" scheme="https://yonagi04.github.io/tags/VMWare/"/>
    
    <category term="黑苹果" scheme="https://yonagi04.github.io/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
    <category term="MacOS" scheme="https://yonagi04.github.io/tags/MacOS/"/>
    
    <category term="杂七杂八" scheme="https://yonagi04.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计 知识点</title>
    <link href="https://yonagi04.github.io/posts/2024/f8877bbf319d/"/>
    <id>https://yonagi04.github.io/posts/2024/f8877bbf319d/</id>
    <published>2024-03-15T20:40:06.000Z</published>
    <updated>2025-05-18T09:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、面向对象程序设计概述">一、面向对象程序设计概述</h2><p>面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。OOP 的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP = 对象+类+继承+多态+消息，其中核心概念是类和对象。</p><p>类是构造对象的模板，而对象可以理解为类的实例。简单来讲，可以把类想象成制作甜饼的模具，而对象想象成小甜饼。由类创造出对象的过程称为创建类的实例。</p><p><strong>面向对象的三大特性：封装、继承、多态。</strong></p><h2 id="二、封装">二、封装</h2><h3 id="1、封装基础">1、封装基础</h3><p>封装(Encapsulation)是面向对象三大特性之一。</p><p>封装就是将数据和行为组合起来，并对对象的使用者隐藏具体的实现方式。</p><p>封装的意义，在于可以将对象中的属性和行为加以<strong>权限控制</strong>。</p><p>例1：设计一个圆类，计算出圆的周长。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//class 代表设计一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="type">int</span> m_r;</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//获取周长</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过圆类，创建具体对象 圆</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆 对象的属性进行赋值</span></span><br><span class="line">    c1.m_r = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C = &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：设计一个学生类，属性有姓名和学号，可以给学号和姓名赋值，并显示学生的姓名和学号。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//权限</span></span><br><span class="line">    <span class="comment">//类中的属性和行为成为 成员</span></span><br><span class="line">    <span class="comment">//属性 成员属性</span></span><br><span class="line">    <span class="comment">//行为 成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_ID;</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; num &quot;</span> &lt;&lt; m_ID &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        m_ID = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="comment">// stu.m_Name = &quot;Yonagi&quot;;</span></span><br><span class="line">    stu.<span class="built_in">setName</span>(<span class="string">&quot;Yonagi&quot;</span>);</span><br><span class="line">    <span class="comment">// stu.m_ID = 1;</span></span><br><span class="line">    stu.<span class="built_in">setID</span>(<span class="number">1</span>);</span><br><span class="line">    stu.<span class="built_in">ShowStudent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、访问权限">2、访问权限</h3><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有以下三种：</p><p><strong>1、public 公共权限  类内可以访问，类外可以访问</strong></p><p><strong>2、protected 保护权限  类内可以访问，类外不可以访问</strong></p><p><strong>3、private 私有权限  类内可以访问，类外不可以访问</strong></p><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="comment">//1、公共权限 public 成员 类内可以访问，类外可以访问</span></span><br><span class="line"><span class="comment">//2、保护权限 protected 成员 类内可以访问，类外不可以访问</span></span><br><span class="line"><span class="comment">//3、私有权限 private 成员 类内可以访问，类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_Car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Password;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;Yonagi&quot;</span>;</span><br><span class="line">        m_car = <span class="string">&quot;TOYOTA&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化具体对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_Name = <span class="string">&quot;Sierra&quot;</span>;</span><br><span class="line">    <span class="comment">// p1.m_car = &quot;NISSAN&quot;;//保护权限内容，类外无法访问</span></span><br><span class="line">    <span class="comment">// p1.m_Password = 234567;//私有权限内容，类外无法访问</span></span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、struct和class的区别">3、struct和class的区别</h3><p>初学面向对象时，会发现struct 和 class 很相似。</p><p>struct和class的一个区别就是，它们的默认访问权限是不同的，<strong>struct的默认访问权限是public，class的默认访问权限是private。</strong></p><p>例4：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//struct和class默认访问权限不同</span></span><br><span class="line"><span class="comment">//struct 默认权限为public</span></span><br><span class="line"><span class="comment">//class 默认权限为private</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//默认权限为private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//默认权限为public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C1 c1;</span><br><span class="line">    <span class="comment">// c1.m_A = 100;//私有</span></span><br><span class="line">    C2 c2;</span><br><span class="line">    c2.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、成员属性私有化">4、成员属性私有化</h3><p>对于一个类，实现封装的最好方法，就是将属性设置为private，将成员函数设置为public。</p><p>例5：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>) &#123;</span><br><span class="line">            m_Age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_Age = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_Name; <span class="comment">//可读可写</span></span><br><span class="line">    <span class="type">int</span> m_Age; <span class="comment">// 可读可写 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;Yonagi&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name : &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age : &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例6：设计一个立方体类，求出立方体的面积和体积</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setM_H</span><span class="params">(<span class="type">double</span> h)</span> </span>&#123; <span class="comment">//设置高</span></span><br><span class="line">        m_H = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setM_L</span><span class="params">(<span class="type">double</span> l)</span> </span>&#123; <span class="comment">//设置长</span></span><br><span class="line">        m_L = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setM_W</span><span class="params">(<span class="type">double</span> w)</span> </span>&#123; <span class="comment">//设置宽</span></span><br><span class="line">        m_W = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getM_H</span><span class="params">()</span> </span>&#123; <span class="comment">//获取高</span></span><br><span class="line">        <span class="keyword">return</span> m_H;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getM_L</span><span class="params">()</span> </span>&#123; <span class="comment">//获取长</span></span><br><span class="line">        <span class="keyword">return</span> m_L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getM_W</span><span class="params">()</span> </span>&#123; <span class="comment">//获取宽</span></span><br><span class="line">        <span class="keyword">return</span> m_W;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">S</span><span class="params">()</span> </span>&#123; <span class="comment">//获取面积</span></span><br><span class="line">        <span class="keyword">return</span> (m_H * m_L) * <span class="number">2</span> + (m_H * m_W) * <span class="number">2</span> + (m_L * m_W) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">V</span><span class="params">()</span> </span>&#123; <span class="comment">//获取体积</span></span><br><span class="line">        <span class="keyword">return</span> m_H * m_L * m_W;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_H; <span class="comment">//高</span></span><br><span class="line">    <span class="type">double</span> m_L; <span class="comment">//长</span></span><br><span class="line">    <span class="type">double</span> m_W; <span class="comment">//宽</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cube c1;</span><br><span class="line">    c1.<span class="built_in">setM_H</span>(<span class="number">1.0</span>);</span><br><span class="line">    c1.<span class="built_in">setM_L</span>(<span class="number">1.0</span>);</span><br><span class="line">    c1.<span class="built_in">setM_W</span>(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;S of c1 is &quot;</span> &lt;&lt; c1.<span class="built_in">S</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V of c1 is &quot;</span> &lt;&lt; c1.<span class="built_in">V</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Cube c2;</span><br><span class="line">    c2.<span class="built_in">setM_H</span>(<span class="number">2.0</span>);</span><br><span class="line">    c2.<span class="built_in">setM_L</span>(<span class="number">2.0</span>);</span><br><span class="line">    c2.<span class="built_in">setM_W</span>(<span class="number">2.0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;S of c2 is &quot;</span> &lt;&lt; c2.<span class="built_in">S</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V of c2 is &quot;</span> &lt;&lt; c2.<span class="built_in">V</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例7：设计一个圆类，和一个点类，计算点和圆的位置关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        c_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c_x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        c_y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c_y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c_x;</span><br><span class="line">    <span class="type">int</span> c_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        c_r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c_r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(Point center)</span> </span>&#123;</span><br><span class="line">        c_center = center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">getCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c_center;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c_r;</span><br><span class="line">    Point c_center;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(Circle &amp;c, Point &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> distance = </span><br><span class="line">        (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) * (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) + (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>()) </span><br><span class="line">        * (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>());</span><br><span class="line">    <span class="type">int</span> rDistance = c.<span class="built_in">getR</span>() * c.<span class="built_in">getR</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (distance == rDistance) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;On the circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distance &lt; rDistance) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In the circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Out of circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">    c.<span class="built_in">setR</span>(<span class="number">10</span>);</span><br><span class="line">    Point center;</span><br><span class="line">    center.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    center.<span class="built_in">setY</span>(<span class="number">0</span>);</span><br><span class="line">    c.<span class="built_in">setCenter</span>(center);</span><br><span class="line"></span><br><span class="line">    Point p;</span><br><span class="line">    p.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setY</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">judge</span>(c, p); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、对象初始化与清理">三、对象初始化与清理</h2><h3 id="1、构造函数与析构函数">1、构造函数与析构函数</h3><p>一个对象或变量，如果没有初始状态，则其使用后果是未知的。</p><p>同样，如果使用完一个对象或变量，如果没能及时清理，也会带来问题。</p><p>C++提供了<strong>构造函数</strong>和<strong>析构函数</strong>，用于解决以上的问题。这两个函数会被编</p><p>译器自动调用，完成对象的初始化和清理工作。</p><p>因为对象的初始化和清理是编译器强制要求，所以<strong>如果不提供构造函数和析</strong></p><p><strong>构函数，编译器也会自动提供。</strong></p><p><strong>编译器自动提供的构造函数和析构函数是空实现。</strong></p><table><thead><tr><th>构造函数</th><th>析构函数</th></tr></thead><tbody><tr><td>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</td><td>主要作用在于对象销毁前系统自动调用，执行一些清理工作</td></tr></tbody></table><p>构造函数：</p><ol><li>基本语法：类名() {}</li><li><strong>构造函数，没有返回值，也不写void</strong></li><li>函数名与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li><strong>程序在调用对象时可以自动调用构造，无需手动调用，且会调用一次</strong></li></ol><p>析构函数：</p><ol><li>基本语法：~类名() {}</li><li><strong>析构函数，没有返回值，也不写void</strong></li><li>函数名与类名相同，在前面加~</li><li><strong>析构函数不能有参数，因此不能发生重载</strong></li><li><strong>程序在销毁对象时会自动调用析构，无需手动调用，且会调用一次</strong></li></ol><p>例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//1、构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2、析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、构造函数分类与调用">2、构造函数分类与调用</h3><p>构造函数有两种分类方式：</p><table><thead><tr><th>按参数分类</th><th>按类型分类</th></tr></thead><tbody><tr><td>有参构造&amp;无参构造(默认构造)</td><td>普通构造&amp;拷贝构造</td></tr></tbody></table><p>构造函数有三种调用方法：</p><ol><li>括号法</li><li>显示法</li><li>隐式转换法</li></ol><p>注意：<strong>构造默认函数时，不要加()。因为编译器会认为这是函数声明。</strong></p><p>例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor01&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        <span class="comment">//将传入的人身上所有的属性，拷贝</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor02&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、括号法</span></span><br><span class="line">    <span class="comment">// Person p; //默认函数调用</span></span><br><span class="line">    <span class="comment">// Person p2(10); //有参构造函数</span></span><br><span class="line">    <span class="comment">// Person p3(p2); //拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、显示法</span></span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//有参构造</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2); <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//不要利用拷贝构造函数 初始化匿名对象</span></span><br><span class="line">    <span class="comment">//Person(p3); // Person(p3) == Person p3; 对象声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">//相当于 写了Person p4 = Person(10);</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4); 拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、拷贝构造函数的调用时机">3、拷贝构造函数的调用时机</h3><p>拷贝构造函数调用通常有三种情况：</p><ol><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>值方式返回局部对象</li></ol><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Function Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">Work</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = <span class="built_in">Work02</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、构造函数调用规则">4、构造函数调用规则</h3><p>默认情况下，编译器会自动为一个类提供三个函数：</p><ol><li>默认构造函数（无参，空实现）</li><li>默认析构函数（无参，空实现）</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol><p>规则：1、<strong>如果写了有参构造函数，编译器就不再提供默认构造，依然提供拷</strong></p><p><strong>贝构造。</strong></p><p>2、<strong>如果写了拷贝构造函数，编译器不再提供其他普通构造函数</strong></p><p>例4：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Person() &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person Constructor&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Person Function Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">         m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void test01() &#123;</span></span><br><span class="line"><span class="comment">//     Person p;</span></span><br><span class="line"><span class="comment">//     p.m_Age = 18;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Person p2(p);</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; &quot;P2&#x27;s age &quot; &lt;&lt; p2.m_Age &lt;&lt; endl; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">28</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、深拷贝与浅拷贝">5、深拷贝与浅拷贝</h3><table><thead><tr><th>浅拷贝</th><th>深拷贝</th></tr></thead><tbody><tr><td>简单的复制拷贝操作</td><td>在堆区重新申请空间，进行拷贝操作</td></tr></tbody></table><p><strong>深拷贝后，析构函数中应当对堆区开辟的数据进行释放。</strong></p><p>例5：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝和浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Function Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己实现拷贝构造函数，解决浅拷贝带来的问题</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">        <span class="comment">//深拷贝操作</span></span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//析构代码</span></span><br><span class="line">        <span class="comment">//将堆区开辟的数据进行释放</span></span><br><span class="line">        <span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Height = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">int</span> *m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The age of p1 is &quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot; height is &quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The age of p2 is &quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="string">&quot; height is &quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、初始化列表">6、初始化列表</h3><p>C++提供了初始化列表语法，用来初始化属性。</p><p><strong>语法：构造函数() : 属性1(值1), 属性2(值2), …</strong></p><p>例6：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传统初始化操作</span></span><br><span class="line">    <span class="comment">// Person(int a, int b, int c) &#123;</span></span><br><span class="line">    <span class="comment">//     m_A = a;</span></span><br><span class="line">    <span class="comment">//     m_B = b;</span></span><br><span class="line">    <span class="comment">//     m_C = c;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Person p(10, 20, 30);</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_C = &quot;</span> &lt;&lt; p.m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、类对象作为类成员">7、类对象作为类成员</h3><p>类中的成员可以是另一个类的对象，可以称该成员为对象成员。</p><p><strong>当其他类的对象作为本类成员时，构造时先构造类对象，再构造自身。</strong></p><p><strong>析构的顺序与构造顺序相反。</strong></p><p>例7：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span> (string pName) &#123;</span><br><span class="line">        m_PName = pName;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当其他类对象作为本类成员，构造时候先构造类对象，再构造自身</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Yonagi&quot;</span>, <span class="string">&quot;iPhone 14 Pro&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; use &quot;</span> &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、静态成员">8、静态成员</h3><p>静态成员就是在成员变量或成员函数前加关键词static，称为静态成员。</p><p>静态成员分为：</p><table><thead><tr><th>静态成员变量</th><th>静态成员函数</th></tr></thead><tbody><tr><td>1、所有对象共享一份数据</td><td>1、所有对象共享同一个函数</td></tr><tr><td>2、在编译过程分配内存</td><td>2、静态成员函数只能访问静态成员变量</td></tr><tr><td>3、类内声明，类外初始化</td><td></td></tr></tbody></table><p><strong>静态成员变量，不属于某个对象上，所有对象都共享一份数据</strong>，因此静态</p><p>成员变量有两种访问方式：</p><ol><li>通过对象进行访问</li><li>通过类名进行访问</li></ol><p>例8：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    <span class="comment">//静态成员变量也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person :: m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// int Person :: m_B = 200;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;<span class="comment">//共享一份数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量 不属于某个对象上，所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//因此静态成员变量有两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过对象进行访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2、通过类名进行访问</span></span><br><span class="line">    cout &lt;&lt; Person :: m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; Person :: m_B &lt;&lt; endl; //类外访问不到私有成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态成员函数，所有对象都共享同一个函数，且静态函数只能访问静态成员</strong></p><p><strong>变量。</strong></p><p>例9：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// m_B = 200; //静态成员函数不能访问非静态成员变量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person :: m_A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象进行访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    Person :: <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// Person :: func2(); //类外访问不到私有成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、C-对象模型">四、C++对象模型</h2><h3 id="1、成员变量与成员函数的存储">1、成员变量与成员函数的存储</h3><p>在C++中，类内的成员变量和成员函数是分开存储的。</p><p>只有非静态成员变量属于类对象。</p><p><strong>空对象占用内存为1。</strong></p><p>编译器会给每个空对象分配一个字节的空间，是为了区分空对象占内存的位</p><p>置，因此<strong>每个空对象也拥有一个独一无二的内存地址。</strong></p><p>例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量和成员函数是分开存储的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_A; <span class="comment">//非静态成员变量 属于类对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量 不属于类对象上</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//非静态成员函数 不属于类对象上</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//静态成员函数 不属于类对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person :: m_B = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof p is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、this指针">2、this指针</h3><p>this指针是隐含在每个非静态成员函数内的一种指针。</p><p>this指针指向被调用的成员函数所属的对象。</p><p>this指针不需要定义，可以直接使用。</p><p>this指针的用途：</p><ol><li><strong>当形参和成员变量同名时，可以用this指针区分</strong></li><li><strong>在类的非静态成员函数中返回对象本身，可以使用</strong>return *this</li></ol><p><strong>this指针的本质是指针常量，指针指向不能修改。</strong></p><p>例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> (<span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="comment">//this指针指向的是被调用成员函数所属的对象</span></span><br><span class="line">        <span class="keyword">this</span> -&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//this是指向p2的指针</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1&#x27;s age is &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、返回对象本身用 *this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2&#x27;s age is &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、空指针访问成员函数">3、空指针访问成员函数</h3><p>C++中，空指针是可以访问成员函数的。</p><p>如果用到了this指针，就需要对指针是否为空进行判定。</p><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//报错原因是传入的指针为null，需要进行判定</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person *p = <span class="literal">NULL</span>;</span><br><span class="line">    p -&gt; <span class="built_in">showClassName</span>();</span><br><span class="line">    p -&gt; <span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、常函数和常对象">4、常函数和常对象</h3><p>常函数：</p><ol><li>成员函数后加const称这个函数为常函数</li><li>常函数内不能修改成员属性</li><li>成员属性声明时加关键词mutable，在常函数中依然可以修改</li></ol><p>常对象：</p><ol><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ol><p>例4：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// const Person * const this;</span></span><br><span class="line">    <span class="comment">//在成员函数后面加const，修饰的是this指向，使指针指向的值不可以修改</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this -&gt; m_A = 100;</span></span><br><span class="line">        <span class="comment">// this = NULL; //this指针不能修改指针指向</span></span><br><span class="line">        <span class="keyword">this</span> -&gt; m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_B = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，加mutable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Person p; <span class="comment">//在对象前加const，变为常对象</span></span><br><span class="line">    <span class="comment">// p.m_A = 100;</span></span><br><span class="line">    p.m_B = <span class="number">100</span>; <span class="comment">//m_B是特殊值，在常对象下可以修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="comment">//p.func(); //常对象不能调用普通成员函数，因为普通成员函数可以修改属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、友元">五、友元</h2><p>在程序里，有些私有属性也想让类外一些特殊的函数或类进行访问，这就需</p><p>要用到友元。</p><p><strong>友元的目的，就是让一个函数或类访问另一个类中的私有成员。</strong></p><p>友元的关键字 friend。</p><p>友元有三种实现方式：</p><ol><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ol><h3 id="1、全局函数做友元">1、全局函数做友元</h3><p><strong>如果需要全局函数做友元，就把全局函数的 <em>返回类型 函数名(参数列表)</em> 部分复制</strong></p><p><strong>粘贴到类的前面，然后在语句前加关键字friend。</strong></p><p>例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元</span></span><br><span class="line"><span class="comment">//目的：让一个函数或者类 访问另一个类中私有成员</span></span><br><span class="line"><span class="comment">//关键词：friend</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="comment">//goodFriend 是building的友元，可以访问私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Building *building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>() &#123;</span><br><span class="line">        m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Good Friend is founding &quot;</span> &lt;&lt; building -&gt; m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Good Friend is founding &quot;</span> &lt;&lt; building -&gt; m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Building building;</span><br><span class="line">    <span class="built_in">goodFriend</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、类做友元">2、类做友元</h3><p><strong>和全局函数做友元同理，如果类做友元，只需要将 <em>class 做友元的类名</em>   复制</strong></p><p><strong>粘贴到另一个类的前面，然后在语句前加入关键字friend。</strong></p><p>例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类作友元</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodFriend</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodFriend</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//参观函数 访问building中的属性</span></span><br><span class="line"></span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="comment">//GoodFriend是本类的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodFriend</span>; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外写成员函数</span></span><br><span class="line">Building :: <span class="built_in">Building</span>() &#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodFriend :: <span class="built_in">GoodFriend</span>() &#123;</span><br><span class="line">    <span class="comment">//创建建筑物对象</span></span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GoodFriend :: <span class="built_in">visit</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Good Friend is visiting &quot;</span> &lt;&lt; building -&gt; m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Good Friend is visiting &quot;</span> &lt;&lt; building -&gt; m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GoodFriend gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、成员函数做友元">3、成员函数做友元</h3><p><strong>成员函数做友元，只需要将 <em>返回类型 成员函数所属类 ：：做友元的函数名</em></strong></p><p><strong><em>(参数列表)</em> 输入到另一个类的前面，然后在语句前加入关键字friend。</strong></p><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodFriend</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodFriend</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//visit函数可以访问Buil中私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; <span class="comment">//visit2函数不可以访问Building中私有成员</span></span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="comment">//GoodFriend下visit函数作为building的友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> GoodFriend :: <span class="built_in">visit</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building :: <span class="built_in">Building</span>() &#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodFriend :: <span class="built_in">GoodFriend</span>() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GoodFriend :: <span class="built_in">visit</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; building -&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; building -&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> GoodFriend :: <span class="built_in">visit2</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; building -&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;visit &quot; &lt;&lt; building -&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GoodFriend gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">    <span class="comment">//gg.visit2();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、继承">六、继承</h2><p>继承是面向对象三大特性之一。</p><p>有些类与类之间具有共性，此时就可以使用继承，减少重复代码。</p><p>继承的好处：减少重复代码。</p><p><strong>语法：class 子类 : 继承方式 父类</strong></p><p>其中，子类又称为派生类，父类又称为基类。</p><p>例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="comment">// class Java &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     void header() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;首页 公开课 注册 登录&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void footer() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;帮助中心 站内地图&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void left() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Java、Python、C/C++&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void content() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Java视频&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Python &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     void header() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;首页 公开课 注册 登录&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void footer() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;帮助中心 站内地图&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void left() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Java、Python、C/C++&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void content() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Python视频&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class C &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     void header() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;首页 公开课 注册 登录&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void footer() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;帮助中心 站内地图&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void left() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Java、Python、C/C++&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void content() &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;C++视频&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void test01() &#123;</span></span><br><span class="line"><span class="comment">//    Java ja;</span></span><br><span class="line"><span class="comment">//    ja.header();</span></span><br><span class="line"><span class="comment">//    ja.footer();</span></span><br><span class="line"><span class="comment">//    ja.left();</span></span><br><span class="line"><span class="comment">//    ja.content();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;===============&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    Python py;</span></span><br><span class="line"><span class="comment">//    py.header();</span></span><br><span class="line"><span class="comment">//    py.footer();</span></span><br><span class="line"><span class="comment">//    py.left();</span></span><br><span class="line"><span class="comment">//    py.content();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;===============&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    C c;</span></span><br><span class="line"><span class="comment">//    c.header();</span></span><br><span class="line"><span class="comment">//    c.footer();</span></span><br><span class="line"><span class="comment">//    c.left();</span></span><br><span class="line"><span class="comment">//    c.content();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页 公开课 注册 登录&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心 站内地图&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C/C++&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、继承方式">1、继承方式</h3><p><strong>继承有三种方式：公共继承、保护继承、私有继承。</strong></p><p>公共继承：</p><ol><li>父类中公共权限成员，到了子类中依然是公共权限。</li><li>父类中保护权限成员，到了子类中依然是保护权限。</li><li>父类中私有权限成员，到了子类中无法访问。</li></ol><p>保护继承：</p><ol><li>父类中公共权限成员，到了子类变为保护权限。</li><li>父类中保护权限成员，到了子类依然是保护权限。</li><li>父类中私有权限成员，到了子类中无法访问。</li></ol><p>私有继承：</p><ol><li>父类中公共权限成员，到了子类变为私有权限。</li><li>父类中保护权限成员，到了子类变成私有权限。</li><li>父类中私有权限成员，子类无法访问。</li></ol><p>例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方式</span></span><br><span class="line"><span class="comment">//公共继承，保护继承，私有继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_A = <span class="number">10</span>; <span class="comment">//父类中公共权限成员 到子类中依然是公共权限</span></span><br><span class="line">        m_B = <span class="number">10</span>; <span class="comment">//父类中保护权限成员 到子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">// m_C = 10; //父类中私有权限成员 到子类中无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    s1.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// s1.m_B = 100; //保护权限不能在类外访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">protected</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">//公共成员 到子类变为保护权限</span></span><br><span class="line">        m_B = <span class="number">100</span>;</span><br><span class="line">        m_C = <span class="number">100</span>; <span class="comment">//父类中私有成员 到子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son2 s1;</span><br><span class="line">    s1.m_A = <span class="number">100</span>; <span class="comment">//m_A保护权限，类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> : <span class="keyword">private</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">//父类中公共成员到子类变成私有成员</span></span><br><span class="line">        m_B = <span class="number">100</span>; <span class="comment">//父类中保护成员到子类变成私有成员</span></span><br><span class="line">        <span class="comment">// m_C = 100; //父类中私有成员，子类无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> : <span class="keyword">public</span> Son3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_A = <span class="number">1000</span>; <span class="comment">//到了Son3中，m_A为私有，无法访问</span></span><br><span class="line">        m_B = <span class="number">1000</span>; <span class="comment">//到了Son3中，m_A为私有，无法访问</span></span><br><span class="line">        m_C = <span class="number">1000</span>; <span class="comment">//到了Son3中，m_A为私有，无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son3 s1;</span><br><span class="line">    <span class="comment">// s1.m_A = 1000; //到Son3中变为私有成员，类外无法访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、继承中的对象模型">2、继承中的对象模型</h3><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中的对象模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of Son is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个案例，最终输出应该是16。</p><p>继承中，<strong>父类的所有非静态成员属性都会被子类继承。父类的私有成员属性被编译器隐藏，因而无</strong></p><p><strong>法访问，但是继承下来了。</strong></p><h3 id="3、继承中构造与析构顺序">3、继承中构造与析构顺序</h3><p>继承中构造和析构顺序：</p><p><strong>父类先构造，子类再构造。</strong></p><p><strong>析构顺序与构造顺序相反。</strong></p><p>例4：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中构造和析构顺序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base Distructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son Distructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base b;</span></span><br><span class="line">    Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、继承中同名成员处理">4、继承中同名成员处理</h3><p>当子类和父类出现同名成员时，如果要<strong>访问子类中成员，可以直接访问</strong>；如</p><p>果<strong>访问父类中成员，则需要加作用域</strong>。</p><p>例5：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中同名成员处理方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base-func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base-func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son-func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名属性处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base :: m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//如果通过子类对象访问同名父类中同名成员，需要加作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名函数处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>(); <span class="comment">//直接调用子类中成员函数</span></span><br><span class="line">    s.Base :: <span class="built_in">func</span>(); <span class="comment">//调用父类中同名成员函数，加作用域</span></span><br><span class="line">    s.Base :: <span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//如果子类中出现和父类同名的成员函数，子类的同名成员函数会隐藏掉父类中所有同名成员函数</span></span><br><span class="line">    <span class="comment">//如果访问父类中被隐藏的同名成员函数，需要加作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、继承中同名静态成员处理">5、继承中同名静态成员处理</h3><p>静态成员和非静态成员出现同名成员处理方式相同。<strong>访问子类成员可以直</strong></p><p><strong>接访问</strong>，<strong>访问父类成员需要加作用域</strong>。</p><p>例6：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中同名静态成员处理方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base-static func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base-static func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base :: m_A = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son-static func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son :: m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base :: m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; Son :: m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第一个：：代表通过类名访问</span></span><br><span class="line">    <span class="comment">//第二个：：代表访问父类作用域下的属性</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; Son :: Base :: m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base :: <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    <span class="comment">//第一个：：代表通过类名访问</span></span><br><span class="line">    <span class="comment">//第二个：：代表访问父类作用域下的函数</span></span><br><span class="line">    Son :: <span class="built_in">func</span>();</span><br><span class="line">    Son :: Base :: <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//如果子类中出现和父类同名的静态成员函数，子类的同名成员函数会隐藏掉父类中所有同名成员函数</span></span><br><span class="line">    <span class="comment">//如果访问父类中被隐藏的同名静态成员函数，需要加作用域</span></span><br><span class="line">    Son :: Base :: <span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、多继承">6、多继承</h3><p>C++允许一个类继承多个类。</p><p><strong>语法：class 子类 : 继承方式 父类1, 继承方式 父类2……</strong></p><p>多继承可能会导致不同父类有同名成员出现，这时候需要加作用域加以区</p><p>分。</p><p><strong>实际开发不建议使用多继承。</strong></p><p>例7：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类需要继承base1和base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="comment">//16</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of Son is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//当父类中出现同名成员，需要加作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;base1 m_A = &quot;</span> &lt;&lt; s.Base1 :: m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;base2 m_A = &quot;</span> &lt;&lt; s.Base2 :: m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、菱形继承">7、菱形继承</h3><p>菱形继承，是指有两个子类继承同一个父类，又有某一个类同时继承这两个</p><p>子类，这样形成的继承关系就是菱形继承。</p><p>菱形继承中可能出现同名成员的问题，可以采用<strong>虚继承</strong>解决这个问题。</p><p>在继承前加上关键字virtual就变为虚继承。</p><p>例8：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菱形继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用虚继承解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前加入关键词 virtual 变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类变为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep :: m_Age = <span class="number">28</span>;</span><br><span class="line">    st.Tuo :: m_Age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">//当菱形继承，两个父类拥有相同数据，需要加以作用域区分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep :: m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo :: m_Age = &quot;</span> &lt;&lt; st.Tuo :: m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//这份数据只要一份就可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、多态">七、多态</h2><h3 id="1、多态基础">1、多态基础</h3><p>多态是面向对象三大特性之一。</p><p>多态可分为<strong>静态多态</strong>和<strong>动态多态</strong>。</p><table><thead><tr><th>静态多态</th><th>动态多态</th></tr></thead><tbody><tr><td>函数地址早绑定，编译期间确定地址</td><td>函数地址晚绑定，运行期间确定地址</td></tr></tbody></table><p>多态的条件：</p><ol><li>有继承关系</li><li>子类要重写父类中的虚函数 重写：函数返回值 函数名 参数列表 完全相同</li></ol><p>多态使用：<strong>父类的指针或引用，执行子类对象</strong>。</p><p>例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal is speaking&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类重写父类的虚函数</span></span><br><span class="line"><span class="comment">//子类的虚函数表内部会替换成子类的虚函数地址</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat is speaking&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog is speaking&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行说话函数</span></span><br><span class="line"><span class="comment">//地址早绑定，在编译阶段就确定地址</span></span><br><span class="line"><span class="comment">//如果想执行让猫说话，那么函数地址就不能提前绑定，需要运行阶段进行绑定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">doSpeak</span>(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">doSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of Animal = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Animal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的优点：</p><ol><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的维护</li></ol><p>例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态优点</span></span><br><span class="line"><span class="comment">//代码组织结构清晰</span></span><br><span class="line"><span class="comment">//可读性强</span></span><br><span class="line"><span class="comment">//利于前期和后期的维护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">    c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现计算器抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> : <span class="keyword">public</span> AbstractCal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> : <span class="keyword">public</span> AbstractCal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul</span> : <span class="keyword">public</span> AbstractCal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractCal *abc = <span class="keyword">new</span> Add;</span><br><span class="line">    abc -&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc -&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc -&gt;m_Num1 &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; abc -&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc -&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">    abc = <span class="keyword">new</span> Sub;</span><br><span class="line">    abc -&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc -&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc -&gt;m_Num1 &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; abc -&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc -&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">    abc = <span class="keyword">new</span> Mul;</span><br><span class="line">    abc -&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    abc -&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; abc -&gt;m_Num1 &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; abc -&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc -&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、纯虚函数和抽象类">2、纯虚函数和抽象类</h3><p>虚函数可以改写为纯虚函数。</p><p><strong>语法：virtual 返回类型 函数名(参数) = 0;</strong></p><p><strong>当类中有纯虚函数时，这个类就称为抽象类。</strong></p><p>抽象类的特点：</p><ol><li>抽象类无法实例化</li><li>子类必须重写抽象类中纯虚函数，否则也是抽象类</li></ol><p>例3：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="comment">//无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写抽象类中纯虚函数，否则也是抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base b;//无法实例化对象</span></span><br><span class="line">    Base *base = <span class="keyword">new</span> Son;</span><br><span class="line">    base -&gt; <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、虚析构与纯虚析构">2、虚析构与纯虚析构</h3><p>多态使用时，如果子类有属性开辟到堆区，那么父类指针释放时无法调用到</p><p>子类的析构代码。</p><p>解决：<strong>将父类中的析构改为虚析构或纯虚析构。</strong></p><p>共性：<strong>可以解决父类指针释放子类对象的问题、都需要具体函数实现。</strong></p><p>区别：<strong>如果是纯虚析构，则该类属于抽象类，无法实例化对象。</strong></p><p>例4：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//虚析构可以解决父类指针释放子类对象时不干净的问题</span></span><br><span class="line">    <span class="comment">// virtual ~Animal() &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Animal Destructor&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//纯虚析构 需要声明也需要实现</span></span><br><span class="line">    <span class="comment">//有了纯虚析构后，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal :: ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot; is speaking&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string *m_Name;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal -&gt; <span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我写博客的起点，第一篇技术博客</summary>
    
    
    
    <category term="技术" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="编程语言" scheme="https://yonagi04.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://yonagi04.github.io/tags/C/"/>
    
    <category term="面向对象" scheme="https://yonagi04.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
