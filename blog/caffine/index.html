<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.ico" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/favicon.ico" media="(prefers-color-scheme: light)"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v4.16.18"><!-- Font preloads --><link rel="preload" href="/_astro/inter-latin-400-normal.BOOGhInR.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/inter-latin-600-normal.D273HNI0.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-400-normal.CvHVDnm4.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-600-normal.DUWh3m6k.woff2" as="font" type="font/woff2" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://yonagi04.github.io/blog/caffine/"><!-- Primary Meta Tags --><title>Java最强本地缓存——Caffeine | Yonagi&#39;s Sekai</title><meta name="title" content="Java最强本地缓存——Caffeine | Yonagi's Sekai"><meta name="description" content="Article: Java最强本地缓存——Caffeine"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://yonagi04.github.io/blog/caffine/"><meta property="og:title" content="Java最强本地缓存——Caffeine | Yonagi's Sekai"><meta property="og:description" content="Article: Java最强本地缓存——Caffeine"><meta property="og:image" content="https://yonagi04.github.io/nano.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://yonagi04.github.io/blog/caffine/"><meta property="twitter:title" content="Java最强本地缓存——Caffeine | Yonagi's Sekai"><meta property="twitter:description" content="Article: Java最强本地缓存——Caffeine"><meta property="twitter:image" content="https://yonagi04.github.io/nano.png"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script>
  function init() {
    preloadTheme();
    onScroll();
    animate();

    const backToTop = document.getElementById("back-to-top");
    backToTop?.addEventListener("click", (event) => scrollToTop(event));

    const backToPrev = document.getElementById("back-to-prev");
    backToPrev?.addEventListener("click", () => window.history.back());

    const lightThemeButton = document.getElementById("light-theme-button");
    lightThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "light");
      toggleTheme(false);
    });

    const darkThemeButton = document.getElementById("dark-theme-button");
    darkThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "dark");
      toggleTheme(true);
    });

    const systemThemeButton = document.getElementById("system-theme-button");
    systemThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "system");
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    });

    window.matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", event => {
        if (localStorage.theme === "system") {
          toggleTheme(event.matches);
        }
      }
    );

    document.addEventListener("scroll", onScroll);
  }

  function animate() {
    const animateElements = document.querySelectorAll(".animate");

    animateElements.forEach((element, index) => {
      setTimeout(() => {
        element.classList.add("show");
      }, index * 150);
    });
  }

  function onScroll() {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }
  }

  function scrollToTop(event) {
    event.preventDefault();
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  }

function toggleTheme(dark) {
    const css = document.createElement("style");

    css.appendChild(
      document.createTextNode(
        `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
      )
    );

    document.head.appendChild(css);

    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }

  window.getComputedStyle(css).opacity;
    document.head.removeChild(css);
  }

  function preloadTheme() {
    const userTheme = localStorage.theme;

    if (userTheme === "light" || userTheme === "dark") {
      toggleTheme(userTheme === "dark");
    } else {
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }

  document.addEventListener("DOMContentLoaded", () => init());
  document.addEventListener("astro:after-swap", () => init());
  preloadTheme();
</script><link rel="stylesheet" href="/_astro/_slug_.DNSn8Jsb.css"><script type="module" src="/_astro/hoisted.RlhmG3H2.js"></script></head> <body> <header> <link rel="stylesheet" href="https://unpkg.com/katex@0.16.9/dist/katex.min.css" integrity="sha384-5IMT6/8xSOPdFjD/xHw5/R5S8QvP4sYf6T0rXG6L4PjS0N0J5O5F4M0E0X0F0V0F" crossorigin="anonymous"> <div class="mx-auto max-w-screen-sm px-5">  <div class="flex flex-wrap gap-y-2 justify-between"> <a href="/">  <div class="font-semibold"> Yonagi&#39;s Sekai </div>  </a> <nav class="flex gap-1"> <a href="/blog"> 
Blog
 </a> <span>    </span> <a href="/rss.xml" class="flex items-center px-2 underline" aria-label="RSS Feed">  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-white-500"> <circle cx="6.18" cy="17.82" r="2.18"></circle> <path d="M4 4.44v3.06a12.5 12.5 0 0 1 12.5 12.5h3.06C19.56 10.61 13.39 4.44 4 4.44z"></path> <path d="M4 10.69v3.06a6.25 6.25 0 0 1 6.25 6.25h3.06A9.31 9.31 0 0 0 4 10.69z"></path> </svg>  </a> </nav> </div>  </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-5"> <div class="space-y-1 my-10"> <div class="animate text-2xl font-semibold text-black dark:text-white"> Java最强本地缓存——Caffeine </div> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> <time datetime="2024-07-25T09:47:32.000Z"> 2024年7月25日 </time> </div>
&bull;
<div class="font-base text-sm"> 4 min read </div> </div> <div class="animate font-base text-sm">
Categories: 未分类 </div> <div class="animate font-base text-sm">
Tags: 无 </div> </div> <article class="animate"> <p>缓存（Cache）在计算机中无处不在。缓存本质上是一种用空间换时间的手段——通过将数据存储在更快的存储媒介上，减少响应的时间，使得下一次访问这些数据的时候能够获得加速的效果。从缓存类型来看，缓存还分为 <strong>本地缓存</strong> 和 <strong>分布式缓存</strong> 两种类型。分布式缓存（如 Redis 集群）除了要解决数据读取效率问题外，还要解决集群环境下的数据不一致问题。本文将简单地介绍一种高性能的本地缓存库——Caffeine，以及Caffeine 的使用、驱逐策略、刷新策略，以及如何在 SpringBoot 中使用 Caffeine</p>
<h2 id="caffeine-简介">Caffeine 简介</h2>
<p><a href="https://github.com/ben-manes/caffeine">Caffeine</a> 是基于Java 1.8的高性能本地缓存库，由 Guava 演变而来，它的性能比Guava也更好，官方声称在基准测试中， <a href="https://github.com/ben-manes/caffeine/wiki/Benchmarks">Caffeine 的缓存命中率已经接近于最优值</a>，且 <a href="https://github.com/ben-manes/caffeine/wiki/Memory-overhead">Caffeine 的内存占用情况也优于 Guava</a></p>
<p>实际上，Caffeine 这种本地缓存和 ConcurrentHashMap 很像——都支持并发，都支持 O(1) 时间复杂度的存取。两者的主要区别在于：</p>
<ul>
<li>ConcurrentHashMap 会存储所有存入的数据，且数据移除需要进行显式的操作</li>
<li>Caffeine 将通过给定的配置，自动移除不常用的数据，节约内存空间</li>
</ul>
<p>因此，我们可以粗略地将Caffeine视为带有淘汰策略的ConcurrentHashMap</p>
<p>根据 Caffeine 官方提供的文档，Caffeine提供的功能如下：</p>
<ul>
<li><a href="https://github.com/ben-manes/caffeine/wiki/Population-zh-CN">自动加载</a>元素到缓存当中，异步加载的方式也可供选择</li>
<li>当达到最大容量的时候可以使用基于<a href="https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN">就近度和频率</a>的算法进行<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%AE%B9%E9%87%8F">基于容量的驱逐</a></li>
<li>将根据缓存中的元素上一次访问或者被修改的时间进行<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4">基于过期时间的驱逐</a></li>
<li>当向缓存中一个已经过时的元素进行访问的时候将会进行<a href="https://github.com/ben-manes/caffeine/wiki/Refresh-zh-CN">异步刷新</a></li>
<li>key将自动被<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8">弱引用</a>所封装</li>
<li>value将自动被<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8">弱引用或者软引用</a>所封装</li>
<li>驱逐(或移除)缓存中的元素时将会进行<a href="https://github.com/ben-manes/caffeine/wiki/Removal-zh-CN">通知</a></li>
<li><a href="https://github.com/ben-manes/caffeine/wiki/Writer-zh-CN">写入传播</a>到一个外部数据源当中</li>
<li>持续计算缓存的访问<a href="https://github.com/ben-manes/caffeine/wiki/Statistics-zh-CN">统计指标</a></li>
</ul>
<h2 id="在-java-中使用-caffeine">在 Java 中使用 Caffeine</h2>
<p>为了使用 Caffeine，在 Maven 工程下引入以下依赖：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="xml"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">dependency</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">groupId</span><span style="color:#E1E4E8">>com.github.ben-manes.caffeine&#x3C;/</span><span style="color:#85E89D">groupId</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">artifactId</span><span style="color:#E1E4E8">>caffeine&#x3C;/</span><span style="color:#85E89D">artifactId</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">version</span><span style="color:#E1E4E8">>2.9.3&#x3C;/</span><span style="color:#85E89D">version</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;/</span><span style="color:#85E89D">dependency</span><span style="color:#E1E4E8">></span></span>
<span class="line"></span></code></pre>
<p>Caffeine 提供了四种缓存添加策略：手动加载，自动加载，手动异步加载和自动异步加载</p>
<h3 id="手动加载">手动加载</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">Cache&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> cache </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">expireAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">maximumSize</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10_000</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 查找一个缓存元素， 没有查找到的时候返回null</span></span>
<span class="line"><span style="color:#E1E4E8">Graph graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">getIfPresent</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"><span style="color:#6A737D">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span>
<span class="line"><span style="color:#E1E4E8">graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(key, k </span><span style="color:#F97583">-></span><span style="color:#B392F0"> createExpensiveGraph</span><span style="color:#E1E4E8">(key));</span></span>
<span class="line"><span style="color:#6A737D">// 添加或者更新一个缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">cache.</span><span style="color:#B392F0">put</span><span style="color:#E1E4E8">(key, graph);</span></span>
<span class="line"><span style="color:#6A737D">// 移除一个缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">cache.</span><span style="color:#B392F0">invalidate</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"></span></code></pre>
<p>Cache 接口提供了显式搜索查找、更新和移除缓存元素的能力</p>
<p><code>cache.put(key, value)</code> 操作将会直接写入或更新缓存中的缓存元素，在缓存中已经存在的该 key 对应的缓存值都会被直接覆盖</p>
<p><code>cache.get(key, k -> value)</code> 操作来在缓存中不存在该key对应的缓存元素的时候进行计算生成并直接写入至缓存内，而当该key对应的缓存元素存在的时候将会直接返回存在的缓存值。如果缓存的元素无法生成或在生成的过程中抛出了异常导致生成失败，<code>cache.get</code> 可能会返回null</p>
<p>通过调用 <code>cache.invalidate(key)</code> 方法来移除缓存</p>
<h3 id="自动加载">自动加载</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">LoadingCache&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> cache </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">maximumSize</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10_000</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">expireAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">-></span><span style="color:#B392F0"> createExpensiveGraph</span><span style="color:#E1E4E8">(key));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null</span></span>
<span class="line"><span style="color:#E1E4E8">Graph graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"><span style="color:#6A737D">// 批量查找缓存，如果缓存不存在则生成缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">Map&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> graphs </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">getAll</span><span style="color:#E1E4E8">(keys);</span></span>
<span class="line"></span></code></pre>
<p><code>LoadingCache</code> 是一个 <code>Cache</code> 附加上 <code>CacheLoader</code> 能力后的缓存实现</p>
<p>当缓存不存在时，如果调用了<code>get()</code>方法，则会调用<code>CacheLoader.load()</code>方法加载最新值。通过 <code>getAll()</code> 可以达到批量查找缓存的目的。通常情况下，<code>getAll()</code> 方法会对每个不存在对应缓存的key调用一次 <code>CacheLoader.load()</code> 来生成缓存元素</p>
<p>使用 <code>LoadingCache</code> 时，需要指定 <code>CacheLoader</code> ，并实现其中的 <code>load()</code> 方法供缓存缺失时的自动加载</p>
<h3 id="手动异步加载">手动异步加载</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">AsyncCache&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> cache </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">expireAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">maximumSize</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10_000</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">buildAsync</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 查找一个缓存元素， 没有查找到的时候返回null</span></span>
<span class="line"><span style="color:#E1E4E8">CompletableFuture&#x3C;</span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">getIfPresent</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"><span style="color:#6A737D">// 查找缓存元素，如果不存在，则异步生成</span></span>
<span class="line"><span style="color:#E1E4E8">graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(key, k </span><span style="color:#F97583">-></span><span style="color:#B392F0"> createExpensiveGraph</span><span style="color:#E1E4E8">(key));</span></span>
<span class="line"><span style="color:#6A737D">// 添加或者更新一个缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">cache.</span><span style="color:#B392F0">put</span><span style="color:#E1E4E8">(key, graph);</span></span>
<span class="line"><span style="color:#6A737D">// 移除一个缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">cache.</span><span style="color:#B392F0">synchronous</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">invalidate</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"></span></code></pre>
<p><code>AsyncCache</code> 是 <code>Cache</code> 的一个变体，响应结果均为 <code>CompletableFuture</code>。默认情况下，缓存计算使用 <code>ForkJoinPool.commonPool()</code>作为线程池，如果想要指定线程池，可以覆盖并实现 <code>Caffeine.executor(Executor)</code> 方法</p>
<p><code>synchronous()</code> 提供了阻塞直到异步缓存生成完毕的能力，它将以 Cache 进行返回</p>
<h3 id="自动异步加载">自动异步加载</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">AsyncLoadingCache&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> cache </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">maximumSize</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10_000</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">expireAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.MINUTES)</span></span>
<span class="line"><span style="color:#6A737D">    // 你可以选择: 去异步的封装一段同步操作来生成缓存元素</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">buildAsync</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">-></span><span style="color:#B392F0"> createExpensiveGraph</span><span style="color:#E1E4E8">(key));</span></span>
<span class="line"><span style="color:#6A737D">    // 你也可以选择: 构建一个异步缓存元素操作并返回一个future</span></span>
<span class="line"><span style="color:#E1E4E8">    .</span><span style="color:#B392F0">buildAsync</span><span style="color:#E1E4E8">((key, executor) </span><span style="color:#F97583">-></span><span style="color:#B392F0"> createExpensiveGraphAsync</span><span style="color:#E1E4E8">(key, executor));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 查找缓存元素，如果其不存在，将会异步进行生成</span></span>
<span class="line"><span style="color:#E1E4E8">CompletableFuture&#x3C;</span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">> graph </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"><span style="color:#6A737D">// 批量查找缓存元素，如果其不存在，将会异步进行生成</span></span>
<span class="line"><span style="color:#E1E4E8">CompletableFuture&#x3C;Map&#x3C;</span><span style="color:#F97583">Key</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">Graph</span><span style="color:#E1E4E8">>> graphs </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cache.</span><span style="color:#B392F0">getAll</span><span style="color:#E1E4E8">(keys);</span></span>
<span class="line"></span></code></pre>
<p>一个 <code>AsyncLoadingCache</code> 是一个 <code>AsyncCache</code> 加上 <code>AsyncCacheLoader</code> 能力的实现</p>
<p>与自动加载 <code>LoadingCache</code> 类似，<code>AsyncLoadingCache</code> 也需要指定 <code>CacheLoader</code> ，同时需要实现 <code>load()</code> 方法供供缓存缺失时的自动加载。</p>
<p>默认以 <code>ForkJoinPool.commonPool()</code>作为线程池来提交，如果想要指定线程池，可以覆盖并实现 <code>AsyncCacheLoader.aysncLoad()</code> 方法</p>
<h3 id="驱逐策略">驱逐策略</h3>
<p>驱逐策略在创建缓存的时候进行指定。常用的有基于容量的驱逐和基于时间的驱逐。基于容量的驱逐需要指定缓存容量的最大值。当缓存容量达到最大时，Caffeine将使用LRU策略对缓存进行淘汰；基于时间的驱逐策略如字面意思，可以设置在最后访问/写入一个缓存经过指定时间后，自动进行淘汰。</p>
<p>驱逐策略可以自由组合，在任意驱逐策略生效后，该缓存将会被清除</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#6A737D">// 创建最大容量为1000的缓存</span></span>
<span class="line"><span style="color:#E1E4E8">Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">maximumSize</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">).</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 创建一个写入10h后过期的缓存</span></span>
<span class="line"><span style="color:#E1E4E8">Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">expireAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.HOURS).</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 创建一个访问1h后过期的缓存</span></span>
<span class="line"><span style="color:#E1E4E8">Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">expireAfterAccess</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, TimeUnit.HOURS).</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span></code></pre>
<h3 id="刷新机制">刷新机制</h3>
<p>刷新机制与驱逐完全不同，它可以通过 <code>LoadingCache.refresh(K)</code> 方法，异步地为 key 对应的缓存元素刷新一个新的值。与驱逐不同的是，在刷新时候如果查询缓存元素，其旧值将会被返回，知道元素刷新完毕后才能返回刷新后的新值</p>
<p>使用 <code>refreshAfterWrite()</code> 机制，Caffeine将在 key 允许刷新后的首次访问时，立即返回旧值，同时异步地对缓存值进行刷新，使得调用方不至于因为缓存驱逐而被阻塞。刷新机制只能适用于自动加载和自动异步加载</p>
<p>通过覆写 <code>Cache.reload()</code> 方法，将在刷新时使得旧缓存值参与其中</p>
<p>刷新操作将会异步执行在一个 <code>Executor</code> 上，默认的线程池实现是 <code>ForkJoinPool.commonPool()</code> ，也可以通过覆盖 <code>Caffeine.executor(Executor)</code> 方法自定义线程池的实现</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">Caffeine.</span><span style="color:#B392F0">newBuilder</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">refreshAfterWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, TimeUnit.MINUTES).</span><span style="color:#B392F0">build</span><span style="color:#E1E4E8">(k </span><span style="color:#F97583">-></span><span style="color:#B392F0"> create</span><span style="color:#E1E4E8">(k));</span></span>
<span class="line"></span></code></pre>
<h3 id="统计">统计</h3>
<p>Caffeine 内置了数据收集功能，通过 <code>Caffeine.recordStats()</code> 方法可以打开数据收集功能。<code>Cache.stats()</code> 方法将会返回一个 <code>CacheStats</code> 对象，将会包含一些统计指标，例如</p>
<ul>
<li><code>hitRate()</code> 缓存命中率</li>
<li><code>evictionCount()</code> 被驱逐的缓存数量</li>
<li><code>averageLoadPenalty()</code> 新值被载入的平均耗时</li>
</ul>
<h2 id="在-springboot-中使用-caffeine">在 SpringBoot 中使用 Caffeine</h2>
<p>除了上面提及的方法之外，在 SpringBoot框架中，我们有一些更加方便的配置方法和管理功能</p>
<h3 id="springboot-缓存管理器">SpringBoot 缓存管理器</h3>
<p>Spring从3.1版本开始就引入了对 Cache 的支持。定义了 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口，来统一不同的缓存技术，支持使用 <code>JCache(JSR-107)</code> 注解来简化开发</p>
<ul>
<li>Cache 接口包括了对缓存的各种操作集合，实际操作缓存时，是通过这些接口进行操作</li>
<li>Cache 接口下提供了各种 xxxCache 的实现，由于 Spring 从2.0版本后把默认的缓存组件由 Guava 替换为 Caffeine，因此这里需要用到的就是 <code>CaffeineCache</code> 类。</li>
<li>CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的的 Cache。这些 Cache 存在于 CacheManager 的上下文中</li>
</ul>
<p>创建缓存管理器</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#E1E4E8">@</span><span style="color:#F97583">Bean</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#E1E4E8"> CacheManager </span><span style="color:#B392F0">cacheManager</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    SimpleCacheManager cacheManager </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> SimpleCacheManager</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    ArrayList&#x3C;</span><span style="color:#F97583">CaffeineCache</span><span style="color:#E1E4E8">> caches </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#E1E4E8"> ArrayList&#x3C;>();</span></span>
<span class="line"><span style="color:#E1E4E8">    caches.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> CaffeineCache</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">cacheName</span><span style="color:#E1E4E8">(), </span><span style="color:#B392F0">generateCache</span><span style="color:#E1E4E8">()));</span></span>
<span class="line"><span style="color:#E1E4E8">    cacheManager.</span><span style="color:#B392F0">setCaches</span><span style="color:#E1E4E8">(caches);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> cacheManager;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<p>需要注意的是，Spring 只支持手动加载和自动加载缓存，无法支持异步缓存</p>
<h3 id="使用-cacheable-注解">使用 @Cacheable 注解</h3>
<p>为了使用 @Cacheable 注解，需要引入 Maven 依赖</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="xml"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">dependency</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">groupId</span><span style="color:#E1E4E8">>org.springframework.boot&#x3C;/</span><span style="color:#85E89D">groupId</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">artifactId</span><span style="color:#E1E4E8">>spring-boot-starter-cache&#x3C;/</span><span style="color:#85E89D">artifactId</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;/</span><span style="color:#85E89D">dependency</span><span style="color:#E1E4E8">></span></span>
<span class="line"></span></code></pre>
<p>与 @Cacheable 相关的常用注解包括：</p>
<ul>
<li>@Cachable：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而是从缓存中直接返回。</li>
<li>@CachePut：表示执行该方法后，其值将作为最新结果更新到缓存中</li>
<li>@CacheEvict：表示执行该方法后，将执行缓存清除操作</li>
<li>@Caching：组合前三个注解</li>
</ul>
<h3 id="常用注解属性">常用注解属性</h3>
<p>@Cacheable 常用的注解属性如下：</p>
<ul>
<li><code>cacheNames/value</code>：缓存组件的名字，即 cacheManager 中缓存的名称</li>
<li><code>key</code>：缓存数据时使用的 key</li>
<li><code>keyGenerator</code>：key 和 keyGenerator 二选一</li>
<li><code>cacheManager</code>：指定使用的缓存管理器</li>
<li><code>condition</code>：在方法执行开始前检查，在符合 condition 的情况下，进行缓存</li>
<li><code>unless</code>：在方法执行完成后检查，在符合 unless 的情况下，进行缓存</li>
<li><code>sync</code>：是否进行同步模式，若使用同步模式，在多个线程同时对一个 key 进行 load 时，其他线程将被阻塞</li>
</ul>
<h3 id="缓存同步模式">缓存同步模式</h3>
<p>@Cacheable 注解支持配置同步模式，在不同的 Caffeine 配置下，对是否开启同步模式进行观察</p>



































<table><thead><tr><th>Caffeine缓存类型</th><th>是否开启同步</th><th>多线程读取不存在/被驱逐的 key</th><th>多线程读取待刷新的 key</th></tr></thead><tbody><tr><td>Cache</td><td>否</td><td>各自独立执行被注解方法</td><td>-</td></tr><tr><td>Cache</td><td>是</td><td>线程1执行被注解方法，线程2阻塞，直到缓存更新完成</td><td>-</td></tr><tr><td>LoadingCache</td><td>否</td><td>线程1执行 <code>load()</code>，线程2被阻塞，直到缓存更新完成</td><td>线程1使用旧值立即返回，并异步更新缓存值；线程2立即返回，不进行更新</td></tr><tr><td>LoadingCache</td><td>是</td><td>线程1执行被注解方法，线程2阻塞，直到缓存更新完成</td><td>线程1使用旧值立即返回，并异步更新缓存值；线程2立即返回，不进行更新</td></tr></tbody></table>
<ul>
<li>在 Cache 中，sync 表示是否需要所有线程同步等待</li>
<li>在 LoadingCache 中，sync 表示在读取不存在/被驱逐的 key 时，是否执行被注解方法</li>
</ul> </article>  </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-5">   <div class="flex justify-between items-center"> <div>
&copy; 2025 | Yonagi&#39;s Sekai </div> <!-- <div class="flex flex-wrap gap-1 items-center">
        <button
          id="light-theme-button"
          aria-label="Light theme"
          class="group size-8 flex items-center justify-center rounded-full"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="1.5"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"
          >
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
          </svg>
        </button>
        <button
          id="dark-theme-button"
          aria-label="Dark theme"
          class="group size-8 flex items-center justify-center rounded-full"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="1.5"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"
          >
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
        <button
          id="system-theme-button"
          aria-label="System theme"
          class="group size-8 flex items-center justify-center rounded-full"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="1.5"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"
          >
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
            <line x1="8" y1="21" x2="16" y2="21"></line>
            <line x1="12" y1="17" x2="12" y2="21"></line>
          </svg>
        </button>
      </div> --> </div>  </div> </footer> </body></html>